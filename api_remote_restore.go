/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// RemoteRestoreApiService RemoteRestoreApi service
type RemoteRestoreApiService service

type ApiCreateRemoteVaultRestoreTaskRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
	Body *CreateRemoteVaultRestoreTaskParameters
}

/*

func (r ApiCreateRemoteVaultRestoreTaskRequest) Body(body CreateRemoteVaultRestoreTaskParameters) ApiCreateRemoteVaultRestoreTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateRemoteVaultRestoreTaskRequest) Execute() (UniversalId, *_nethttp.Response, error) {
	return r.ApiService.CreateRemoteVaultRestoreTaskExecute(r)
}

 * CreateRemoteVaultRestoreTask Create a remote Vault restore task. (CloudRetrieve)
 * Returns the id of the remote Vault restore Task that was created.

After a Vault is searched by a search Job, this operation can be
called to create a task that restores the indexes and/or the Snapshots
of a Protection Job, which were archived on a remote Vault (External Target).
This is part of the CloudRetrieve functionality for finding and restoring
archived data from remote Vaults to an alternative (non-original) Cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateRemoteVaultRestoreTaskRequest
 
func (a *RemoteRestoreApiService) CreateRemoteVaultRestoreTask(ctx _context.Context) ApiCreateRemoteVaultRestoreTaskRequest {
	return ApiCreateRemoteVaultRestoreTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RemoteRestoreApiService) CreateRemoteVaultRestoreTask(r ApiCreateRemoteVaultRestoreTaskRequest) (UniversalId, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return UniversalId{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateRemoteVaultRestoreTaskExecute(r)
}


/*
 * Execute executes the request
 * @return UniversalId
 */
func (a *RemoteRestoreApiService) CreateRemoteVaultRestoreTaskExecute(r ApiCreateRemoteVaultRestoreTaskRequest) (UniversalId, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UniversalId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.CreateRemoteVaultRestoreTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/restoreTasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRemoteVaultSearchJobRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
	Body *CreateRemoteVaultSearchJobParameters
}

/*

func (r ApiCreateRemoteVaultSearchJobRequest) Body(body CreateRemoteVaultSearchJobParameters) ApiCreateRemoteVaultSearchJobRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateRemoteVaultSearchJobRequest) Execute() (CreatedRemoteVaultSearchJobUid, *_nethttp.Response, error) {
	return r.ApiService.CreateRemoteVaultSearchJobExecute(r)
}

 * CreateRemoteVaultSearchJob Create a search of a remote Vault. (CloudRetrieve)
 * A search Job finds Protection Jobs that archived data to a
Vault (External Target) which also match the specified search criteria.
The results can be optionally filtered by specifying a Cluster match string,
a Protection Job match string, a start time and an end time.
This is part of the CloudRetrieve functionality for finding and restoring
archived data from remote Vaults to an alternative (non-original) Cluster.

NOTE: A Vault is equivalent to an External Target in the Cohesity Dashboard.
A search Job is equivalent to a search task in the Cohesity Dashboard.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateRemoteVaultSearchJobRequest
 
func (a *RemoteRestoreApiService) CreateRemoteVaultSearchJob(ctx _context.Context) ApiCreateRemoteVaultSearchJobRequest {
	return ApiCreateRemoteVaultSearchJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RemoteRestoreApiService) CreateRemoteVaultSearchJob(r ApiCreateRemoteVaultSearchJobRequest) (CreatedRemoteVaultSearchJobUid, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return CreatedRemoteVaultSearchJobUid{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateRemoteVaultSearchJobExecute(r)
}


/*
 * Execute executes the request
 * @return CreatedRemoteVaultSearchJobUid
 */
func (a *RemoteRestoreApiService) CreateRemoteVaultSearchJobExecute(r ApiCreateRemoteVaultSearchJobRequest) (CreatedRemoteVaultSearchJobUid, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreatedRemoteVaultSearchJobUid
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.CreateRemoteVaultSearchJob")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/searchJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRemoteVaultSearchJobResultsRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
	SearchJobId *int64
	ClusterId *int64
	ClusterIncarnationId *int64
	PageCount *int32
	ClusterName *string
	Cookie *string
}

/*

func (r ApiGetRemoteVaultSearchJobResultsRequest) SearchJobId(searchJobId int64) ApiGetRemoteVaultSearchJobResultsRequest {
	r.searchJobId = &searchJobId
	return r
}
func (r ApiGetRemoteVaultSearchJobResultsRequest) ClusterId(clusterId int64) ApiGetRemoteVaultSearchJobResultsRequest {
	r.clusterId = &clusterId
	return r
}
func (r ApiGetRemoteVaultSearchJobResultsRequest) ClusterIncarnationId(clusterIncarnationId int64) ApiGetRemoteVaultSearchJobResultsRequest {
	r.clusterIncarnationId = &clusterIncarnationId
	return r
}
func (r ApiGetRemoteVaultSearchJobResultsRequest) PageCount(pageCount int32) ApiGetRemoteVaultSearchJobResultsRequest {
	r.pageCount = &pageCount
	return r
}
func (r ApiGetRemoteVaultSearchJobResultsRequest) ClusterName(clusterName string) ApiGetRemoteVaultSearchJobResultsRequest {
	r.clusterName = &clusterName
	return r
}
func (r ApiGetRemoteVaultSearchJobResultsRequest) Cookie(cookie string) ApiGetRemoteVaultSearchJobResultsRequest {
	r.cookie = &cookie
	return r
}
*/

/*
func (r ApiGetRemoteVaultSearchJobResultsRequest) Execute() (RemoteVaultSearchJobResults, *_nethttp.Response, error) {
	return r.ApiService.GetRemoteVaultSearchJobResultsExecute(r)
}

 * GetRemoteVaultSearchJobResults List details about the Job Runs of Protection Jobs found by a single search of a remote Vault. (CloudRetrieve)
 * Specify a unique id of the search Job using a combination of the
searchJobId, clusterId, and clusterIncarnationId parameters,
which are all required.

The results can be optionally filtered by the remote Cluster name.
This is part of the CloudRetrieve functionality for finding and restoring
archived data from a remote Vault.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetRemoteVaultSearchJobResultsRequest
 
func (a *RemoteRestoreApiService) GetRemoteVaultSearchJobResults(ctx _context.Context) ApiGetRemoteVaultSearchJobResultsRequest {
	return ApiGetRemoteVaultSearchJobResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RemoteRestoreApiService) GetRemoteVaultSearchJobResults(r ApiGetRemoteVaultSearchJobResultsRequest) (RemoteVaultSearchJobResults, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RemoteVaultSearchJobResults{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetRemoteVaultSearchJobResultsExecute(r)
}


/*
 * Execute executes the request
 * @return RemoteVaultSearchJobResults
 */
func (a *RemoteRestoreApiService) GetRemoteVaultSearchJobResultsExecute(r ApiGetRemoteVaultSearchJobResultsRequest) (RemoteVaultSearchJobResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RemoteVaultSearchJobResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.GetRemoteVaultSearchJobResults")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/searchJobResults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.SearchJobId == nil {
		return localVarReturnValue, nil, reportError("SearchJobId is required and must be specified")
	}
	if r.ClusterId == nil {
		return localVarReturnValue, nil, reportError("ClusterId is required and must be specified")
	}
	if r.ClusterIncarnationId == nil {
		return localVarReturnValue, nil, reportError("ClusterIncarnationId is required and must be specified")
	}

	localVarQueryParams.Add("searchJobId", parameterToString(*r.SearchJobId, ""))
	localVarQueryParams.Add("clusterId", parameterToString(*r.ClusterId, ""))
	localVarQueryParams.Add("clusterIncarnationId", parameterToString(*r.ClusterIncarnationId, ""))
	if r.PageCount != nil {
		localVarQueryParams.Add("pageCount", parameterToString(*r.PageCount, ""))
	}
	if r.ClusterName != nil {
		localVarQueryParams.Add("clusterName", parameterToString(*r.ClusterName, ""))
	}
	if r.Cookie != nil {
		localVarQueryParams.Add("cookie", parameterToString(*r.Cookie, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRemoteVaultRestoreTasksRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
}

/*

*/

/*
func (r ApiListRemoteVaultRestoreTasksRequest) Execute() ([]RemoteVaultRestoreTaskStatus, *_nethttp.Response, error) {
	return r.ApiService.ListRemoteVaultRestoreTasksExecute(r)
}

 * ListRemoteVaultRestoreTasks List the remote Vault restore tasks that have completed or are running on this Cohesity Cluster. (CloudRetrieve)
 * A remote Vault restore task can restore archived data from a Vault
(External Target) to this local Cluster.
This is part of the CloudRetrieve functionality for finding and restoring
archived data from remote Vaults to an alternative (non-original) Cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListRemoteVaultRestoreTasksRequest
 
func (a *RemoteRestoreApiService) ListRemoteVaultRestoreTasks(ctx _context.Context) ApiListRemoteVaultRestoreTasksRequest {
	return ApiListRemoteVaultRestoreTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RemoteRestoreApiService) ListRemoteVaultRestoreTasks(r ApiListRemoteVaultRestoreTasksRequest) ([]RemoteVaultRestoreTaskStatus, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []RemoteVaultRestoreTaskStatus{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListRemoteVaultRestoreTasksExecute(r)
}


/*
 * Execute executes the request
 * @return []RemoteVaultRestoreTaskStatus
 */
func (a *RemoteRestoreApiService) ListRemoteVaultRestoreTasksExecute(r ApiListRemoteVaultRestoreTasksRequest) ([]RemoteVaultRestoreTaskStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []RemoteVaultRestoreTaskStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.ListRemoteVaultRestoreTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/restoreTasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRemoteVaultSearchJobByIdRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
	Id int64
}

/*

*/

/*
func (r ApiListRemoteVaultSearchJobByIdRequest) Execute() (RemoteVaultSearchJobInformation, *_nethttp.Response, error) {
	return r.ApiService.ListRemoteVaultSearchJobByIdExecute(r)
}

 * ListRemoteVaultSearchJobById List details about a single search Job of a remote Vault. (CloudRetrieve)
 * Specify an id for a completed or running search Job.
A search Job finds data that has been archived to a Vault (External Target).
The returned results do not include Job Run (Snapshot) information.
It is part of the CloudRetrieve functionality for finding and restoring
archived data from remote Vaults to an alternative (non-original) Cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies the id of the remote Vault search Job to return.
 * @return ApiListRemoteVaultSearchJobByIdRequest
 
func (a *RemoteRestoreApiService) ListRemoteVaultSearchJobById(ctx _context.Context, id int64) ApiListRemoteVaultSearchJobByIdRequest {
	return ApiListRemoteVaultSearchJobByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *RemoteRestoreApiService) ListRemoteVaultSearchJobById(r ApiListRemoteVaultSearchJobByIdRequest) (RemoteVaultSearchJobInformation, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RemoteVaultSearchJobInformation{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListRemoteVaultSearchJobByIdExecute(r)
}


/*
 * Execute executes the request
 * @return RemoteVaultSearchJobInformation
 */
func (a *RemoteRestoreApiService) ListRemoteVaultSearchJobByIdExecute(r ApiListRemoteVaultSearchJobByIdRequest) (RemoteVaultSearchJobInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RemoteVaultSearchJobInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.ListRemoteVaultSearchJobById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/searchJobs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRemoteVaultSearchJobsRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
}

/*

*/

/*
func (r ApiListRemoteVaultSearchJobsRequest) Execute() ([]RemoteVaultSearchJobInformation, *_nethttp.Response, error) {
	return r.ApiService.ListRemoteVaultSearchJobsExecute(r)
}

 * ListRemoteVaultSearchJobs List all the searches of remote Vaults. (CloudRetrieve)
 * List all the searches of remote Vaults (External Targets) that
have run or are running on this Cohesity Cluster.
A search finds Protection Jobs that have archived to a
Vault (External Target).
This is part of the CloudRetrieve functionality for finding and restoring
archived data from remote Vaults to an alternative (non-original) Cluster.

NOTE: A Vault is equivalent to an External Target in the Cohesity Dashboard.
A search Job is equivalent to a search task in the Cohesity Dashboard.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListRemoteVaultSearchJobsRequest
 
func (a *RemoteRestoreApiService) ListRemoteVaultSearchJobs(ctx _context.Context) ApiListRemoteVaultSearchJobsRequest {
	return ApiListRemoteVaultSearchJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RemoteRestoreApiService) ListRemoteVaultSearchJobs(r ApiListRemoteVaultSearchJobsRequest) ([]RemoteVaultSearchJobInformation, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []RemoteVaultSearchJobInformation{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListRemoteVaultSearchJobsExecute(r)
}


/*
 * Execute executes the request
 * @return []RemoteVaultSearchJobInformation
 */
func (a *RemoteRestoreApiService) ListRemoteVaultSearchJobsExecute(r ApiListRemoteVaultSearchJobsRequest) ([]RemoteVaultSearchJobInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []RemoteVaultSearchJobInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.ListRemoteVaultSearchJobs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/searchJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStopRemoteVaultSearchJobRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
	Body *StopRemoteVaultSearchJobParameters
}

/*

func (r ApiStopRemoteVaultSearchJobRequest) Body(body StopRemoteVaultSearchJobParameters) ApiStopRemoteVaultSearchJobRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiStopRemoteVaultSearchJobRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.StopRemoteVaultSearchJobExecute(r)
}

 * StopRemoteVaultSearchJob Stop a search of a remote Vault (External Target). (CloudRetrieve)
 * This is part of the CloudRetrieve functionality for finding and restoring
archived data from remote Vaults to an alternative (non-original) Cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiStopRemoteVaultSearchJobRequest
 
func (a *RemoteRestoreApiService) StopRemoteVaultSearchJob(ctx _context.Context) ApiStopRemoteVaultSearchJobRequest {
	return ApiStopRemoteVaultSearchJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RemoteRestoreApiService) StopRemoteVaultSearchJob(r ApiStopRemoteVaultSearchJobRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.StopRemoteVaultSearchJobExecute(r)
}


/*
 * Execute executes the request
 */
func (a *RemoteRestoreApiService) StopRemoteVaultSearchJobExecute(r ApiStopRemoteVaultSearchJobRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.StopRemoteVaultSearchJob")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/searchJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadVaultEncryptionKeysRequest struct {
	ctx _context.Context
	ApiService *RemoteRestoreApiService
	Id int64
	Body *[]VaultEncryptionKey
}

/*

func (r ApiUploadVaultEncryptionKeysRequest) Body(body []VaultEncryptionKey) ApiUploadVaultEncryptionKeysRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUploadVaultEncryptionKeysRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UploadVaultEncryptionKeysExecute(r)
}

 * UploadVaultEncryptionKeys Upload the encryption keys required to restore data from a remote Vault. (CloudRetrieve)
 * This request contains multiple files stored as multipart mime data.
Each file has a key used to encrypt data between a remote Cluster and the
remote Vault.
Content of the file should be same as the file downloaded from the remote
Cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Vault.
 * @return ApiUploadVaultEncryptionKeysRequest
 
func (a *RemoteRestoreApiService) UploadVaultEncryptionKeys(ctx _context.Context, id int64) ApiUploadVaultEncryptionKeysRequest {
	return ApiUploadVaultEncryptionKeysRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *RemoteRestoreApiService) UploadVaultEncryptionKeys(r ApiUploadVaultEncryptionKeysRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UploadVaultEncryptionKeysExecute(r)
}


/*
 * Execute executes the request
 */
func (a *RemoteRestoreApiService) UploadVaultEncryptionKeysExecute(r ApiUploadVaultEncryptionKeysRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RemoteRestoreApiService.UploadVaultEncryptionKeys")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/remoteVaults/encryptionKeys/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
