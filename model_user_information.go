/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"encoding/json"
)

// UserInformation A message to encapsulate information about the user who made the request. Request should be filtered by these fields if specified so that only the objects that the user is permissioned for are returned. If both sid_vec & tenant_id are specified then an intersection of respective results should be returned.
type UserInformation struct {
	// Whether objects owned by subtenants should be returned. This would require a prefix search with the passed tenant_id. All tenants are considered sub-tenants of the admin. For GET requests, if tenant id is empty(admin user is querying) and if this flag is false, we will only return untagged objects. If it is true, we will return everything.
	IncludeSubtenantObjects NullableBool `json:"includeSubtenantObjects,omitempty"`
	// Specifies the KeyValuePair that client (eg. Iris) wants to persist along with the corresponding (soon-to-be-created) Pulse task for the current action. Eg. pulse_attribute_vec can drive user notifications by associating a Pulse Task with user SID and later Pulse can be searched by client specified Sid to get all finished tasks for the logged in user.
	PulseAttributeVec []KeyValuePair `json:"pulseAttributeVec,omitempty"`
	// If specified, only the objects associated with these SIDs should be returned.
	SidVec []ClusterConfigProtoSID `json:"sidVec,omitempty"`
	// If specified, only the objects associated with this tenant should be returned. A given tenant ID is always a prefix of the ids of its subtenants. Eg. if tenant_id of cluster admin is empty string then it will be a prefix match for all the tenants on the cluster.
	TenantIdVec []string `json:"tenantIdVec,omitempty"`
}

// NewUserInformation instantiates a new UserInformation object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewUserInformation() *UserInformation {
	this := UserInformation{}
	return &this
}

// NewUserInformationWithDefaults instantiates a new UserInformation object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewUserInformationWithDefaults() *UserInformation {
	this := UserInformation{}
	return &this
}

// GetIncludeSubtenantObjects returns the IncludeSubtenantObjects field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UserInformation) GetIncludeSubtenantObjects() bool {
	if o == nil || o.IncludeSubtenantObjects.Get() == nil {
		var ret bool
		return ret
	}
	return *o.IncludeSubtenantObjects.Get()
}

// GetIncludeSubtenantObjectsOk returns a tuple with the IncludeSubtenantObjects field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UserInformation) GetIncludeSubtenantObjectsOk() (*bool, bool) {
	if o == nil  {
		return nil, false
	}
	return o.IncludeSubtenantObjects.Get(), o.IncludeSubtenantObjects.IsSet()
}

// HasIncludeSubtenantObjects returns a boolean if a field has been set.
func (o *UserInformation) HasIncludeSubtenantObjects() bool {
	if o != nil && o.IncludeSubtenantObjects.IsSet() {
		return true
	}

	return false
}

// SetIncludeSubtenantObjects gets a reference to the given NullableBool and assigns it to the IncludeSubtenantObjects field.
func (o *UserInformation) SetIncludeSubtenantObjects(v bool) {
	o.IncludeSubtenantObjects.Set(&v)
}
// SetIncludeSubtenantObjectsNil sets the value for IncludeSubtenantObjects to be an explicit nil
func (o *UserInformation) SetIncludeSubtenantObjectsNil() {
	o.IncludeSubtenantObjects.Set(nil)
}

// UnsetIncludeSubtenantObjects ensures that no value is present for IncludeSubtenantObjects, not even an explicit nil
func (o *UserInformation) UnsetIncludeSubtenantObjects() {
	o.IncludeSubtenantObjects.Unset()
}

// GetPulseAttributeVec returns the PulseAttributeVec field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UserInformation) GetPulseAttributeVec() []KeyValuePair {
	if o == nil  {
		var ret []KeyValuePair
		return ret
	}
	return o.PulseAttributeVec
}

// GetPulseAttributeVecOk returns a tuple with the PulseAttributeVec field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UserInformation) GetPulseAttributeVecOk() (*[]KeyValuePair, bool) {
	if o == nil || o.PulseAttributeVec == nil {
		return nil, false
	}
	return &o.PulseAttributeVec, true
}

// HasPulseAttributeVec returns a boolean if a field has been set.
func (o *UserInformation) HasPulseAttributeVec() bool {
	if o != nil && o.PulseAttributeVec != nil {
		return true
	}

	return false
}

// SetPulseAttributeVec gets a reference to the given []KeyValuePair and assigns it to the PulseAttributeVec field.
func (o *UserInformation) SetPulseAttributeVec(v []KeyValuePair) {
	o.PulseAttributeVec = v
}

// GetSidVec returns the SidVec field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UserInformation) GetSidVec() []ClusterConfigProtoSID {
	if o == nil  {
		var ret []ClusterConfigProtoSID
		return ret
	}
	return o.SidVec
}

// GetSidVecOk returns a tuple with the SidVec field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UserInformation) GetSidVecOk() (*[]ClusterConfigProtoSID, bool) {
	if o == nil || o.SidVec == nil {
		return nil, false
	}
	return &o.SidVec, true
}

// HasSidVec returns a boolean if a field has been set.
func (o *UserInformation) HasSidVec() bool {
	if o != nil && o.SidVec != nil {
		return true
	}

	return false
}

// SetSidVec gets a reference to the given []ClusterConfigProtoSID and assigns it to the SidVec field.
func (o *UserInformation) SetSidVec(v []ClusterConfigProtoSID) {
	o.SidVec = v
}

// GetTenantIdVec returns the TenantIdVec field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UserInformation) GetTenantIdVec() []string {
	if o == nil  {
		var ret []string
		return ret
	}
	return o.TenantIdVec
}

// GetTenantIdVecOk returns a tuple with the TenantIdVec field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UserInformation) GetTenantIdVecOk() (*[]string, bool) {
	if o == nil || o.TenantIdVec == nil {
		return nil, false
	}
	return &o.TenantIdVec, true
}

// HasTenantIdVec returns a boolean if a field has been set.
func (o *UserInformation) HasTenantIdVec() bool {
	if o != nil && o.TenantIdVec != nil {
		return true
	}

	return false
}

// SetTenantIdVec gets a reference to the given []string and assigns it to the TenantIdVec field.
func (o *UserInformation) SetTenantIdVec(v []string) {
	o.TenantIdVec = v
}

func (o UserInformation) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.IncludeSubtenantObjects.IsSet() {
		toSerialize["includeSubtenantObjects"] = o.IncludeSubtenantObjects.Get()
	}
	if o.PulseAttributeVec != nil {
		toSerialize["pulseAttributeVec"] = o.PulseAttributeVec
	}
	if o.SidVec != nil {
		toSerialize["sidVec"] = o.SidVec
	}
	if o.TenantIdVec != nil {
		toSerialize["tenantIdVec"] = o.TenantIdVec
	}
	return json.Marshal(toSerialize)
}

type NullableUserInformation struct {
	value *UserInformation
	isSet bool
}

func (v NullableUserInformation) Get() *UserInformation {
	return v.value
}

func (v *NullableUserInformation) Set(val *UserInformation) {
	v.value = val
	v.isSet = true
}

func (v NullableUserInformation) IsSet() bool {
	return v.isSet
}

func (v *NullableUserInformation) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableUserInformation(val *UserInformation) *NullableUserInformation {
	return &NullableUserInformation{value: val, isSet: true}
}

func (v NullableUserInformation) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableUserInformation) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


