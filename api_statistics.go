/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// StatisticsApiService StatisticsApi service
type StatisticsApiService service

type ApiGetEntitiesRequest struct {
	ctx _context.Context
	ApiService *StatisticsApiService
	SchemaName *string
	IncludeAggrMetricSources *bool
	MetricNames *[]string
	MaxEntities *int32
}

/*

func (r ApiGetEntitiesRequest) SchemaName(schemaName string) ApiGetEntitiesRequest {
	r.schemaName = &schemaName
	return r
}
func (r ApiGetEntitiesRequest) IncludeAggrMetricSources(includeAggrMetricSources bool) ApiGetEntitiesRequest {
	r.includeAggrMetricSources = &includeAggrMetricSources
	return r
}
func (r ApiGetEntitiesRequest) MetricNames(metricNames []string) ApiGetEntitiesRequest {
	r.metricNames = &metricNames
	return r
}
func (r ApiGetEntitiesRequest) MaxEntities(maxEntities int32) ApiGetEntitiesRequest {
	r.maxEntities = &maxEntities
	return r
}
*/

/*
func (r ApiGetEntitiesRequest) Execute() ([]EntityProto, *_nethttp.Response, error) {
	return r.ApiService.GetEntitiesExecute(r)
}

 * GetEntities Lists the entities for the specified schema.
 * An entity is an object found on the Cohesity Cluster, such as a disk or a
Node.
In the Cohesity Dashboard, similar functionality is provided in Advanced
Diagnostics.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetEntitiesRequest
 
func (a *StatisticsApiService) GetEntities(ctx _context.Context) ApiGetEntitiesRequest {
	return ApiGetEntitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatisticsApiService) GetEntities(r ApiGetEntitiesRequest) ([]EntityProto, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []EntityProto{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetEntitiesExecute(r)
}


/*
 * Execute executes the request
 * @return []EntityProto
 */
func (a *StatisticsApiService) GetEntitiesExecute(r ApiGetEntitiesRequest) ([]EntityProto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EntityProto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatisticsApiService.GetEntities")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/statistics/entities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.SchemaName == nil {
		return localVarReturnValue, nil, reportError("SchemaName is required and must be specified")
	}

	localVarQueryParams.Add("schemaName", parameterToString(*r.SchemaName, ""))
	if r.IncludeAggrMetricSources != nil {
		localVarQueryParams.Add("includeAggrMetricSources", parameterToString(*r.IncludeAggrMetricSources, ""))
	}
	if r.MetricNames != nil {
		localVarQueryParams.Add("metricNames", parameterToString(*r.MetricNames, "csv"))
	}
	if r.MaxEntities != nil {
		localVarQueryParams.Add("maxEntities", parameterToString(*r.MaxEntities, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntitiesSchemaRequest struct {
	ctx _context.Context
	ApiService *StatisticsApiService
	SchemaNames *[]string
	MetricNames *[]string
}

/*

func (r ApiGetEntitiesSchemaRequest) SchemaNames(schemaNames []string) ApiGetEntitiesSchemaRequest {
	r.schemaNames = &schemaNames
	return r
}
func (r ApiGetEntitiesSchemaRequest) MetricNames(metricNames []string) ApiGetEntitiesSchemaRequest {
	r.metricNames = &metricNames
	return r
}
*/

/*
func (r ApiGetEntitiesSchemaRequest) Execute() ([]EntitySchemaProto, *_nethttp.Response, error) {
	return r.ApiService.GetEntitiesSchemaExecute(r)
}

 * GetEntitiesSchema List the entity schemas filtered by the specified parameters.
 * An entity schema specifies the meta-data associated with entity such as
the list of attributes and a time series of data.
For example, for a Disk entity, the entity schema specifies the Node that is
using this Disk, the type of the Disk, and Metrics about the Disk such as Space
Usage, Read IOs and Write IOs. Metrics define data points (time series data)
to track over a period of time for a specific interval.
If no parameters are specified, all entity schemas found on the Cohesity
Cluster are returned.
Specifying parameters filters the results that are returned.
In the Cohesity Dashboard, similar functionality is provided in Advanced
Diagnostics.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetEntitiesSchemaRequest
 
func (a *StatisticsApiService) GetEntitiesSchema(ctx _context.Context) ApiGetEntitiesSchemaRequest {
	return ApiGetEntitiesSchemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatisticsApiService) GetEntitiesSchema(r ApiGetEntitiesSchemaRequest) ([]EntitySchemaProto, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []EntitySchemaProto{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetEntitiesSchemaExecute(r)
}


/*
 * Execute executes the request
 * @return []EntitySchemaProto
 */
func (a *StatisticsApiService) GetEntitiesSchemaExecute(r ApiGetEntitiesSchemaRequest) ([]EntitySchemaProto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EntitySchemaProto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatisticsApiService.GetEntitiesSchema")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/statistics/entitiesSchema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.SchemaNames != nil {
		localVarQueryParams.Add("schemaNames", parameterToString(*r.SchemaNames, "csv"))
	}
	if r.MetricNames != nil {
		localVarQueryParams.Add("metricNames", parameterToString(*r.MetricNames, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntitySchemaByNameRequest struct {
	ctx _context.Context
	ApiService *StatisticsApiService
	SchemaName string
}

/*

*/

/*
func (r ApiGetEntitySchemaByNameRequest) Execute() ([]EntitySchemaProto, *_nethttp.Response, error) {
	return r.ApiService.GetEntitySchemaByNameExecute(r)
}

 * GetEntitySchemaByName Get the entity schema for the specified schema.
 * An entity schema specifies the meta-data associated with entity such as the
list of attributes and a time series of data.
For example, for a Disk entity, the entity schema specifies the Node that is
using this Disk, the type of the Disk, and Metrics about the Disk such as
Space Usage, Read IOs and Write IOs. Metrics define data points (time series
data) to track over a period of time for a specific interval.
In the Cohesity Dashboard, similar functionality is provided in Advanced
Diagnostics.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param schemaName Name of the Schema
 * @return ApiGetEntitySchemaByNameRequest
 
func (a *StatisticsApiService) GetEntitySchemaByName(ctx _context.Context, schemaName string) ApiGetEntitySchemaByNameRequest {
	return ApiGetEntitySchemaByNameRequest{
		ApiService: a,
		ctx: ctx,
		schemaName: schemaName,
	}
}
*/

func (a *StatisticsApiService) GetEntitySchemaByName(r ApiGetEntitySchemaByNameRequest) ([]EntitySchemaProto, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []EntitySchemaProto{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetEntitySchemaByNameExecute(r)
}


/*
 * Execute executes the request
 * @return []EntitySchemaProto
 */
func (a *StatisticsApiService) GetEntitySchemaByNameExecute(r ApiGetEntitySchemaByNameRequest) ([]EntitySchemaProto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EntitySchemaProto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatisticsApiService.GetEntitySchemaByName")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/statistics/entitiesSchema/{schemaName}"
	localVarPath = strings.Replace(localVarPath, "{"+"schemaName"+"}", _neturl.PathEscape(parameterToString(r.SchemaName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTasksRequest struct {
	ctx _context.Context
	ApiService *StatisticsApiService
	TaskPaths *[]string
	IncludeFinishedTasks *bool
	StartTimeSeconds *int64
	EndTimeSeconds *int64
	MaxTasks *int32
	ExcludeSubTasks *bool
	Attributes *[]string
}

/*

func (r ApiGetTasksRequest) TaskPaths(taskPaths []string) ApiGetTasksRequest {
	r.taskPaths = &taskPaths
	return r
}
func (r ApiGetTasksRequest) IncludeFinishedTasks(includeFinishedTasks bool) ApiGetTasksRequest {
	r.includeFinishedTasks = &includeFinishedTasks
	return r
}
func (r ApiGetTasksRequest) StartTimeSeconds(startTimeSeconds int64) ApiGetTasksRequest {
	r.startTimeSeconds = &startTimeSeconds
	return r
}
func (r ApiGetTasksRequest) EndTimeSeconds(endTimeSeconds int64) ApiGetTasksRequest {
	r.endTimeSeconds = &endTimeSeconds
	return r
}
func (r ApiGetTasksRequest) MaxTasks(maxTasks int32) ApiGetTasksRequest {
	r.maxTasks = &maxTasks
	return r
}
func (r ApiGetTasksRequest) ExcludeSubTasks(excludeSubTasks bool) ApiGetTasksRequest {
	r.excludeSubTasks = &excludeSubTasks
	return r
}
func (r ApiGetTasksRequest) Attributes(attributes []string) ApiGetTasksRequest {
	r.attributes = &attributes
	return r
}
*/

/*
func (r ApiGetTasksRequest) Execute() ([]Task, *_nethttp.Response, error) {
	return r.ApiService.GetTasksExecute(r)
}

 * GetTasks Gets the progress and status of tasks.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTasksRequest
 
func (a *StatisticsApiService) GetTasks(ctx _context.Context) ApiGetTasksRequest {
	return ApiGetTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatisticsApiService) GetTasks(r ApiGetTasksRequest) ([]Task, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []Task{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetTasksExecute(r)
}


/*
 * Execute executes the request
 * @return []Task
 */
func (a *StatisticsApiService) GetTasksExecute(r ApiGetTasksRequest) ([]Task, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatisticsApiService.GetTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/tasks/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.TaskPaths != nil {
		localVarQueryParams.Add("taskPaths", parameterToString(*r.TaskPaths, "csv"))
	}
	if r.IncludeFinishedTasks != nil {
		localVarQueryParams.Add("includeFinishedTasks", parameterToString(*r.IncludeFinishedTasks, ""))
	}
	if r.StartTimeSeconds != nil {
		localVarQueryParams.Add("startTimeSeconds", parameterToString(*r.StartTimeSeconds, ""))
	}
	if r.EndTimeSeconds != nil {
		localVarQueryParams.Add("endTimeSeconds", parameterToString(*r.EndTimeSeconds, ""))
	}
	if r.MaxTasks != nil {
		localVarQueryParams.Add("maxTasks", parameterToString(*r.MaxTasks, ""))
	}
	if r.ExcludeSubTasks != nil {
		localVarQueryParams.Add("excludeSubTasks", parameterToString(*r.ExcludeSubTasks, ""))
	}
	if r.Attributes != nil {
		localVarQueryParams.Add("attributes", parameterToString(*r.Attributes, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesSchemaRequest struct {
	ctx _context.Context
	ApiService *StatisticsApiService
	EntityType *string
	EntityId *int64
	EntityName *string
}

/*

func (r ApiGetTimeSeriesSchemaRequest) EntityType(entityType string) ApiGetTimeSeriesSchemaRequest {
	r.entityType = &entityType
	return r
}
func (r ApiGetTimeSeriesSchemaRequest) EntityId(entityId int64) ApiGetTimeSeriesSchemaRequest {
	r.entityId = &entityId
	return r
}
func (r ApiGetTimeSeriesSchemaRequest) EntityName(entityName string) ApiGetTimeSeriesSchemaRequest {
	r.entityName = &entityName
	return r
}
*/

/*
func (r ApiGetTimeSeriesSchemaRequest) Execute() (TimeSeriesSchemaResponse, *_nethttp.Response, error) {
	return r.ApiService.GetTimeSeriesSchemaExecute(r)
}

 * GetTimeSeriesSchema Method for GetTimeSeriesSchema
 * Gets the Apollo schema information for an entity to list a series of data
points.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTimeSeriesSchemaRequest
 
func (a *StatisticsApiService) GetTimeSeriesSchema(ctx _context.Context) ApiGetTimeSeriesSchemaRequest {
	return ApiGetTimeSeriesSchemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatisticsApiService) GetTimeSeriesSchema(r ApiGetTimeSeriesSchemaRequest) (TimeSeriesSchemaResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return TimeSeriesSchemaResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetTimeSeriesSchemaExecute(r)
}


/*
 * Execute executes the request
 * @return TimeSeriesSchemaResponse
 */
func (a *StatisticsApiService) GetTimeSeriesSchemaExecute(r ApiGetTimeSeriesSchemaRequest) (TimeSeriesSchemaResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TimeSeriesSchemaResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatisticsApiService.GetTimeSeriesSchema")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/statistics/timeSeriesSchema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.EntityType == nil {
		return localVarReturnValue, nil, reportError("EntityType is required and must be specified")
	}
	if r.EntityId == nil {
		return localVarReturnValue, nil, reportError("EntityId is required and must be specified")
	}
	if r.EntityName == nil {
		return localVarReturnValue, nil, reportError("EntityName is required and must be specified")
	}

	localVarQueryParams.Add("entityType", parameterToString(*r.EntityType, ""))
	localVarQueryParams.Add("entityId", parameterToString(*r.EntityId, ""))
	localVarQueryParams.Add("entityName", parameterToString(*r.EntityName, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesStatsRequest struct {
	ctx _context.Context
	ApiService *StatisticsApiService
	SchemaName *string
	MetricName *string
	StartTimeMsecs *int64
	EntityId *string
	EntityIdList *[]string
	EndTimeMsecs *int64
	RollupFunction *string
	RollupIntervalSecs *int32
}

/*

func (r ApiGetTimeSeriesStatsRequest) SchemaName(schemaName string) ApiGetTimeSeriesStatsRequest {
	r.schemaName = &schemaName
	return r
}
func (r ApiGetTimeSeriesStatsRequest) MetricName(metricName string) ApiGetTimeSeriesStatsRequest {
	r.metricName = &metricName
	return r
}
func (r ApiGetTimeSeriesStatsRequest) StartTimeMsecs(startTimeMsecs int64) ApiGetTimeSeriesStatsRequest {
	r.startTimeMsecs = &startTimeMsecs
	return r
}
func (r ApiGetTimeSeriesStatsRequest) EntityId(entityId string) ApiGetTimeSeriesStatsRequest {
	r.entityId = &entityId
	return r
}
func (r ApiGetTimeSeriesStatsRequest) EntityIdList(entityIdList []string) ApiGetTimeSeriesStatsRequest {
	r.entityIdList = &entityIdList
	return r
}
func (r ApiGetTimeSeriesStatsRequest) EndTimeMsecs(endTimeMsecs int64) ApiGetTimeSeriesStatsRequest {
	r.endTimeMsecs = &endTimeMsecs
	return r
}
func (r ApiGetTimeSeriesStatsRequest) RollupFunction(rollupFunction string) ApiGetTimeSeriesStatsRequest {
	r.rollupFunction = &rollupFunction
	return r
}
func (r ApiGetTimeSeriesStatsRequest) RollupIntervalSecs(rollupIntervalSecs int32) ApiGetTimeSeriesStatsRequest {
	r.rollupIntervalSecs = &rollupIntervalSecs
	return r
}
*/

/*
func (r ApiGetTimeSeriesStatsRequest) Execute() (MetricDataBlock, *_nethttp.Response, error) {
	return r.ApiService.GetTimeSeriesStatsExecute(r)
}

 * GetTimeSeriesStats List a series of data points for an entity of a metric in a schema, during the specified time period.
 * A Metric specifies a data point (such as CPU usage and IOPS) to track over a
period of time.
For example for a disk in the Cluster, you can report on the 'Disk Health'
(kDiskAwaitTimeMsecs) Metric of the 'Disk Health Metrics' (kSentryDiskStats)
Schema for the last week.
You must specify the 'k' names as input and not the descriptive names.
You must also specify the id of the entity that you are reporting on such as
a Cluster, disk drive, job, etc.
Get the entityId by running the GET /public/statistics/entities operation.
In the Cohesity Dashboard, similar functionality is provided in Advanced
Diagnostics.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTimeSeriesStatsRequest
 
func (a *StatisticsApiService) GetTimeSeriesStats(ctx _context.Context) ApiGetTimeSeriesStatsRequest {
	return ApiGetTimeSeriesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatisticsApiService) GetTimeSeriesStats(r ApiGetTimeSeriesStatsRequest) (MetricDataBlock, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return MetricDataBlock{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetTimeSeriesStatsExecute(r)
}


/*
 * Execute executes the request
 * @return MetricDataBlock
 */
func (a *StatisticsApiService) GetTimeSeriesStatsExecute(r ApiGetTimeSeriesStatsRequest) (MetricDataBlock, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MetricDataBlock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatisticsApiService.GetTimeSeriesStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/statistics/timeSeriesStats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.SchemaName == nil {
		return localVarReturnValue, nil, reportError("SchemaName is required and must be specified")
	}
	if r.MetricName == nil {
		return localVarReturnValue, nil, reportError("MetricName is required and must be specified")
	}
	if r.StartTimeMsecs == nil {
		return localVarReturnValue, nil, reportError("StartTimeMsecs is required and must be specified")
	}

	localVarQueryParams.Add("schemaName", parameterToString(*r.SchemaName, ""))
	if r.EntityId != nil {
		localVarQueryParams.Add("entityId", parameterToString(*r.EntityId, ""))
	}
	if r.EntityIdList != nil {
		localVarQueryParams.Add("entityIdList", parameterToString(*r.EntityIdList, "csv"))
	}
	localVarQueryParams.Add("metricName", parameterToString(*r.MetricName, ""))
	localVarQueryParams.Add("startTimeMsecs", parameterToString(*r.StartTimeMsecs, ""))
	if r.EndTimeMsecs != nil {
		localVarQueryParams.Add("endTimeMsecs", parameterToString(*r.EndTimeMsecs, ""))
	}
	if r.RollupFunction != nil {
		localVarQueryParams.Add("rollupFunction", parameterToString(*r.RollupFunction, ""))
	}
	if r.RollupIntervalSecs != nil {
		localVarQueryParams.Add("rollupIntervalSecs", parameterToString(*r.RollupIntervalSecs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
