/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ActiveDirectoryApiService ActiveDirectoryApi service
type ActiveDirectoryApiService service

type ApiAddActiveDirectoryPrincipalsRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Body *[]ActiveDirectoryPrincipalsAddParameters
}

/*

func (r ApiAddActiveDirectoryPrincipalsRequest) Body(body []ActiveDirectoryPrincipalsAddParameters) ApiAddActiveDirectoryPrincipalsRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiAddActiveDirectoryPrincipalsRequest) Execute() ([]AddedActiveDirectoryPrincipal, *_nethttp.Response, error) {
	return r.ApiService.AddActiveDirectoryPrincipalsExecute(r)
}

 * AddActiveDirectoryPrincipals Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges.
 * After a group or user has been added to a Cohesity Cluster,
the referenced Active Directory principal can be used by the Cohesity Cluster.
In addition, this operation maps Cohesity roles with a group or user and
this mapping defines the privileges allowed on the Cohesity Cluster for the
group or user.
For example if an 'management' group is created on the Cohesity Cluster
for the Active Directory 'management' principal group and is
associated with the Cohesity 'View' role, all users in the
referenced Active Directory 'management' principal group can log in to the
Cohesity Dashboard but will only have view-only privileges.
These users cannot create new Protection Jobs, Policies, Views, etc.

NOTE: Local Cohesity users and groups cannot be created by this operation.
Local Cohesity users or groups do not have an associated Active Directory
principals and are created directly in the default LOCAL domain.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAddActiveDirectoryPrincipalsRequest
 
func (a *ActiveDirectoryApiService) AddActiveDirectoryPrincipals(ctx _context.Context) ApiAddActiveDirectoryPrincipalsRequest {
	return ApiAddActiveDirectoryPrincipalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ActiveDirectoryApiService) AddActiveDirectoryPrincipals(r ApiAddActiveDirectoryPrincipalsRequest) ([]AddedActiveDirectoryPrincipal, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []AddedActiveDirectoryPrincipal{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.AddActiveDirectoryPrincipalsExecute(r)
}


/*
 * Execute executes the request
 * @return []AddedActiveDirectoryPrincipal
 */
func (a *ActiveDirectoryApiService) AddActiveDirectoryPrincipalsExecute(r ApiAddActiveDirectoryPrincipalsRequest) ([]AddedActiveDirectoryPrincipal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AddedActiveDirectoryPrincipal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.AddActiveDirectoryPrincipals")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/principals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateActiveDirectoryEntryRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Body *CreateActiveDirectoryEntryParams
}

/*

func (r ApiCreateActiveDirectoryEntryRequest) Body(body CreateActiveDirectoryEntryParams) ApiCreateActiveDirectoryEntryRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateActiveDirectoryEntryRequest) Execute() (ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.CreateActiveDirectoryEntryExecute(r)
}

 * CreateActiveDirectoryEntry Join the Cohesity Cluster to the specified Active Directory.
 * After a Cohesity Cluster has been joined to an Active Directory domain,
the users and groups in the domain can be authenticated on the Cohesity Cluster
using their Active Directory credentials.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateActiveDirectoryEntryRequest
 
func (a *ActiveDirectoryApiService) CreateActiveDirectoryEntry(ctx _context.Context) ApiCreateActiveDirectoryEntryRequest {
	return ApiCreateActiveDirectoryEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ActiveDirectoryApiService) CreateActiveDirectoryEntry(r ApiCreateActiveDirectoryEntryRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateActiveDirectoryEntryExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) CreateActiveDirectoryEntryExecute(r ApiCreateActiveDirectoryEntryRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.CreateActiveDirectoryEntry")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteActiveDirectoryEntryRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Body *ActiveDirectoryEntry
}

/*

func (r ApiDeleteActiveDirectoryEntryRequest) Body(body ActiveDirectoryEntry) ApiDeleteActiveDirectoryEntryRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiDeleteActiveDirectoryEntryRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteActiveDirectoryEntryExecute(r)
}

 * DeleteActiveDirectoryEntry Deletes the join with the Active Directory.
 * Deletes the join of the Cohesity Cluster to the specified
Active Directory domain. After the deletion, the Cohesity Cluster
no longer has access to the principals on the Active Directory.
For example, you can no longer log in to the Cohesity Cluster
with a user defined in a principal group of the Active Directory domain.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDeleteActiveDirectoryEntryRequest
 
func (a *ActiveDirectoryApiService) DeleteActiveDirectoryEntry(ctx _context.Context) ApiDeleteActiveDirectoryEntryRequest {
	return ApiDeleteActiveDirectoryEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ActiveDirectoryApiService) DeleteActiveDirectoryEntry(r ApiDeleteActiveDirectoryEntryRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.DeleteActiveDirectoryEntryExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ActiveDirectoryApiService) DeleteActiveDirectoryEntryExecute(r ApiDeleteActiveDirectoryEntryRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.DeleteActiveDirectoryEntry")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableTrustedDomainDiscoveryRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Name string
	Body *UpdateTrustedDomainEnableParams
}

/*

func (r ApiEnableTrustedDomainDiscoveryRequest) Body(body UpdateTrustedDomainEnableParams) ApiEnableTrustedDomainDiscoveryRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiEnableTrustedDomainDiscoveryRequest) Execute() (ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.EnableTrustedDomainDiscoveryExecute(r)
}

 * EnableTrustedDomainDiscovery Updates the states of trusted domains discovery.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Specifies the Active Directory Domain Name.
 * @return ApiEnableTrustedDomainDiscoveryRequest
 
func (a *ActiveDirectoryApiService) EnableTrustedDomainDiscovery(ctx _context.Context, name string) ApiEnableTrustedDomainDiscoveryRequest {
	return ApiEnableTrustedDomainDiscoveryRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}
*/

func (a *ActiveDirectoryApiService) EnableTrustedDomainDiscovery(r ApiEnableTrustedDomainDiscoveryRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.EnableTrustedDomainDiscoveryExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) EnableTrustedDomainDiscoveryExecute(r ApiEnableTrustedDomainDiscoveryRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.EnableTrustedDomainDiscovery")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/{name}/enableTrustedDomainState"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.Name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveDirectoryDomainControllersRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	DomainName *string
}

/*

func (r ApiGetActiveDirectoryDomainControllersRequest) DomainName(domainName string) ApiGetActiveDirectoryDomainControllersRequest {
	r.domainName = &domainName
	return r
}
*/

/*
func (r ApiGetActiveDirectoryDomainControllersRequest) Execute() (DomainControllers, *_nethttp.Response, error) {
	return r.ApiService.GetActiveDirectoryDomainControllersExecute(r)
}

 * GetActiveDirectoryDomainControllers List the domain controllers for a domain.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetActiveDirectoryDomainControllersRequest
 
func (a *ActiveDirectoryApiService) GetActiveDirectoryDomainControllers(ctx _context.Context) ApiGetActiveDirectoryDomainControllersRequest {
	return ApiGetActiveDirectoryDomainControllersRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ActiveDirectoryApiService) GetActiveDirectoryDomainControllers(r ApiGetActiveDirectoryDomainControllersRequest) (DomainControllers, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return DomainControllers{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetActiveDirectoryDomainControllersExecute(r)
}


/*
 * Execute executes the request
 * @return DomainControllers
 */
func (a *ActiveDirectoryApiService) GetActiveDirectoryDomainControllersExecute(r ApiGetActiveDirectoryDomainControllersRequest) (DomainControllers, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DomainControllers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.GetActiveDirectoryDomainControllers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/domainControllers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.DomainName != nil {
		localVarQueryParams.Add("domainName", parameterToString(*r.DomainName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveDirectoryEntryRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Domains *[]string
	TenantIds *[]string
	AllUnderHierarchy *bool
}

/*

func (r ApiGetActiveDirectoryEntryRequest) Domains(domains []string) ApiGetActiveDirectoryEntryRequest {
	r.domains = &domains
	return r
}
func (r ApiGetActiveDirectoryEntryRequest) TenantIds(tenantIds []string) ApiGetActiveDirectoryEntryRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetActiveDirectoryEntryRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetActiveDirectoryEntryRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiGetActiveDirectoryEntryRequest) Execute() ([]ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.GetActiveDirectoryEntryExecute(r)
}

 * GetActiveDirectoryEntry Lists the Active Directories that the Cohesity Cluster has joined.
 * After a Cohesity Cluster has been joined to an Active Directory domain,
the users and groups in the domain can be authenticated on the Cohesity Cluster
using their Active Directory credentials.

NOTE: The userName and password fields are not populated by this operation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetActiveDirectoryEntryRequest
 
func (a *ActiveDirectoryApiService) GetActiveDirectoryEntry(ctx _context.Context) ApiGetActiveDirectoryEntryRequest {
	return ApiGetActiveDirectoryEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ActiveDirectoryApiService) GetActiveDirectoryEntry(r ApiGetActiveDirectoryEntryRequest) ([]ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetActiveDirectoryEntryExecute(r)
}


/*
 * Execute executes the request
 * @return []ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) GetActiveDirectoryEntryExecute(r ApiGetActiveDirectoryEntryRequest) ([]ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.GetActiveDirectoryEntry")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Domains != nil {
		localVarQueryParams.Add("domains", parameterToString(*r.Domains, "csv"))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCentrifyZonesRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	DomainName *string
}

/*

func (r ApiListCentrifyZonesRequest) DomainName(domainName string) ApiListCentrifyZonesRequest {
	r.domainName = &domainName
	return r
}
*/

/*
func (r ApiListCentrifyZonesRequest) Execute() ([]ListCentrifyZone, *_nethttp.Response, error) {
	return r.ApiService.ListCentrifyZonesExecute(r)
}

 * ListCentrifyZones Fetches the list centrify zones of an active directory domain.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListCentrifyZonesRequest
 
func (a *ActiveDirectoryApiService) ListCentrifyZones(ctx _context.Context) ApiListCentrifyZonesRequest {
	return ApiListCentrifyZonesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ActiveDirectoryApiService) ListCentrifyZones(r ApiListCentrifyZonesRequest) ([]ListCentrifyZone, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ListCentrifyZone{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListCentrifyZonesExecute(r)
}


/*
 * Execute executes the request
 * @return []ListCentrifyZone
 */
func (a *ActiveDirectoryApiService) ListCentrifyZonesExecute(r ApiListCentrifyZonesRequest) ([]ListCentrifyZone, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ListCentrifyZone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.ListCentrifyZones")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/centrifyZones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.DomainName != nil {
		localVarQueryParams.Add("domainName", parameterToString(*r.DomainName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchActiveDirectoryPrincipalsRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Domain *string
	ObjectClass *string
	Search *string
	Sids *[]string
	IncludeComputers *bool
}

/*

func (r ApiSearchActiveDirectoryPrincipalsRequest) Domain(domain string) ApiSearchActiveDirectoryPrincipalsRequest {
	r.domain = &domain
	return r
}
func (r ApiSearchActiveDirectoryPrincipalsRequest) ObjectClass(objectClass string) ApiSearchActiveDirectoryPrincipalsRequest {
	r.objectClass = &objectClass
	return r
}
func (r ApiSearchActiveDirectoryPrincipalsRequest) Search(search string) ApiSearchActiveDirectoryPrincipalsRequest {
	r.search = &search
	return r
}
func (r ApiSearchActiveDirectoryPrincipalsRequest) Sids(sids []string) ApiSearchActiveDirectoryPrincipalsRequest {
	r.sids = &sids
	return r
}
func (r ApiSearchActiveDirectoryPrincipalsRequest) IncludeComputers(includeComputers bool) ApiSearchActiveDirectoryPrincipalsRequest {
	r.includeComputers = &includeComputers
	return r
}
*/

/*
func (r ApiSearchActiveDirectoryPrincipalsRequest) Execute() ([]ActiveDirectoryPrincipal, *_nethttp.Response, error) {
	return r.ApiService.SearchActiveDirectoryPrincipalsExecute(r)
}

 * SearchActiveDirectoryPrincipals List the user and group principals in the Active Directory that match the filter criteria specified using parameters.
 * Optionally limit the search results by specifying security identifiers (SIDs),
an object class (user or group) or a substring.
You can specify SIDs or a substring but not both.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSearchActiveDirectoryPrincipalsRequest
 
func (a *ActiveDirectoryApiService) SearchActiveDirectoryPrincipals(ctx _context.Context) ApiSearchActiveDirectoryPrincipalsRequest {
	return ApiSearchActiveDirectoryPrincipalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ActiveDirectoryApiService) SearchActiveDirectoryPrincipals(r ApiSearchActiveDirectoryPrincipalsRequest) ([]ActiveDirectoryPrincipal, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ActiveDirectoryPrincipal{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.SearchActiveDirectoryPrincipalsExecute(r)
}


/*
 * Execute executes the request
 * @return []ActiveDirectoryPrincipal
 */
func (a *ActiveDirectoryApiService) SearchActiveDirectoryPrincipalsExecute(r ApiSearchActiveDirectoryPrincipalsRequest) ([]ActiveDirectoryPrincipal, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ActiveDirectoryPrincipal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.SearchActiveDirectoryPrincipals")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/principals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Domain != nil {
		localVarQueryParams.Add("domain", parameterToString(*r.Domain, ""))
	}
	if r.ObjectClass != nil {
		localVarQueryParams.Add("objectClass", parameterToString(*r.ObjectClass, ""))
	}
	if r.Search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.Search, ""))
	}
	if r.Sids != nil {
		localVarQueryParams.Add("sids", parameterToString(*r.Sids, "csv"))
	}
	if r.IncludeComputers != nil {
		localVarQueryParams.Add("includeComputers", parameterToString(*r.IncludeComputers, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateActiveDirectoryIdMappingRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Name string
	Body *IdMappingInfo
}

/*

func (r ApiUpdateActiveDirectoryIdMappingRequest) Body(body IdMappingInfo) ApiUpdateActiveDirectoryIdMappingRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateActiveDirectoryIdMappingRequest) Execute() (ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.UpdateActiveDirectoryIdMappingExecute(r)
}

 * UpdateActiveDirectoryIdMapping Updates the user id mapping info of an Active Directory.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Specifies the Active Directory Domain Name.
 * @return ApiUpdateActiveDirectoryIdMappingRequest
 
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryIdMapping(ctx _context.Context, name string) ApiUpdateActiveDirectoryIdMappingRequest {
	return ApiUpdateActiveDirectoryIdMappingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}
*/

func (a *ActiveDirectoryApiService) UpdateActiveDirectoryIdMapping(r ApiUpdateActiveDirectoryIdMappingRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateActiveDirectoryIdMappingExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryIdMappingExecute(r ApiUpdateActiveDirectoryIdMappingRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.UpdateActiveDirectoryIdMapping")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/{name}/idMappingInfo"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.Name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Name string
	Body *UpdateIgnoredTrustedDomainsParams
}

/*

func (r ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest) Body(body UpdateIgnoredTrustedDomainsParams) ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest) Execute() (ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.UpdateActiveDirectoryIgnoredTrustedDomainsExecute(r)
}

 * UpdateActiveDirectoryIgnoredTrustedDomains Updates the list of trusted domains to be ignored during trusted domain discovery of an Active Directory.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Specifies the Active Directory Domain Name.
 * @return ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest
 
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryIgnoredTrustedDomains(ctx _context.Context, name string) ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest {
	return ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}
*/

func (a *ActiveDirectoryApiService) UpdateActiveDirectoryIgnoredTrustedDomains(r ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateActiveDirectoryIgnoredTrustedDomainsExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryIgnoredTrustedDomainsExecute(r ApiUpdateActiveDirectoryIgnoredTrustedDomainsRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.UpdateActiveDirectoryIgnoredTrustedDomains")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/{name}/ignoredTrustedDomains"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.Name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateActiveDirectoryLdapProviderRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Name string
	Body *UpdateLdapProviderParams
}

/*

func (r ApiUpdateActiveDirectoryLdapProviderRequest) Body(body UpdateLdapProviderParams) ApiUpdateActiveDirectoryLdapProviderRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateActiveDirectoryLdapProviderRequest) Execute() (ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.UpdateActiveDirectoryLdapProviderExecute(r)
}

 * UpdateActiveDirectoryLdapProvider Updates the LDAP provide Id for an Active Directory domain.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Specifies the Active Directory Domain Name.
 * @return ApiUpdateActiveDirectoryLdapProviderRequest
 
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryLdapProvider(ctx _context.Context, name string) ApiUpdateActiveDirectoryLdapProviderRequest {
	return ApiUpdateActiveDirectoryLdapProviderRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}
*/

func (a *ActiveDirectoryApiService) UpdateActiveDirectoryLdapProvider(r ApiUpdateActiveDirectoryLdapProviderRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateActiveDirectoryLdapProviderExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryLdapProviderExecute(r ApiUpdateActiveDirectoryLdapProviderRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.UpdateActiveDirectoryLdapProvider")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/{name}/ldapProvider"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.Name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateActiveDirectoryMachineAccountsRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Name string
	Body *UpdateMachineAccountsParams
}

/*

func (r ApiUpdateActiveDirectoryMachineAccountsRequest) Body(body UpdateMachineAccountsParams) ApiUpdateActiveDirectoryMachineAccountsRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateActiveDirectoryMachineAccountsRequest) Execute() (ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.UpdateActiveDirectoryMachineAccountsExecute(r)
}

 * UpdateActiveDirectoryMachineAccounts Updates the machine accounts of an Active Directory.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Specifies the Active Directory Domain Name.
 * @return ApiUpdateActiveDirectoryMachineAccountsRequest
 
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryMachineAccounts(ctx _context.Context, name string) ApiUpdateActiveDirectoryMachineAccountsRequest {
	return ApiUpdateActiveDirectoryMachineAccountsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}
*/

func (a *ActiveDirectoryApiService) UpdateActiveDirectoryMachineAccounts(r ApiUpdateActiveDirectoryMachineAccountsRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateActiveDirectoryMachineAccountsExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) UpdateActiveDirectoryMachineAccountsExecute(r ApiUpdateActiveDirectoryMachineAccountsRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.UpdateActiveDirectoryMachineAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/{name}/machineAccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.Name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePreferredDomainControllersRequest struct {
	ctx _context.Context
	ApiService *ActiveDirectoryApiService
	Name string
	Body *[]PreferredDomainController
}

/*

func (r ApiUpdatePreferredDomainControllersRequest) Body(body []PreferredDomainController) ApiUpdatePreferredDomainControllersRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdatePreferredDomainControllersRequest) Execute() (ActiveDirectoryEntry, *_nethttp.Response, error) {
	return r.ApiService.UpdatePreferredDomainControllersExecute(r)
}

 * UpdatePreferredDomainControllers Method for UpdatePreferredDomainControllers
 * Updates the preferred domain controllers of an Active Directory
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Specifies the Active Directory Domain Name.
 * @return ApiUpdatePreferredDomainControllersRequest
 
func (a *ActiveDirectoryApiService) UpdatePreferredDomainControllers(ctx _context.Context, name string) ApiUpdatePreferredDomainControllersRequest {
	return ApiUpdatePreferredDomainControllersRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}
*/

func (a *ActiveDirectoryApiService) UpdatePreferredDomainControllers(r ApiUpdatePreferredDomainControllersRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveDirectoryEntry{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdatePreferredDomainControllersExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveDirectoryEntry
 */
func (a *ActiveDirectoryApiService) UpdatePreferredDomainControllersExecute(r ApiUpdatePreferredDomainControllersRequest) (ActiveDirectoryEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveDirectoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryApiService.UpdatePreferredDomainControllers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/activeDirectory/{name}/preferredDomainControllers"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.Name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
