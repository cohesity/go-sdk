/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

// package cohesitysdk
package models

import (
	"encoding/json"
	. "github.com/cohesity/go-sdk/cohesitysdk/utils"
)

var _ = NullableBool{}

// SupportedConfig Lists the supported Erasure Coding options for the number of Nodes in the Cohesity Cluster. In addition, the minimum number of Nodes supported for this Cluster type is defined.
type SupportedConfig struct {
	// Specifies the minimum number of Nodes supported for this Cluster type. For example, a Cohesity Cluster hosted directly on hardware must have at least 3 Nodes.
	MinNodesAllowed NullableInt32 `json:"minNodesAllowed,omitempty"`
	// Array of Supported Erasure Coding Options.  List the supported Erasure Coding options for the current number of Nodes (nodeCount) in this Cluster. Each string in the array is in the following format: \"NumDataStripes:NumCodedStripes\" For example if there are 3 nodes in the Cluster, the following Erasure Coding mode is returned: 2:1. See the Cohesity Dashboard help documentation for details.
	SupportedErasureCoding []string `json:"supportedErasureCoding,omitempty"`
}

// NewSupportedConfig instantiates a new SupportedConfig object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSupportedConfig() *SupportedConfig {
	this := SupportedConfig{}
	return &this
}

// NewSupportedConfigWithDefaults instantiates a new SupportedConfig object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSupportedConfigWithDefaults() *SupportedConfig {
	this := SupportedConfig{}
	return &this
}

// GetMinNodesAllowed returns the MinNodesAllowed field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SupportedConfig) GetMinNodesAllowed() int32 {
	if o == nil || o.MinNodesAllowed.Get() == nil {
		var ret int32
		return ret
	}
	return *o.MinNodesAllowed.Get()
}

// GetMinNodesAllowedOk returns a tuple with the MinNodesAllowed field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SupportedConfig) GetMinNodesAllowedOk() (*int32, bool) {
	if o == nil  {
		return nil, false
	}
	return o.MinNodesAllowed.Get(), o.MinNodesAllowed.IsSet()
}

// HasMinNodesAllowed returns a boolean if a field has been set.
func (o *SupportedConfig) HasMinNodesAllowed() bool {
	if o != nil && o.MinNodesAllowed.IsSet() {
		return true
	}

	return false
}

// SetMinNodesAllowed gets a reference to the given NullableInt32 and assigns it to the MinNodesAllowed field.
func (o *SupportedConfig) SetMinNodesAllowed(v int32) {
	o.MinNodesAllowed.Set(&v)
}
// SetMinNodesAllowedNil sets the value for MinNodesAllowed to be an explicit nil
func (o *SupportedConfig) SetMinNodesAllowedNil() {
	o.MinNodesAllowed.Set(nil)
}

// UnsetMinNodesAllowed ensures that no value is present for MinNodesAllowed, not even an explicit nil
func (o *SupportedConfig) UnsetMinNodesAllowed() {
	o.MinNodesAllowed.Unset()
}

// GetSupportedErasureCoding returns the SupportedErasureCoding field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SupportedConfig) GetSupportedErasureCoding() []string {
	if o == nil  {
		var ret []string
		return ret
	}
	return o.SupportedErasureCoding
}

// GetSupportedErasureCodingOk returns a tuple with the SupportedErasureCoding field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SupportedConfig) GetSupportedErasureCodingOk() (*[]string, bool) {
	if o == nil || o.SupportedErasureCoding == nil {
		return nil, false
	}
	return &o.SupportedErasureCoding, true
}

// HasSupportedErasureCoding returns a boolean if a field has been set.
func (o *SupportedConfig) HasSupportedErasureCoding() bool {
	if o != nil && o.SupportedErasureCoding != nil {
		return true
	}

	return false
}

// SetSupportedErasureCoding gets a reference to the given []string and assigns it to the SupportedErasureCoding field.
func (o *SupportedConfig) SetSupportedErasureCoding(v []string) {
	o.SupportedErasureCoding = v
}

func (o SupportedConfig) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.MinNodesAllowed.IsSet() {
		toSerialize["minNodesAllowed"] = o.MinNodesAllowed.Get()
	}
	if o.SupportedErasureCoding != nil {
		toSerialize["supportedErasureCoding"] = o.SupportedErasureCoding
	}
	return json.Marshal(toSerialize)
}

type NullableSupportedConfig struct {
	value *SupportedConfig
	isSet bool
}

func (v NullableSupportedConfig) Get() *SupportedConfig {
	return v.value
}

func (v *NullableSupportedConfig) Set(val *SupportedConfig) {
	v.value = val
	v.isSet = true
}

func (v NullableSupportedConfig) IsSet() bool {
	return v.isSet
}

func (v *NullableSupportedConfig) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSupportedConfig(val *SupportedConfig) *NullableSupportedConfig {
	return &NullableSupportedConfig{value: val, isSet: true}
}

func (v NullableSupportedConfig) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSupportedConfig) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


