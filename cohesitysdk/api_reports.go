/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	. "github.com/cohesity/go-sdk/cohesitysdk/models"
)

// Linger please
var (
	_ _context.Context
)

// ReportsApiService ReportsApi service
type ReportsApiService service

type ApiGetAgentDeploymentReportRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	HostOsType *[]string
	CompactVersion *string
	OutputFormat *string
	HealthStatus *[]string
}


func (a *ReportsApiService) GetAgentDeploymentReport(r ApiGetAgentDeploymentReportRequest) ([]AgentDeploymentStatusResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []AgentDeploymentStatusResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetAgentDeploymentReportExecute(r)
}


/*
 * Execute executes the request
 * @return []AgentDeploymentStatusResponse
 */
func (a *ReportsApiService) GetAgentDeploymentReportExecute(r ApiGetAgentDeploymentReportRequest) ([]AgentDeploymentStatusResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AgentDeploymentStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetAgentDeploymentReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/agents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.HostOsType != nil {
		localVarQueryParams.Add("hostOsType", parameterToString(*r.HostOsType, "csv"))
	}
	if r.CompactVersion != nil {
		localVarQueryParams.Add("compactVersion", parameterToString(*r.CompactVersion, ""))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.HealthStatus != nil {
		localVarQueryParams.Add("healthStatus", parameterToString(*r.HealthStatus, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataTransferFromVaultsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	VaultIds *[]int64
	StartTimeMsecs *int64
	EndTimeMsecs *int64
	OutputFormat *string
	GroupBy *int32
}


func (a *ReportsApiService) GetDataTransferFromVaultsReportRequest(r ApiGetDataTransferFromVaultsReportRequestRequest) (DataTransferFromVaultsSummaryResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return DataTransferFromVaultsSummaryResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetDataTransferFromVaultsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return DataTransferFromVaultsSummaryResponse
 */
func (a *ReportsApiService) GetDataTransferFromVaultsReportRequestExecute(r ApiGetDataTransferFromVaultsReportRequestRequest) (DataTransferFromVaultsSummaryResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DataTransferFromVaultsSummaryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetDataTransferFromVaultsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/dataTransferFromVaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.VaultIds == nil {
		return localVarReturnValue, nil, reportError("VaultIds is required and must be specified")
	}

	if r.StartTimeMsecs != nil {
		localVarQueryParams.Add("startTimeMsecs", parameterToString(*r.StartTimeMsecs, ""))
	}
	if r.EndTimeMsecs != nil {
		localVarQueryParams.Add("endTimeMsecs", parameterToString(*r.EndTimeMsecs, ""))
	}
	localVarQueryParams.Add("vaultIds", parameterToString(*r.VaultIds, "csv"))
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.GroupBy != nil {
		localVarQueryParams.Add("groupBy", parameterToString(*r.GroupBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataTransferToVaultsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	VaultIds *[]int64
	StartTimeMsecs *int64
	EndTimeMsecs *int64
	OutputFormat *string
	GroupBy *int32
}


func (a *ReportsApiService) GetDataTransferToVaultsReportRequest(r ApiGetDataTransferToVaultsReportRequestRequest) (DataTransferToVaultsSummaryResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return DataTransferToVaultsSummaryResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetDataTransferToVaultsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return DataTransferToVaultsSummaryResponse
 */
func (a *ReportsApiService) GetDataTransferToVaultsReportRequestExecute(r ApiGetDataTransferToVaultsReportRequestRequest) (DataTransferToVaultsSummaryResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DataTransferToVaultsSummaryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetDataTransferToVaultsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/dataTransferToVaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.VaultIds == nil {
		return localVarReturnValue, nil, reportError("VaultIds is required and must be specified")
	}

	if r.StartTimeMsecs != nil {
		localVarQueryParams.Add("startTimeMsecs", parameterToString(*r.StartTimeMsecs, ""))
	}
	if r.EndTimeMsecs != nil {
		localVarQueryParams.Add("endTimeMsecs", parameterToString(*r.EndTimeMsecs, ""))
	}
	localVarQueryParams.Add("vaultIds", parameterToString(*r.VaultIds, "csv"))
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.GroupBy != nil {
		localVarQueryParams.Add("groupBy", parameterToString(*r.GroupBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdprReportRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	Id *[]int64
	AccessibleUsers *[]string
	ParentSourceId *[]int64
	OutputFormat *string
	Actions *[]string
	Search *string
	StartTimeUsecs *int64
	EndTimeUsecs *int64
}


func (a *ReportsApiService) GetGdprReport(r ApiGetGdprReportRequest) ([]ObjectInformation, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ObjectInformation{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetGdprReportExecute(r)
}


/*
 * Execute executes the request
 * @return []ObjectInformation
 */
func (a *ReportsApiService) GetGdprReportExecute(r ApiGetGdprReportRequest) ([]ObjectInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ObjectInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetGdprReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/gdpr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.Id, "csv"))
	}
	if r.AccessibleUsers != nil {
		localVarQueryParams.Add("accessibleUsers", parameterToString(*r.AccessibleUsers, "csv"))
	}
	if r.ParentSourceId != nil {
		localVarQueryParams.Add("parentSourceId", parameterToString(*r.ParentSourceId, "csv"))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.Actions != nil {
		localVarQueryParams.Add("actions", parameterToString(*r.Actions, "csv"))
	}
	if r.Search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.Search, ""))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectedObjectsTrendsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	Timezone *string
	JobIds *[]int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	Environments *[]string
	ProtectedObjectIds *[]int64
	RegisteredSourceId *int64
	Rollup *string
	TenantIds *[]string
	AllUnderHierarchy *bool
}


func (a *ReportsApiService) GetProtectedObjectsTrendsReportRequest(r ApiGetProtectedObjectsTrendsReportRequestRequest) ([]ProtectionTrend, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionTrend{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectedObjectsTrendsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionTrend
 */
func (a *ReportsApiService) GetProtectedObjectsTrendsReportRequestExecute(r ApiGetProtectedObjectsTrendsReportRequestRequest) ([]ProtectionTrend, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionTrend
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetProtectedObjectsTrendsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/protectedObjectsTrends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Timezone == nil {
		return localVarReturnValue, nil, reportError("Timezone is required and must be specified")
	}

	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	localVarQueryParams.Add("timezone", parameterToString(*r.Timezone, ""))
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.ProtectedObjectIds != nil {
		localVarQueryParams.Add("protectedObjectIds", parameterToString(*r.ProtectedObjectIds, "csv"))
	}
	if r.RegisteredSourceId != nil {
		localVarQueryParams.Add("registeredSourceId", parameterToString(*r.RegisteredSourceId, ""))
	}
	if r.Rollup != nil {
		localVarQueryParams.Add("rollup", parameterToString(*r.Rollup, ""))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionSourcesJobRunsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	ProtectionSourceIds *[]int64
	TenantIds *[]string
	AllUnderHierarchy *bool
	JobIds *[]int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	Environments *[]string
	OutputFormat *string
	PageCount *int32
	RunStatus *[]string
}


func (a *ReportsApiService) GetProtectionSourcesJobRunsReportRequest(r ApiGetProtectionSourcesJobRunsReportRequestRequest) ([]ProtectionSourcesJobRunsReportElement, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionSourcesJobRunsReportElement{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionSourcesJobRunsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionSourcesJobRunsReportElement
 */
func (a *ReportsApiService) GetProtectionSourcesJobRunsReportRequestExecute(r ApiGetProtectionSourcesJobRunsReportRequestRequest) ([]ProtectionSourcesJobRunsReportElement, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionSourcesJobRunsReportElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetProtectionSourcesJobRunsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/protectionSourcesJobRuns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ProtectionSourceIds == nil {
		return localVarReturnValue, nil, reportError("ProtectionSourceIds is required and must be specified")
	}

	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	localVarQueryParams.Add("protectionSourceIds", parameterToString(*r.ProtectionSourceIds, "csv"))
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.PageCount != nil {
		localVarQueryParams.Add("pageCount", parameterToString(*r.PageCount, ""))
	}
	if r.RunStatus != nil {
		localVarQueryParams.Add("runStatus", parameterToString(*r.RunStatus, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionSourcesJobsSummaryReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	JobIds *[]int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	Environments *[]string
	ProtectionSourceIds *[]int64
	Statuses *[]string
	OutputFormat *string
	RegisteredSourceId *int64
	ConsecutiveFailures *int32
	ReportName *string
	ReportType *int32
	TenantIds *[]string
	AllUnderHierarchy *bool
}


func (a *ReportsApiService) GetProtectionSourcesJobsSummaryReportRequest(r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) (ProtectionSourcesJobsSummaryReportResponseWrapper, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSourcesJobsSummaryReportResponseWrapper{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionSourcesJobsSummaryReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSourcesJobsSummaryReportResponseWrapper
 */
func (a *ReportsApiService) GetProtectionSourcesJobsSummaryReportRequestExecute(r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) (ProtectionSourcesJobsSummaryReportResponseWrapper, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSourcesJobsSummaryReportResponseWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetProtectionSourcesJobsSummaryReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/protectionSourcesJobsSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.ProtectionSourceIds != nil {
		localVarQueryParams.Add("protectionSourceIds", parameterToString(*r.ProtectionSourceIds, "csv"))
	}
	if r.Statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.Statuses, "csv"))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.RegisteredSourceId != nil {
		localVarQueryParams.Add("registeredSourceId", parameterToString(*r.RegisteredSourceId, ""))
	}
	if r.ConsecutiveFailures != nil {
		localVarQueryParams.Add("consecutiveFailures", parameterToString(*r.ConsecutiveFailures, ""))
	}
	if r.ReportName != nil {
		localVarQueryParams.Add("reportName", parameterToString(*r.ReportName, ""))
	}
	if r.ReportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.ReportType, ""))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
