/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
)

// Linger please
var (
	_ _context.Context
)

// ReportsApiService ReportsApi service
type ReportsApiService service

type ApiGetAgentDeploymentReportRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	HostOsType *[]string
	CompactVersion *string
	OutputFormat *string
	HealthStatus *[]string
}

/*

func (r ApiGetAgentDeploymentReportRequest) HostOsType(hostOsType []string) ApiGetAgentDeploymentReportRequest {
	r.hostOsType = &hostOsType
	return r
}
func (r ApiGetAgentDeploymentReportRequest) CompactVersion(compactVersion string) ApiGetAgentDeploymentReportRequest {
	r.compactVersion = &compactVersion
	return r
}
func (r ApiGetAgentDeploymentReportRequest) OutputFormat(outputFormat string) ApiGetAgentDeploymentReportRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiGetAgentDeploymentReportRequest) HealthStatus(healthStatus []string) ApiGetAgentDeploymentReportRequest {
	r.healthStatus = &healthStatus
	return r
}
*/

/*
func (r ApiGetAgentDeploymentReportRequest) Execute() ([]AgentDeploymentStatusResponse, *_nethttp.Response, error) {
	return r.ApiService.GetAgentDeploymentReportExecute(r)
}

 * GetAgentDeploymentReport Method for GetAgentDeploymentReport
 * Get the list of all the installed agents which includes the health status and
upgradability of the agent.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAgentDeploymentReportRequest
 
func (a *ReportsApiService) GetAgentDeploymentReport(ctx _context.Context) ApiGetAgentDeploymentReportRequest {
	return ApiGetAgentDeploymentReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ReportsApiService) GetAgentDeploymentReport(r ApiGetAgentDeploymentReportRequest) ([]AgentDeploymentStatusResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []AgentDeploymentStatusResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetAgentDeploymentReportExecute(r)
}


/*
 * Execute executes the request
 * @return []AgentDeploymentStatusResponse
 */
func (a *ReportsApiService) GetAgentDeploymentReportExecute(r ApiGetAgentDeploymentReportRequest) ([]AgentDeploymentStatusResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AgentDeploymentStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetAgentDeploymentReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/agents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.HostOsType != nil {
		localVarQueryParams.Add("hostOsType", parameterToString(*r.HostOsType, "csv"))
	}
	if r.CompactVersion != nil {
		localVarQueryParams.Add("compactVersion", parameterToString(*r.CompactVersion, ""))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.HealthStatus != nil {
		localVarQueryParams.Add("healthStatus", parameterToString(*r.HealthStatus, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataTransferFromVaultsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	VaultIds *[]int64
	StartTimeMsecs *int64
	EndTimeMsecs *int64
	OutputFormat *string
	GroupBy *int32
}

/*

func (r ApiGetDataTransferFromVaultsReportRequestRequest) VaultIds(vaultIds []int64) ApiGetDataTransferFromVaultsReportRequestRequest {
	r.vaultIds = &vaultIds
	return r
}
func (r ApiGetDataTransferFromVaultsReportRequestRequest) StartTimeMsecs(startTimeMsecs int64) ApiGetDataTransferFromVaultsReportRequestRequest {
	r.startTimeMsecs = &startTimeMsecs
	return r
}
func (r ApiGetDataTransferFromVaultsReportRequestRequest) EndTimeMsecs(endTimeMsecs int64) ApiGetDataTransferFromVaultsReportRequestRequest {
	r.endTimeMsecs = &endTimeMsecs
	return r
}
func (r ApiGetDataTransferFromVaultsReportRequestRequest) OutputFormat(outputFormat string) ApiGetDataTransferFromVaultsReportRequestRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiGetDataTransferFromVaultsReportRequestRequest) GroupBy(groupBy int32) ApiGetDataTransferFromVaultsReportRequestRequest {
	r.groupBy = &groupBy
	return r
}
*/

/*
func (r ApiGetDataTransferFromVaultsReportRequestRequest) Execute() (DataTransferFromVaultsSummaryResponse, *_nethttp.Response, error) {
	return r.ApiService.GetDataTransferFromVaultsReportRequestExecute(r)
}

 * GetDataTransferFromVaultsReportRequest Get summary statistics about transferring data from Vaults (External Targets) to this Cohesity Cluster.
 * A Vault can provide an additional Cloud Tier where cold data of the
Cohesity Cluster is stored in the Cloud.
A Vault can also provide archive storage for backup data.
This archive data is stored on Tapes and in Cloud Vaults.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDataTransferFromVaultsReportRequestRequest
 
func (a *ReportsApiService) GetDataTransferFromVaultsReportRequest(ctx _context.Context) ApiGetDataTransferFromVaultsReportRequestRequest {
	return ApiGetDataTransferFromVaultsReportRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ReportsApiService) GetDataTransferFromVaultsReportRequest(r ApiGetDataTransferFromVaultsReportRequestRequest) (DataTransferFromVaultsSummaryResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return DataTransferFromVaultsSummaryResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetDataTransferFromVaultsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return DataTransferFromVaultsSummaryResponse
 */
func (a *ReportsApiService) GetDataTransferFromVaultsReportRequestExecute(r ApiGetDataTransferFromVaultsReportRequestRequest) (DataTransferFromVaultsSummaryResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DataTransferFromVaultsSummaryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetDataTransferFromVaultsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/dataTransferFromVaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.VaultIds == nil {
		return localVarReturnValue, nil, reportError("VaultIds is required and must be specified")
	}

	if r.StartTimeMsecs != nil {
		localVarQueryParams.Add("startTimeMsecs", parameterToString(*r.StartTimeMsecs, ""))
	}
	if r.EndTimeMsecs != nil {
		localVarQueryParams.Add("endTimeMsecs", parameterToString(*r.EndTimeMsecs, ""))
	}
	localVarQueryParams.Add("vaultIds", parameterToString(*r.VaultIds, "csv"))
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.GroupBy != nil {
		localVarQueryParams.Add("groupBy", parameterToString(*r.GroupBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataTransferToVaultsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	VaultIds *[]int64
	StartTimeMsecs *int64
	EndTimeMsecs *int64
	OutputFormat *string
	GroupBy *int32
}

/*

func (r ApiGetDataTransferToVaultsReportRequestRequest) VaultIds(vaultIds []int64) ApiGetDataTransferToVaultsReportRequestRequest {
	r.vaultIds = &vaultIds
	return r
}
func (r ApiGetDataTransferToVaultsReportRequestRequest) StartTimeMsecs(startTimeMsecs int64) ApiGetDataTransferToVaultsReportRequestRequest {
	r.startTimeMsecs = &startTimeMsecs
	return r
}
func (r ApiGetDataTransferToVaultsReportRequestRequest) EndTimeMsecs(endTimeMsecs int64) ApiGetDataTransferToVaultsReportRequestRequest {
	r.endTimeMsecs = &endTimeMsecs
	return r
}
func (r ApiGetDataTransferToVaultsReportRequestRequest) OutputFormat(outputFormat string) ApiGetDataTransferToVaultsReportRequestRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiGetDataTransferToVaultsReportRequestRequest) GroupBy(groupBy int32) ApiGetDataTransferToVaultsReportRequestRequest {
	r.groupBy = &groupBy
	return r
}
*/

/*
func (r ApiGetDataTransferToVaultsReportRequestRequest) Execute() (DataTransferToVaultsSummaryResponse, *_nethttp.Response, error) {
	return r.ApiService.GetDataTransferToVaultsReportRequestExecute(r)
}

 * GetDataTransferToVaultsReportRequest Get summary statistics about transferring data from the Cohesity Cluster to Vaults (External Targets).
 * A Vault can provide an additional Cloud Tier where cold data of the
Cohesity Cluster can be stored in the Cloud.
A Vault can also provide archive storage for backup data.
This archive data is stored on Tapes and in Cloud Vaults.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDataTransferToVaultsReportRequestRequest
 
func (a *ReportsApiService) GetDataTransferToVaultsReportRequest(ctx _context.Context) ApiGetDataTransferToVaultsReportRequestRequest {
	return ApiGetDataTransferToVaultsReportRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ReportsApiService) GetDataTransferToVaultsReportRequest(r ApiGetDataTransferToVaultsReportRequestRequest) (DataTransferToVaultsSummaryResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return DataTransferToVaultsSummaryResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetDataTransferToVaultsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return DataTransferToVaultsSummaryResponse
 */
func (a *ReportsApiService) GetDataTransferToVaultsReportRequestExecute(r ApiGetDataTransferToVaultsReportRequestRequest) (DataTransferToVaultsSummaryResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DataTransferToVaultsSummaryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetDataTransferToVaultsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/dataTransferToVaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.VaultIds == nil {
		return localVarReturnValue, nil, reportError("VaultIds is required and must be specified")
	}

	if r.StartTimeMsecs != nil {
		localVarQueryParams.Add("startTimeMsecs", parameterToString(*r.StartTimeMsecs, ""))
	}
	if r.EndTimeMsecs != nil {
		localVarQueryParams.Add("endTimeMsecs", parameterToString(*r.EndTimeMsecs, ""))
	}
	localVarQueryParams.Add("vaultIds", parameterToString(*r.VaultIds, "csv"))
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.GroupBy != nil {
		localVarQueryParams.Add("groupBy", parameterToString(*r.GroupBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGdprReportRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	Id *[]int64
	AccessibleUsers *[]string
	ParentSourceId *[]int64
	OutputFormat *string
	Actions *[]string
	Search *string
	StartTimeUsecs *int64
	EndTimeUsecs *int64
}

/*

func (r ApiGetGdprReportRequest) Id(id []int64) ApiGetGdprReportRequest {
	r.id = &id
	return r
}
func (r ApiGetGdprReportRequest) AccessibleUsers(accessibleUsers []string) ApiGetGdprReportRequest {
	r.accessibleUsers = &accessibleUsers
	return r
}
func (r ApiGetGdprReportRequest) ParentSourceId(parentSourceId []int64) ApiGetGdprReportRequest {
	r.parentSourceId = &parentSourceId
	return r
}
func (r ApiGetGdprReportRequest) OutputFormat(outputFormat string) ApiGetGdprReportRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiGetGdprReportRequest) Actions(actions []string) ApiGetGdprReportRequest {
	r.actions = &actions
	return r
}
func (r ApiGetGdprReportRequest) Search(search string) ApiGetGdprReportRequest {
	r.search = &search
	return r
}
func (r ApiGetGdprReportRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetGdprReportRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetGdprReportRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetGdprReportRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
*/

/*
func (r ApiGetGdprReportRequest) Execute() ([]ObjectInformation, *_nethttp.Response, error) {
	return r.ApiService.GetGdprReportExecute(r)
}

 * GetGdprReport Get gdpr report related information.
 * Returns the GDPR report information.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetGdprReportRequest
 
func (a *ReportsApiService) GetGdprReport(ctx _context.Context) ApiGetGdprReportRequest {
	return ApiGetGdprReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ReportsApiService) GetGdprReport(r ApiGetGdprReportRequest) ([]ObjectInformation, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ObjectInformation{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetGdprReportExecute(r)
}


/*
 * Execute executes the request
 * @return []ObjectInformation
 */
func (a *ReportsApiService) GetGdprReportExecute(r ApiGetGdprReportRequest) ([]ObjectInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ObjectInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetGdprReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/gdpr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.Id, "csv"))
	}
	if r.AccessibleUsers != nil {
		localVarQueryParams.Add("accessibleUsers", parameterToString(*r.AccessibleUsers, "csv"))
	}
	if r.ParentSourceId != nil {
		localVarQueryParams.Add("parentSourceId", parameterToString(*r.ParentSourceId, "csv"))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.Actions != nil {
		localVarQueryParams.Add("actions", parameterToString(*r.Actions, "csv"))
	}
	if r.Search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.Search, ""))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectedObjectsTrendsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	Timezone *string
	JobIds *[]int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	Environments *[]string
	ProtectedObjectIds *[]int64
	RegisteredSourceId *int64
	Rollup *string
	TenantIds *[]string
	AllUnderHierarchy *bool
}

/*

func (r ApiGetProtectedObjectsTrendsReportRequestRequest) Timezone(timezone string) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.timezone = &timezone
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) JobIds(jobIds []int64) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.jobIds = &jobIds
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) Environments(environments []string) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.environments = &environments
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) ProtectedObjectIds(protectedObjectIds []int64) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.protectedObjectIds = &protectedObjectIds
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) RegisteredSourceId(registeredSourceId int64) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.registeredSourceId = &registeredSourceId
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) Rollup(rollup string) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.rollup = &rollup
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) TenantIds(tenantIds []string) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetProtectedObjectsTrendsReportRequestRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiGetProtectedObjectsTrendsReportRequestRequest) Execute() ([]ProtectionTrend, *_nethttp.Response, error) {
	return r.ApiService.GetProtectedObjectsTrendsReportRequestExecute(r)
}

 * GetProtectedObjectsTrendsReportRequest Get protected objects trends grouped by days/weeks/months.
 * This gives a summary of protection trend for protected resources during the
given time range.
If no roll up is specified, then the trends will be grouped by days.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectedObjectsTrendsReportRequestRequest
 
func (a *ReportsApiService) GetProtectedObjectsTrendsReportRequest(ctx _context.Context) ApiGetProtectedObjectsTrendsReportRequestRequest {
	return ApiGetProtectedObjectsTrendsReportRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ReportsApiService) GetProtectedObjectsTrendsReportRequest(r ApiGetProtectedObjectsTrendsReportRequestRequest) ([]ProtectionTrend, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionTrend{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectedObjectsTrendsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionTrend
 */
func (a *ReportsApiService) GetProtectedObjectsTrendsReportRequestExecute(r ApiGetProtectedObjectsTrendsReportRequestRequest) ([]ProtectionTrend, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionTrend
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetProtectedObjectsTrendsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/protectedObjectsTrends"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Timezone == nil {
		return localVarReturnValue, nil, reportError("Timezone is required and must be specified")
	}

	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	localVarQueryParams.Add("timezone", parameterToString(*r.Timezone, ""))
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.ProtectedObjectIds != nil {
		localVarQueryParams.Add("protectedObjectIds", parameterToString(*r.ProtectedObjectIds, "csv"))
	}
	if r.RegisteredSourceId != nil {
		localVarQueryParams.Add("registeredSourceId", parameterToString(*r.RegisteredSourceId, ""))
	}
	if r.Rollup != nil {
		localVarQueryParams.Add("rollup", parameterToString(*r.Rollup, ""))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionSourcesJobRunsReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	ProtectionSourceIds *[]int64
	TenantIds *[]string
	AllUnderHierarchy *bool
	JobIds *[]int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	Environments *[]string
	OutputFormat *string
	PageCount *int32
	RunStatus *[]string
}

/*

func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) ProtectionSourceIds(protectionSourceIds []int64) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.protectionSourceIds = &protectionSourceIds
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) TenantIds(tenantIds []string) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) JobIds(jobIds []int64) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.jobIds = &jobIds
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) Environments(environments []string) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.environments = &environments
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) OutputFormat(outputFormat string) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) PageCount(pageCount int32) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.pageCount = &pageCount
	return r
}
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) RunStatus(runStatus []string) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	r.runStatus = &runStatus
	return r
}
*/

/*
func (r ApiGetProtectionSourcesJobRunsReportRequestRequest) Execute() ([]ProtectionSourcesJobRunsReportElement, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionSourcesJobRunsReportRequestExecute(r)
}

 * GetProtectionSourcesJobRunsReportRequest Get protection details about the specified list of leaf Protection Source Objects (such as a VMs).
 * Returns the Snapshots that contain backups of the specified
Protection Source Objects and match the specified filter criteria.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectionSourcesJobRunsReportRequestRequest
 
func (a *ReportsApiService) GetProtectionSourcesJobRunsReportRequest(ctx _context.Context) ApiGetProtectionSourcesJobRunsReportRequestRequest {
	return ApiGetProtectionSourcesJobRunsReportRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ReportsApiService) GetProtectionSourcesJobRunsReportRequest(r ApiGetProtectionSourcesJobRunsReportRequestRequest) ([]ProtectionSourcesJobRunsReportElement, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionSourcesJobRunsReportElement{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionSourcesJobRunsReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionSourcesJobRunsReportElement
 */
func (a *ReportsApiService) GetProtectionSourcesJobRunsReportRequestExecute(r ApiGetProtectionSourcesJobRunsReportRequestRequest) ([]ProtectionSourcesJobRunsReportElement, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionSourcesJobRunsReportElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetProtectionSourcesJobRunsReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/protectionSourcesJobRuns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ProtectionSourceIds == nil {
		return localVarReturnValue, nil, reportError("ProtectionSourceIds is required and must be specified")
	}

	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	localVarQueryParams.Add("protectionSourceIds", parameterToString(*r.ProtectionSourceIds, "csv"))
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.PageCount != nil {
		localVarQueryParams.Add("pageCount", parameterToString(*r.PageCount, ""))
	}
	if r.RunStatus != nil {
		localVarQueryParams.Add("runStatus", parameterToString(*r.RunStatus, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionSourcesJobsSummaryReportRequestRequest struct {
	ctx _context.Context
	ApiService *ReportsApiService
	JobIds *[]int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	Environments *[]string
	ProtectionSourceIds *[]int64
	Statuses *[]string
	OutputFormat *string
	RegisteredSourceId *int64
	ConsecutiveFailures *int32
	ReportName *string
	ReportType *int32
	TenantIds *[]string
	AllUnderHierarchy *bool
}

/*

func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) JobIds(jobIds []int64) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.jobIds = &jobIds
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) Environments(environments []string) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.environments = &environments
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) ProtectionSourceIds(protectionSourceIds []int64) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.protectionSourceIds = &protectionSourceIds
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) Statuses(statuses []string) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.statuses = &statuses
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) OutputFormat(outputFormat string) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) RegisteredSourceId(registeredSourceId int64) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.registeredSourceId = &registeredSourceId
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) ConsecutiveFailures(consecutiveFailures int32) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.consecutiveFailures = &consecutiveFailures
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) ReportName(reportName string) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.reportName = &reportName
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) ReportType(reportType int32) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.reportType = &reportType
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) TenantIds(tenantIds []string) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) Execute() (ProtectionSourcesJobsSummaryReportResponseWrapper, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionSourcesJobsSummaryReportRequestExecute(r)
}

 * GetProtectionSourcesJobsSummaryReportRequest Get Job Run (Snapshot) summary statistics about the leaf Protection Sources Objects that match the specified filter criteria.
 * For example, if two Job ids are passed in, Snapshot summary statistics about
all the leaf Objects that have been protected by the two specified
Jobs are reported.
For example, if a top level registered Source id is passed in, summary
statistics about all the Snapshots backing up leaf Objects in
the specified Source are reported.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectionSourcesJobsSummaryReportRequestRequest
 
func (a *ReportsApiService) GetProtectionSourcesJobsSummaryReportRequest(ctx _context.Context) ApiGetProtectionSourcesJobsSummaryReportRequestRequest {
	return ApiGetProtectionSourcesJobsSummaryReportRequestRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ReportsApiService) GetProtectionSourcesJobsSummaryReportRequest(r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) (ProtectionSourcesJobsSummaryReportResponseWrapper, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSourcesJobsSummaryReportResponseWrapper{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionSourcesJobsSummaryReportRequestExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSourcesJobsSummaryReportResponseWrapper
 */
func (a *ReportsApiService) GetProtectionSourcesJobsSummaryReportRequestExecute(r ApiGetProtectionSourcesJobsSummaryReportRequestRequest) (ProtectionSourcesJobsSummaryReportResponseWrapper, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSourcesJobsSummaryReportResponseWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportsApiService.GetProtectionSourcesJobsSummaryReportRequest")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/reports/protectionSourcesJobsSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.ProtectionSourceIds != nil {
		localVarQueryParams.Add("protectionSourceIds", parameterToString(*r.ProtectionSourceIds, "csv"))
	}
	if r.Statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.Statuses, "csv"))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.RegisteredSourceId != nil {
		localVarQueryParams.Add("registeredSourceId", parameterToString(*r.RegisteredSourceId, ""))
	}
	if r.ConsecutiveFailures != nil {
		localVarQueryParams.Add("consecutiveFailures", parameterToString(*r.ConsecutiveFailures, ""))
	}
	if r.ReportName != nil {
		localVarQueryParams.Add("reportName", parameterToString(*r.ReportName, ""))
	}
	if r.ReportType != nil {
		localVarQueryParams.Add("reportType", parameterToString(*r.ReportType, ""))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
