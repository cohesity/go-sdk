/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the UpdateExistingArchivalSnapshotConfig type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &UpdateExistingArchivalSnapshotConfig{}

// UpdateExistingArchivalSnapshotConfig Specifies the configuration about updating an existing Archival Snapshot Run.
type UpdateExistingArchivalSnapshotConfig struct {
	// Specifies the snapshot's archival target type from which recovery has been performed.
	ArchivalTargetType NullableString `json:"archivalTargetType"`
	// Specifies WORM retention type for the snapshots. When a WORM retention type is specified, the snapshots of the Protection Groups using this policy will be kept until the maximum of the snapshot retention time. During that time, the snapshots cannot be deleted. <br>'Compliance' implies WORM retention is set for compliance reason. <br>'Administrative' implies WORM retention is set for administrative purposes.
	DataLock NullableString `json:"dataLock,omitempty"`
	// Specifies number of days to retain the snapshots. If positive, then this value is added to exisiting expiry time thereby increasing  the retention period of the snapshot. Conversly, if this value is negative, then value is subtracted to existing expiry time thereby decreasing the retention period of the snaphot. Here, by this operation if expiry time goes below current time then snapshot is immediately deleted.
	DaysToKeep NullableInt64 `json:"daysToKeep,omitempty"`
	// Specifies whether to delete the snapshot. When this is set to true, all other params will be ignored.
	DeleteSnapshot NullableBool `json:"deleteSnapshot,omitempty"`
	// Specifies whether to retain the snapshot for legal purpose. If set to true, the snapshots cannot be deleted until the retention period. Note that using this option may cause the Cluster to run out of space. If set to false explicitly, the hold is removed, and the snapshots will expire as specified in the policy of the Protection Group. If this field is not specified, there is no change to the hold of the run. This field can be set only by a User having Data Security Role.
	EnableLegalHold NullableBool `json:"enableLegalHold,omitempty"`
	// Specifies the id of the archival target.
	Id int64 `json:"id"`
	// Specifies the name of the archival target.
	Name NullableString `json:"name,omitempty"`
	// Specifies whether to retry the archival operation in case if earlier attempt failed. If not specified or set to false, archival is not retried.
	Resync NullableBool `json:"resync,omitempty"`
}

type _UpdateExistingArchivalSnapshotConfig UpdateExistingArchivalSnapshotConfig

// NewUpdateExistingArchivalSnapshotConfig instantiates a new UpdateExistingArchivalSnapshotConfig object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewUpdateExistingArchivalSnapshotConfig(archivalTargetType NullableString, id int64) *UpdateExistingArchivalSnapshotConfig {
	this := UpdateExistingArchivalSnapshotConfig{}
	this.ArchivalTargetType = archivalTargetType
	this.Id = id
	return &this
}

// NewUpdateExistingArchivalSnapshotConfigWithDefaults instantiates a new UpdateExistingArchivalSnapshotConfig object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewUpdateExistingArchivalSnapshotConfigWithDefaults() *UpdateExistingArchivalSnapshotConfig {
	this := UpdateExistingArchivalSnapshotConfig{}
	return &this
}

// GetArchivalTargetType returns the ArchivalTargetType field value
// If the value is explicit nil, the zero value for string will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetArchivalTargetType() string {
	if o == nil || o.ArchivalTargetType.Get() == nil {
		var ret string
		return ret
	}

	return *o.ArchivalTargetType.Get()
}

// GetArchivalTargetTypeOk returns a tuple with the ArchivalTargetType field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetArchivalTargetTypeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.ArchivalTargetType.Get(), o.ArchivalTargetType.IsSet()
}

// SetArchivalTargetType sets field value
func (o *UpdateExistingArchivalSnapshotConfig) SetArchivalTargetType(v string) {
	o.ArchivalTargetType.Set(&v)
}

// GetDataLock returns the DataLock field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UpdateExistingArchivalSnapshotConfig) GetDataLock() string {
	if o == nil || IsNil(o.DataLock.Get()) {
		var ret string
		return ret
	}
	return *o.DataLock.Get()
}

// GetDataLockOk returns a tuple with the DataLock field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetDataLockOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.DataLock.Get(), o.DataLock.IsSet()
}

// HasDataLock returns a boolean if a field has been set.
func (o *UpdateExistingArchivalSnapshotConfig) HasDataLock() bool {
	if o != nil && o.DataLock.IsSet() {
		return true
	}

	return false
}

// SetDataLock gets a reference to the given NullableString and assigns it to the DataLock field.
func (o *UpdateExistingArchivalSnapshotConfig) SetDataLock(v string) {
	o.DataLock.Set(&v)
}
// SetDataLockNil sets the value for DataLock to be an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) SetDataLockNil() {
	o.DataLock.Set(nil)
}

// UnsetDataLock ensures that no value is present for DataLock, not even an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) UnsetDataLock() {
	o.DataLock.Unset()
}

// GetDaysToKeep returns the DaysToKeep field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UpdateExistingArchivalSnapshotConfig) GetDaysToKeep() int64 {
	if o == nil || IsNil(o.DaysToKeep.Get()) {
		var ret int64
		return ret
	}
	return *o.DaysToKeep.Get()
}

// GetDaysToKeepOk returns a tuple with the DaysToKeep field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetDaysToKeepOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return o.DaysToKeep.Get(), o.DaysToKeep.IsSet()
}

// HasDaysToKeep returns a boolean if a field has been set.
func (o *UpdateExistingArchivalSnapshotConfig) HasDaysToKeep() bool {
	if o != nil && o.DaysToKeep.IsSet() {
		return true
	}

	return false
}

// SetDaysToKeep gets a reference to the given NullableInt64 and assigns it to the DaysToKeep field.
func (o *UpdateExistingArchivalSnapshotConfig) SetDaysToKeep(v int64) {
	o.DaysToKeep.Set(&v)
}
// SetDaysToKeepNil sets the value for DaysToKeep to be an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) SetDaysToKeepNil() {
	o.DaysToKeep.Set(nil)
}

// UnsetDaysToKeep ensures that no value is present for DaysToKeep, not even an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) UnsetDaysToKeep() {
	o.DaysToKeep.Unset()
}

// GetDeleteSnapshot returns the DeleteSnapshot field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UpdateExistingArchivalSnapshotConfig) GetDeleteSnapshot() bool {
	if o == nil || IsNil(o.DeleteSnapshot.Get()) {
		var ret bool
		return ret
	}
	return *o.DeleteSnapshot.Get()
}

// GetDeleteSnapshotOk returns a tuple with the DeleteSnapshot field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetDeleteSnapshotOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return o.DeleteSnapshot.Get(), o.DeleteSnapshot.IsSet()
}

// HasDeleteSnapshot returns a boolean if a field has been set.
func (o *UpdateExistingArchivalSnapshotConfig) HasDeleteSnapshot() bool {
	if o != nil && o.DeleteSnapshot.IsSet() {
		return true
	}

	return false
}

// SetDeleteSnapshot gets a reference to the given NullableBool and assigns it to the DeleteSnapshot field.
func (o *UpdateExistingArchivalSnapshotConfig) SetDeleteSnapshot(v bool) {
	o.DeleteSnapshot.Set(&v)
}
// SetDeleteSnapshotNil sets the value for DeleteSnapshot to be an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) SetDeleteSnapshotNil() {
	o.DeleteSnapshot.Set(nil)
}

// UnsetDeleteSnapshot ensures that no value is present for DeleteSnapshot, not even an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) UnsetDeleteSnapshot() {
	o.DeleteSnapshot.Unset()
}

// GetEnableLegalHold returns the EnableLegalHold field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UpdateExistingArchivalSnapshotConfig) GetEnableLegalHold() bool {
	if o == nil || IsNil(o.EnableLegalHold.Get()) {
		var ret bool
		return ret
	}
	return *o.EnableLegalHold.Get()
}

// GetEnableLegalHoldOk returns a tuple with the EnableLegalHold field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetEnableLegalHoldOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return o.EnableLegalHold.Get(), o.EnableLegalHold.IsSet()
}

// HasEnableLegalHold returns a boolean if a field has been set.
func (o *UpdateExistingArchivalSnapshotConfig) HasEnableLegalHold() bool {
	if o != nil && o.EnableLegalHold.IsSet() {
		return true
	}

	return false
}

// SetEnableLegalHold gets a reference to the given NullableBool and assigns it to the EnableLegalHold field.
func (o *UpdateExistingArchivalSnapshotConfig) SetEnableLegalHold(v bool) {
	o.EnableLegalHold.Set(&v)
}
// SetEnableLegalHoldNil sets the value for EnableLegalHold to be an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) SetEnableLegalHoldNil() {
	o.EnableLegalHold.Set(nil)
}

// UnsetEnableLegalHold ensures that no value is present for EnableLegalHold, not even an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) UnsetEnableLegalHold() {
	o.EnableLegalHold.Unset()
}

// GetId returns the Id field value
func (o *UpdateExistingArchivalSnapshotConfig) GetId() int64 {
	if o == nil {
		var ret int64
		return ret
	}

	return o.Id
}

// GetIdOk returns a tuple with the Id field value
// and a boolean to check if the value has been set.
func (o *UpdateExistingArchivalSnapshotConfig) GetIdOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Id, true
}

// SetId sets field value
func (o *UpdateExistingArchivalSnapshotConfig) SetId(v int64) {
	o.Id = v
}

// GetName returns the Name field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UpdateExistingArchivalSnapshotConfig) GetName() string {
	if o == nil || IsNil(o.Name.Get()) {
		var ret string
		return ret
	}
	return *o.Name.Get()
}

// GetNameOk returns a tuple with the Name field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Name.Get(), o.Name.IsSet()
}

// HasName returns a boolean if a field has been set.
func (o *UpdateExistingArchivalSnapshotConfig) HasName() bool {
	if o != nil && o.Name.IsSet() {
		return true
	}

	return false
}

// SetName gets a reference to the given NullableString and assigns it to the Name field.
func (o *UpdateExistingArchivalSnapshotConfig) SetName(v string) {
	o.Name.Set(&v)
}
// SetNameNil sets the value for Name to be an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) SetNameNil() {
	o.Name.Set(nil)
}

// UnsetName ensures that no value is present for Name, not even an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) UnsetName() {
	o.Name.Unset()
}

// GetResync returns the Resync field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UpdateExistingArchivalSnapshotConfig) GetResync() bool {
	if o == nil || IsNil(o.Resync.Get()) {
		var ret bool
		return ret
	}
	return *o.Resync.Get()
}

// GetResyncOk returns a tuple with the Resync field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UpdateExistingArchivalSnapshotConfig) GetResyncOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return o.Resync.Get(), o.Resync.IsSet()
}

// HasResync returns a boolean if a field has been set.
func (o *UpdateExistingArchivalSnapshotConfig) HasResync() bool {
	if o != nil && o.Resync.IsSet() {
		return true
	}

	return false
}

// SetResync gets a reference to the given NullableBool and assigns it to the Resync field.
func (o *UpdateExistingArchivalSnapshotConfig) SetResync(v bool) {
	o.Resync.Set(&v)
}
// SetResyncNil sets the value for Resync to be an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) SetResyncNil() {
	o.Resync.Set(nil)
}

// UnsetResync ensures that no value is present for Resync, not even an explicit nil
func (o *UpdateExistingArchivalSnapshotConfig) UnsetResync() {
	o.Resync.Unset()
}

func (o UpdateExistingArchivalSnapshotConfig) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o UpdateExistingArchivalSnapshotConfig) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["archivalTargetType"] = o.ArchivalTargetType.Get()
	if o.DataLock.IsSet() {
		toSerialize["dataLock"] = o.DataLock.Get()
	}
	if o.DaysToKeep.IsSet() {
		toSerialize["daysToKeep"] = o.DaysToKeep.Get()
	}
	if o.DeleteSnapshot.IsSet() {
		toSerialize["deleteSnapshot"] = o.DeleteSnapshot.Get()
	}
	if o.EnableLegalHold.IsSet() {
		toSerialize["enableLegalHold"] = o.EnableLegalHold.Get()
	}
	toSerialize["id"] = o.Id
	if o.Name.IsSet() {
		toSerialize["name"] = o.Name.Get()
	}
	if o.Resync.IsSet() {
		toSerialize["resync"] = o.Resync.Get()
	}
	return toSerialize, nil
}

func (o *UpdateExistingArchivalSnapshotConfig) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"archivalTargetType",
		"id",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varUpdateExistingArchivalSnapshotConfig := _UpdateExistingArchivalSnapshotConfig{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varUpdateExistingArchivalSnapshotConfig)

	if err != nil {
		return err
	}

	*o = UpdateExistingArchivalSnapshotConfig(varUpdateExistingArchivalSnapshotConfig)

	return err
}

type NullableUpdateExistingArchivalSnapshotConfig struct {
	value *UpdateExistingArchivalSnapshotConfig
	isSet bool
}

func (v NullableUpdateExistingArchivalSnapshotConfig) Get() *UpdateExistingArchivalSnapshotConfig {
	return v.value
}

func (v *NullableUpdateExistingArchivalSnapshotConfig) Set(val *UpdateExistingArchivalSnapshotConfig) {
	v.value = val
	v.isSet = true
}

func (v NullableUpdateExistingArchivalSnapshotConfig) IsSet() bool {
	return v.isSet
}

func (v *NullableUpdateExistingArchivalSnapshotConfig) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableUpdateExistingArchivalSnapshotConfig(val *UpdateExistingArchivalSnapshotConfig) *NullableUpdateExistingArchivalSnapshotConfig {
	return &NullableUpdateExistingArchivalSnapshotConfig{value: val, isSet: true}
}

func (v NullableUpdateExistingArchivalSnapshotConfig) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableUpdateExistingArchivalSnapshotConfig) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


