/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the UptieringTarget type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &UptieringTarget{}

// UptieringTarget Specifies the target data tiering details for uptier job. This is in beta phase. Please use target inside CommonDataTieringTaskParams, present directly under data tiering request body. If target is present inside CommonDataTieringTaskParams, this target will be ignored.
type UptieringTarget struct {
	// Specifies a list of mapping between sources and its corresponding viewNames and mountPaths, where the sources were downtiered.
	DowntieredDataLocations []DowntieredDataLocation `json:"downtieredDataLocations,omitempty"`
	// Specifies the Storage Domain ID where the view will be kept.
	StorageDomainId NullableInt64 `json:"storageDomainId"`
}

type _UptieringTarget UptieringTarget

// NewUptieringTarget instantiates a new UptieringTarget object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewUptieringTarget(storageDomainId NullableInt64) *UptieringTarget {
	this := UptieringTarget{}
	this.StorageDomainId = storageDomainId
	return &this
}

// NewUptieringTargetWithDefaults instantiates a new UptieringTarget object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewUptieringTargetWithDefaults() *UptieringTarget {
	this := UptieringTarget{}
	return &this
}

// GetDowntieredDataLocations returns the DowntieredDataLocations field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UptieringTarget) GetDowntieredDataLocations() []DowntieredDataLocation {
	if o == nil {
		var ret []DowntieredDataLocation
		return ret
	}
	return o.DowntieredDataLocations
}

// GetDowntieredDataLocationsOk returns a tuple with the DowntieredDataLocations field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UptieringTarget) GetDowntieredDataLocationsOk() ([]DowntieredDataLocation, bool) {
	if o == nil || IsNil(o.DowntieredDataLocations) {
		return nil, false
	}
	return o.DowntieredDataLocations, true
}

// HasDowntieredDataLocations returns a boolean if a field has been set.
func (o *UptieringTarget) HasDowntieredDataLocations() bool {
	if o != nil && !IsNil(o.DowntieredDataLocations) {
		return true
	}

	return false
}

// SetDowntieredDataLocations gets a reference to the given []DowntieredDataLocation and assigns it to the DowntieredDataLocations field.
func (o *UptieringTarget) SetDowntieredDataLocations(v []DowntieredDataLocation) {
	o.DowntieredDataLocations = v
}

// GetStorageDomainId returns the StorageDomainId field value
// If the value is explicit nil, the zero value for int64 will be returned
func (o *UptieringTarget) GetStorageDomainId() int64 {
	if o == nil || o.StorageDomainId.Get() == nil {
		var ret int64
		return ret
	}

	return *o.StorageDomainId.Get()
}

// GetStorageDomainIdOk returns a tuple with the StorageDomainId field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UptieringTarget) GetStorageDomainIdOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return o.StorageDomainId.Get(), o.StorageDomainId.IsSet()
}

// SetStorageDomainId sets field value
func (o *UptieringTarget) SetStorageDomainId(v int64) {
	o.StorageDomainId.Set(&v)
}

func (o UptieringTarget) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o UptieringTarget) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if o.DowntieredDataLocations != nil {
		toSerialize["downtieredDataLocations"] = o.DowntieredDataLocations
	}
	toSerialize["storageDomainId"] = o.StorageDomainId.Get()
	return toSerialize, nil
}

func (o *UptieringTarget) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"storageDomainId",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varUptieringTarget := _UptieringTarget{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varUptieringTarget)

	if err != nil {
		return err
	}

	*o = UptieringTarget(varUptieringTarget)

	return err
}

type NullableUptieringTarget struct {
	value *UptieringTarget
	isSet bool
}

func (v NullableUptieringTarget) Get() *UptieringTarget {
	return v.value
}

func (v *NullableUptieringTarget) Set(val *UptieringTarget) {
	v.value = val
	v.isSet = true
}

func (v NullableUptieringTarget) IsSet() bool {
	return v.isSet
}

func (v *NullableUptieringTarget) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableUptieringTarget(val *UptieringTarget) *NullableUptieringTarget {
	return &NullableUptieringTarget{value: val, isSet: true}
}

func (v NullableUptieringTarget) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableUptieringTarget) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


