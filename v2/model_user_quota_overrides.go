/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the UserQuotaOverrides type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &UserQuotaOverrides{}

// UserQuotaOverrides Specifies a list of user quotas set on the View. These user quotas will override the default View user quota.
type UserQuotaOverrides struct {
	// Specifies the pagination cookie.
	Cookie NullableString `json:"cookie,omitempty"`
	// By default, the overrides specified in userQuotas is treated as delta and the existing overrides will be left untouched. Set this to true, if the existing overrides should be cleared before applying overrides specified in userQuotas.
	OverrideExistingPerUserQuotas NullableBool `json:"overrideExistingPerUserQuotas,omitempty"`
	// Array of UserQuota. Specifies the list of UserQuota for each user.
	UserQuotas []UserQuota `json:"userQuotas"`
}

type _UserQuotaOverrides UserQuotaOverrides

// NewUserQuotaOverrides instantiates a new UserQuotaOverrides object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewUserQuotaOverrides(userQuotas []UserQuota) *UserQuotaOverrides {
	this := UserQuotaOverrides{}
	this.UserQuotas = userQuotas
	return &this
}

// NewUserQuotaOverridesWithDefaults instantiates a new UserQuotaOverrides object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewUserQuotaOverridesWithDefaults() *UserQuotaOverrides {
	this := UserQuotaOverrides{}
	return &this
}

// GetCookie returns the Cookie field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UserQuotaOverrides) GetCookie() string {
	if o == nil || IsNil(o.Cookie.Get()) {
		var ret string
		return ret
	}
	return *o.Cookie.Get()
}

// GetCookieOk returns a tuple with the Cookie field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UserQuotaOverrides) GetCookieOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Cookie.Get(), o.Cookie.IsSet()
}

// HasCookie returns a boolean if a field has been set.
func (o *UserQuotaOverrides) HasCookie() bool {
	if o != nil && o.Cookie.IsSet() {
		return true
	}

	return false
}

// SetCookie gets a reference to the given NullableString and assigns it to the Cookie field.
func (o *UserQuotaOverrides) SetCookie(v string) {
	o.Cookie.Set(&v)
}
// SetCookieNil sets the value for Cookie to be an explicit nil
func (o *UserQuotaOverrides) SetCookieNil() {
	o.Cookie.Set(nil)
}

// UnsetCookie ensures that no value is present for Cookie, not even an explicit nil
func (o *UserQuotaOverrides) UnsetCookie() {
	o.Cookie.Unset()
}

// GetOverrideExistingPerUserQuotas returns the OverrideExistingPerUserQuotas field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *UserQuotaOverrides) GetOverrideExistingPerUserQuotas() bool {
	if o == nil || IsNil(o.OverrideExistingPerUserQuotas.Get()) {
		var ret bool
		return ret
	}
	return *o.OverrideExistingPerUserQuotas.Get()
}

// GetOverrideExistingPerUserQuotasOk returns a tuple with the OverrideExistingPerUserQuotas field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UserQuotaOverrides) GetOverrideExistingPerUserQuotasOk() (*bool, bool) {
	if o == nil {
		return nil, false
	}
	return o.OverrideExistingPerUserQuotas.Get(), o.OverrideExistingPerUserQuotas.IsSet()
}

// HasOverrideExistingPerUserQuotas returns a boolean if a field has been set.
func (o *UserQuotaOverrides) HasOverrideExistingPerUserQuotas() bool {
	if o != nil && o.OverrideExistingPerUserQuotas.IsSet() {
		return true
	}

	return false
}

// SetOverrideExistingPerUserQuotas gets a reference to the given NullableBool and assigns it to the OverrideExistingPerUserQuotas field.
func (o *UserQuotaOverrides) SetOverrideExistingPerUserQuotas(v bool) {
	o.OverrideExistingPerUserQuotas.Set(&v)
}
// SetOverrideExistingPerUserQuotasNil sets the value for OverrideExistingPerUserQuotas to be an explicit nil
func (o *UserQuotaOverrides) SetOverrideExistingPerUserQuotasNil() {
	o.OverrideExistingPerUserQuotas.Set(nil)
}

// UnsetOverrideExistingPerUserQuotas ensures that no value is present for OverrideExistingPerUserQuotas, not even an explicit nil
func (o *UserQuotaOverrides) UnsetOverrideExistingPerUserQuotas() {
	o.OverrideExistingPerUserQuotas.Unset()
}

// GetUserQuotas returns the UserQuotas field value
// If the value is explicit nil, the zero value for []UserQuota will be returned
func (o *UserQuotaOverrides) GetUserQuotas() []UserQuota {
	if o == nil {
		var ret []UserQuota
		return ret
	}

	return o.UserQuotas
}

// GetUserQuotasOk returns a tuple with the UserQuotas field value
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *UserQuotaOverrides) GetUserQuotasOk() ([]UserQuota, bool) {
	if o == nil || IsNil(o.UserQuotas) {
		return nil, false
	}
	return o.UserQuotas, true
}

// SetUserQuotas sets field value
func (o *UserQuotaOverrides) SetUserQuotas(v []UserQuota) {
	o.UserQuotas = v
}

func (o UserQuotaOverrides) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o UserQuotaOverrides) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if o.Cookie.IsSet() {
		toSerialize["cookie"] = o.Cookie.Get()
	}
	if o.OverrideExistingPerUserQuotas.IsSet() {
		toSerialize["overrideExistingPerUserQuotas"] = o.OverrideExistingPerUserQuotas.Get()
	}
	if o.UserQuotas != nil {
		toSerialize["userQuotas"] = o.UserQuotas
	}
	return toSerialize, nil
}

func (o *UserQuotaOverrides) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"userQuotas",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varUserQuotaOverrides := _UserQuotaOverrides{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varUserQuotaOverrides)

	if err != nil {
		return err
	}

	*o = UserQuotaOverrides(varUserQuotaOverrides)

	return err
}

type NullableUserQuotaOverrides struct {
	value *UserQuotaOverrides
	isSet bool
}

func (v NullableUserQuotaOverrides) Get() *UserQuotaOverrides {
	return v.value
}

func (v *NullableUserQuotaOverrides) Set(val *UserQuotaOverrides) {
	v.value = val
	v.isSet = true
}

func (v NullableUserQuotaOverrides) IsSet() bool {
	return v.isSet
}

func (v *NullableUserQuotaOverrides) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableUserQuotaOverrides(val *UserQuotaOverrides) *NullableUserQuotaOverrides {
	return &NullableUserQuotaOverrides{value: val, isSet: true}
}

func (v NullableUserQuotaOverrides) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableUserQuotaOverrides) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


