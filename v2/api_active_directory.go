/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ActiveDirectoryAPIService ActiveDirectoryAPI service
type ActiveDirectoryAPIService service

type ApiAddActiveDirectoryPrincipalsRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	body *[]AddActiveDirectoryPrincipalsParameters
}

func (r ApiAddActiveDirectoryPrincipalsRequest) Body(body []AddActiveDirectoryPrincipalsParameters) ApiAddActiveDirectoryPrincipalsRequest {
	r.body = &body
	return r
}

func (r ApiAddActiveDirectoryPrincipalsRequest) Execute() ([]AddedActiveDirectoryPrincipal, *http.Response, error) {
	return r.ApiService.AddActiveDirectoryPrincipalsExecute(r)
}

/*
AddActiveDirectoryPrincipals Add multiple groups or users on the Cohesity Cluster for the specified Active Directory principals. In addition, assign Cohesity roles to the users or groups to define their Cohesity privileges.

After a group or user has been added to a Cohesity Cluster, the referenced Active Directory principal can be used by the Cohesity Cluster. In addition, this operation maps Cohesity roles with a group or user and this mapping defines the privileges allowed on the Cohesity Cluster for the group or user. For example if an 'management' group is created on the Cohesity Cluster for the Active Directory 'management' principal group and is associated with the Cohesity 'View' role, all users in the referenced Active Directory 'management' principal group can log in to the Cohesity Dashboard but will only have view-only privileges. These users cannot create new Protection Jobs, Policies, Views, etc.
NOTE: Local Cohesity users and groups cannot be created by this operation. Local Cohesity users or groups do not have an associated Active Directory principals and are created directly in the default LOCAL domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddActiveDirectoryPrincipalsRequest
*/
func (a *ActiveDirectoryAPIService) AddActiveDirectoryPrincipals(ctx context.Context) ApiAddActiveDirectoryPrincipalsRequest {
	return ApiAddActiveDirectoryPrincipalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AddedActiveDirectoryPrincipal
func (a *ActiveDirectoryAPIService) AddActiveDirectoryPrincipalsExecute(r ApiAddActiveDirectoryPrincipalsRequest) ([]AddedActiveDirectoryPrincipal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AddedActiveDirectoryPrincipal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.AddActiveDirectoryPrincipals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active-directory-principals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateActiveDirectoryRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	body *CreateActiveDirectoryRequest
}

// Specifies the parameters to create an Active Directory.
func (r ApiCreateActiveDirectoryRequest) Body(body CreateActiveDirectoryRequest) ApiCreateActiveDirectoryRequest {
	r.body = &body
	return r
}

func (r ApiCreateActiveDirectoryRequest) Execute() (*ActiveDirectory, *http.Response, error) {
	return r.ApiService.CreateActiveDirectoryExecute(r)
}

/*
CreateActiveDirectory Create an Active Directory.

Create an Active Directory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateActiveDirectoryRequest
*/
func (a *ActiveDirectoryAPIService) CreateActiveDirectory(ctx context.Context) ApiCreateActiveDirectoryRequest {
	return ApiCreateActiveDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActiveDirectory
func (a *ActiveDirectoryAPIService) CreateActiveDirectoryExecute(r ApiCreateActiveDirectoryRequest) (*ActiveDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.CreateActiveDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active-directories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteActiveDirectoryRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	id int64
	activeDirectoryAdminUsername *string
	activeDirectoryAdminPassword *string
	forceRemove *bool
}

// Specifies the username of the Active Directory Admin.
func (r ApiDeleteActiveDirectoryRequest) ActiveDirectoryAdminUsername(activeDirectoryAdminUsername string) ApiDeleteActiveDirectoryRequest {
	r.activeDirectoryAdminUsername = &activeDirectoryAdminUsername
	return r
}

// Specifies the password of the Active Directory Admin.
func (r ApiDeleteActiveDirectoryRequest) ActiveDirectoryAdminPassword(activeDirectoryAdminPassword string) ApiDeleteActiveDirectoryRequest {
	r.activeDirectoryAdminPassword = &activeDirectoryAdminPassword
	return r
}

// To force delete the Active directory from cluster. This will skip all the checks that prevents cluster from leaving an AD domain.
func (r ApiDeleteActiveDirectoryRequest) ForceRemove(forceRemove bool) ApiDeleteActiveDirectoryRequest {
	r.forceRemove = &forceRemove
	return r
}

func (r ApiDeleteActiveDirectoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteActiveDirectoryExecute(r)
}

/*
DeleteActiveDirectory Delete an Active Directory.

Delete an Active Directory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies id of an Active Directory.
 @return ApiDeleteActiveDirectoryRequest
*/
func (a *ActiveDirectoryAPIService) DeleteActiveDirectory(ctx context.Context, id int64) ApiDeleteActiveDirectoryRequest {
	return ApiDeleteActiveDirectoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ActiveDirectoryAPIService) DeleteActiveDirectoryExecute(r ApiDeleteActiveDirectoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.DeleteActiveDirectory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active-directories/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.activeDirectoryAdminUsername == nil {
		return nil, reportError("activeDirectoryAdminUsername is required and must be specified")
	}
	if r.activeDirectoryAdminPassword == nil {
		return nil, reportError("activeDirectoryAdminPassword is required and must be specified")
	}

	if r.forceRemove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceRemove", r.forceRemove, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "activeDirectoryAdminUsername", r.activeDirectoryAdminUsername, "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "activeDirectoryAdminPassword", r.activeDirectoryAdminPassword, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetActiveDirectoryRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	domainNames *[]string
	ids *[]int64
	tenantIds *[]string
	includeTenants *bool
}

// Filter by a list of Active Directory domain names.
func (r ApiGetActiveDirectoryRequest) DomainNames(domainNames []string) ApiGetActiveDirectoryRequest {
	r.domainNames = &domainNames
	return r
}

// Filter by a list of Active Directory Ids.
func (r ApiGetActiveDirectoryRequest) Ids(ids []int64) ApiGetActiveDirectoryRequest {
	r.ids = &ids
	return r
}

// TenantIds contains ids of the tenants for which Active Directories are to be returned.
func (r ApiGetActiveDirectoryRequest) TenantIds(tenantIds []string) ApiGetActiveDirectoryRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Active Directories which were created by all tenants which the current user has permission to see. If false, then only Active Directories created by the current user will be returned.
func (r ApiGetActiveDirectoryRequest) IncludeTenants(includeTenants bool) ApiGetActiveDirectoryRequest {
	r.includeTenants = &includeTenants
	return r
}

func (r ApiGetActiveDirectoryRequest) Execute() (*ActiveDirectories, *http.Response, error) {
	return r.ApiService.GetActiveDirectoryExecute(r)
}

/*
GetActiveDirectory Get the list of Active Directories.

Get the list of Active Directories.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActiveDirectoryRequest
*/
func (a *ActiveDirectoryAPIService) GetActiveDirectory(ctx context.Context) ApiGetActiveDirectoryRequest {
	return ApiGetActiveDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActiveDirectories
func (a *ActiveDirectoryAPIService) GetActiveDirectoryExecute(r ApiGetActiveDirectoryRequest) (*ActiveDirectories, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveDirectories
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.GetActiveDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active-directories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.domainNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domainNames", r.domainNames, "csv")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveDirectoryByIdRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	id int64
	includeCentrifyZones *bool
	includeDomainControllers *bool
	includeSecurityPrincipals *bool
	prefix *string
	objectClass *[]string
}

// Specifies whether to include Centrify Zones of the Active Directory in response.
func (r ApiGetActiveDirectoryByIdRequest) IncludeCentrifyZones(includeCentrifyZones bool) ApiGetActiveDirectoryByIdRequest {
	r.includeCentrifyZones = &includeCentrifyZones
	return r
}

// Specifies whether to include Domain Controllers of the Active Directory in response.
func (r ApiGetActiveDirectoryByIdRequest) IncludeDomainControllers(includeDomainControllers bool) ApiGetActiveDirectoryByIdRequest {
	r.includeDomainControllers = &includeDomainControllers
	return r
}

// Specifies whether to include Security Principals of the Active Directory in response.
func (r ApiGetActiveDirectoryByIdRequest) IncludeSecurityPrincipals(includeSecurityPrincipals bool) ApiGetActiveDirectoryByIdRequest {
	r.includeSecurityPrincipals = &includeSecurityPrincipals
	return r
}

// Specifies a prefix, only security principals with name or sAMAccountName having this prefix (ignoring cases) will be returned. This field is appliciable and mandatory if &#39;includeSecurityPrincipals&#39; is set to true.
func (r ApiGetActiveDirectoryByIdRequest) Prefix(prefix string) ApiGetActiveDirectoryByIdRequest {
	r.prefix = &prefix
	return r
}

// Specifies a list of object classes, only security principals with object class in this list will be returned. This field is appliciable if &#39;includeSecurityPrincipals&#39; is set to true.
func (r ApiGetActiveDirectoryByIdRequest) ObjectClass(objectClass []string) ApiGetActiveDirectoryByIdRequest {
	r.objectClass = &objectClass
	return r
}

func (r ApiGetActiveDirectoryByIdRequest) Execute() (*ActiveDirectory, *http.Response, error) {
	return r.ApiService.GetActiveDirectoryByIdExecute(r)
}

/*
GetActiveDirectoryById Get an Active Directory by id.

Get an Active Directory by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies id of an Active Directory.
 @return ApiGetActiveDirectoryByIdRequest
*/
func (a *ActiveDirectoryAPIService) GetActiveDirectoryById(ctx context.Context, id int64) ApiGetActiveDirectoryByIdRequest {
	return ApiGetActiveDirectoryByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActiveDirectory
func (a *ActiveDirectoryAPIService) GetActiveDirectoryByIdExecute(r ApiGetActiveDirectoryByIdRequest) (*ActiveDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.GetActiveDirectoryById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active-directories/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeCentrifyZones != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCentrifyZones", r.includeCentrifyZones, "")
	}
	if r.includeDomainControllers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDomainControllers", r.includeDomainControllers, "")
	}
	if r.includeSecurityPrincipals != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSecurityPrincipals", r.includeSecurityPrincipals, "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "")
	}
	if r.objectClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectClass", r.objectClass, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveDirectoryPrincipalsRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	domainName *string
	sids *[]string
	searchTerm *string
	includeComputers *bool
	includeServiceAccounts *bool
	objectClass *string
}

// Specifies the domain name of the principals to search. If specified the principals in that domain are searched. Domain could be an Active Directory domain joined by the Cluster or any one of the trusted domains of the Active Directory domain or the LOCAL domain. If not specified, all the domains are searched.
func (r ApiGetActiveDirectoryPrincipalsRequest) DomainName(domainName string) ApiGetActiveDirectoryPrincipalsRequest {
	r.domainName = &domainName
	return r
}

// Optionally filter by a list of security identifiers (SIDs) found in the specified domain. Only principals matching the specified SIDs are returned. If specified, a &#39;searchTerm&#39; parameter should not be specified. Note: Duplicate SIDs will be ignored.
func (r ApiGetActiveDirectoryPrincipalsRequest) Sids(sids []string) ApiGetActiveDirectoryPrincipalsRequest {
	r.sids = &sids
	return r
}

// Optionally filter by matching a substring. Only principals with a name or sAMAccountName that matches part or all of the specified substring are returned. If specified, a &#39;sids&#39; parameter should not be specified
func (r ApiGetActiveDirectoryPrincipalsRequest) SearchTerm(searchTerm string) ApiGetActiveDirectoryPrincipalsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Specifies if Computer/GMSA accounts need to be included in this search.
func (r ApiGetActiveDirectoryPrincipalsRequest) IncludeComputers(includeComputers bool) ApiGetActiveDirectoryPrincipalsRequest {
	r.includeComputers = &includeComputers
	return r
}

// Specifies if service accounts should be included in the search result.
func (r ApiGetActiveDirectoryPrincipalsRequest) IncludeServiceAccounts(includeServiceAccounts bool) ApiGetActiveDirectoryPrincipalsRequest {
	r.includeServiceAccounts = &includeServiceAccounts
	return r
}

// Specifies the type of principal, a user or a group.
func (r ApiGetActiveDirectoryPrincipalsRequest) ObjectClass(objectClass string) ApiGetActiveDirectoryPrincipalsRequest {
	r.objectClass = &objectClass
	return r
}

func (r ApiGetActiveDirectoryPrincipalsRequest) Execute() (*ActiveDirectoryPrincipals, *http.Response, error) {
	return r.ApiService.GetActiveDirectoryPrincipalsExecute(r)
}

/*
GetActiveDirectoryPrincipals Get the list of user and group principals from the Active Directory that match the specified filter criteria.

Get the list of user and group principals from the Active Directory that match the specified filter criteria.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActiveDirectoryPrincipalsRequest
*/
func (a *ActiveDirectoryAPIService) GetActiveDirectoryPrincipals(ctx context.Context) ApiGetActiveDirectoryPrincipalsRequest {
	return ApiGetActiveDirectoryPrincipalsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActiveDirectoryPrincipals
func (a *ActiveDirectoryAPIService) GetActiveDirectoryPrincipalsExecute(r ApiGetActiveDirectoryPrincipalsRequest) (*ActiveDirectoryPrincipals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveDirectoryPrincipals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.GetActiveDirectoryPrincipals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active-directory-principals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.domainName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domainName", r.domainName, "")
	}
	if r.sids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sids", r.sids, "csv")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTerm", r.searchTerm, "")
	}
	if r.includeComputers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComputers", r.includeComputers, "")
	}
	if r.includeServiceAccounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeServiceAccounts", r.includeServiceAccounts, "")
	}
	if r.objectClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectClass", r.objectClass, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCentrifyZonesRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	domainName *string
}

// Specifies the FQDN of the domain name.
func (r ApiGetCentrifyZonesRequest) DomainName(domainName string) ApiGetCentrifyZonesRequest {
	r.domainName = &domainName
	return r
}

func (r ApiGetCentrifyZonesRequest) Execute() (*CentrifyZones, *http.Response, error) {
	return r.ApiService.GetCentrifyZonesExecute(r)
}

/*
GetCentrifyZones Get Centrify Zones.

Get Centrify zones for a specified domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCentrifyZonesRequest
*/
func (a *ActiveDirectoryAPIService) GetCentrifyZones(ctx context.Context) ApiGetCentrifyZonesRequest {
	return ApiGetCentrifyZonesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CentrifyZones
func (a *ActiveDirectoryAPIService) GetCentrifyZonesExecute(r ApiGetCentrifyZonesRequest) (*CentrifyZones, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CentrifyZones
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.GetCentrifyZones")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/centrify-zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.domainName == nil {
		return localVarReturnValue, nil, reportError("domainName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "domainName", r.domainName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDomainControllersRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	domainNames *[]string
	connectionId *int64
}

// Specifies a list of domain names.
func (r ApiGetDomainControllersRequest) DomainNames(domainNames []string) ApiGetDomainControllersRequest {
	r.domainNames = &domainNames
	return r
}

// Specifies the Id of the connection which the connector belongs to.
func (r ApiGetDomainControllersRequest) ConnectionId(connectionId int64) ApiGetDomainControllersRequest {
	r.connectionId = &connectionId
	return r
}

func (r ApiGetDomainControllersRequest) Execute() (*DomainControllersResponse, *http.Response, error) {
	return r.ApiService.GetDomainControllersExecute(r)
}

/*
GetDomainControllers Get Domain Controllers of specified domains.

Get Domain Controllers of specified domains.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDomainControllersRequest
*/
func (a *ActiveDirectoryAPIService) GetDomainControllers(ctx context.Context) ApiGetDomainControllersRequest {
	return ApiGetDomainControllersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DomainControllersResponse
func (a *ActiveDirectoryAPIService) GetDomainControllersExecute(r ApiGetDomainControllersRequest) (*DomainControllersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DomainControllersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.GetDomainControllers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/domain-controllers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.domainNames == nil {
		return localVarReturnValue, nil, reportError("domainNames is required and must be specified")
	}
	if len(*r.domainNames) < 1 {
		return localVarReturnValue, nil, reportError("domainNames must have at least 1 elements")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "domainNames", r.domainNames, "csv")
	if r.connectionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "connectionId", r.connectionId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrustedDomainsRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	domainName *string
}

// Specifies the FQDN of an Active directory domain.
func (r ApiGetTrustedDomainsRequest) DomainName(domainName string) ApiGetTrustedDomainsRequest {
	r.domainName = &domainName
	return r
}

func (r ApiGetTrustedDomainsRequest) Execute() (*TrustedDomainParams, *http.Response, error) {
	return r.ApiService.GetTrustedDomainsExecute(r)
}

/*
GetTrustedDomains Get Trusted Domains.

Get Trusted Domains for a specified domain.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTrustedDomainsRequest
*/
func (a *ActiveDirectoryAPIService) GetTrustedDomains(ctx context.Context) ApiGetTrustedDomainsRequest {
	return ApiGetTrustedDomainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrustedDomainParams
func (a *ActiveDirectoryAPIService) GetTrustedDomainsExecute(r ApiGetTrustedDomainsRequest) (*TrustedDomainParams, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrustedDomainParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.GetTrustedDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trusted-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.domainName == nil {
		return localVarReturnValue, nil, reportError("domainName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "domainName", r.domainName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTriggerTrustedDomainsDiscoveryRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	domainName *string
	rediscover *bool
}

// Specifies the FQDN of an Active directory domain.
func (r ApiTriggerTrustedDomainsDiscoveryRequest) DomainName(domainName string) ApiTriggerTrustedDomainsDiscoveryRequest {
	r.domainName = &domainName
	return r
}

// Specifies if trusted domains should be rediscovered.
func (r ApiTriggerTrustedDomainsDiscoveryRequest) Rediscover(rediscover bool) ApiTriggerTrustedDomainsDiscoveryRequest {
	r.rediscover = &rediscover
	return r
}

func (r ApiTriggerTrustedDomainsDiscoveryRequest) Execute() (*http.Response, error) {
	return r.ApiService.TriggerTrustedDomainsDiscoveryExecute(r)
}

/*
TriggerTrustedDomainsDiscovery Rediscover trusted domains.

Re-trigger the trusted domains of an Active Directory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTriggerTrustedDomainsDiscoveryRequest
*/
func (a *ActiveDirectoryAPIService) TriggerTrustedDomainsDiscovery(ctx context.Context) ApiTriggerTrustedDomainsDiscoveryRequest {
	return ApiTriggerTrustedDomainsDiscoveryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ActiveDirectoryAPIService) TriggerTrustedDomainsDiscoveryExecute(r ApiTriggerTrustedDomainsDiscoveryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.TriggerTrustedDomainsDiscovery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trusted-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.domainName == nil {
		return nil, reportError("domainName is required and must be specified")
	}
	if r.rediscover == nil {
		return nil, reportError("rediscover is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "domainName", r.domainName, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "rediscover", r.rediscover, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateActiveDirectoryRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	id int64
	body *UpdateActiveDirectoryRequest
}

// Request to update an Active Directory.
func (r ApiUpdateActiveDirectoryRequest) Body(body UpdateActiveDirectoryRequest) ApiUpdateActiveDirectoryRequest {
	r.body = &body
	return r
}

func (r ApiUpdateActiveDirectoryRequest) Execute() (*ActiveDirectory, *http.Response, error) {
	return r.ApiService.UpdateActiveDirectoryExecute(r)
}

/*
UpdateActiveDirectory Update an Active Directory.

Update an Active Directory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies id of an Active Directory.
 @return ApiUpdateActiveDirectoryRequest
*/
func (a *ActiveDirectoryAPIService) UpdateActiveDirectory(ctx context.Context, id int64) ApiUpdateActiveDirectoryRequest {
	return ApiUpdateActiveDirectoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ActiveDirectory
func (a *ActiveDirectoryAPIService) UpdateActiveDirectoryExecute(r ApiUpdateActiveDirectoryRequest) (*ActiveDirectory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveDirectory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.UpdateActiveDirectory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/active-directories/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTrustedDomainsRequest struct {
	ctx context.Context
	ApiService *ActiveDirectoryAPIService
	domainName *string
	body *TrustedDomainParams
}

// Specifies the FQDN of an Active directory domain.
func (r ApiUpdateTrustedDomainsRequest) DomainName(domainName string) ApiUpdateTrustedDomainsRequest {
	r.domainName = &domainName
	return r
}

// Specifies the trusted domains params.
func (r ApiUpdateTrustedDomainsRequest) Body(body TrustedDomainParams) ApiUpdateTrustedDomainsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateTrustedDomainsRequest) Execute() (*TrustedDomainParams, *http.Response, error) {
	return r.ApiService.UpdateTrustedDomainsExecute(r)
}

/*
UpdateTrustedDomains Update trusted domains.

To update trusted domains of an Active Directory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateTrustedDomainsRequest
*/
func (a *ActiveDirectoryAPIService) UpdateTrustedDomains(ctx context.Context) ApiUpdateTrustedDomainsRequest {
	return ApiUpdateTrustedDomainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrustedDomainParams
func (a *ActiveDirectoryAPIService) UpdateTrustedDomainsExecute(r ApiUpdateTrustedDomainsRequest) (*TrustedDomainParams, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrustedDomainParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveDirectoryAPIService.UpdateTrustedDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trusted-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.domainName == nil {
		return localVarReturnValue, nil, reportError("domainName is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "domainName", r.domainName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
