/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PolicyAPIService PolicyAPI service
type PolicyAPIService service

type ApiCreateProtectionPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	body *ProtectionPolicyRequest
}

// Request to create a Protection Policy.
func (r ApiCreateProtectionPolicyRequest) Body(body ProtectionPolicyRequest) ApiCreateProtectionPolicyRequest {
	r.body = &body
	return r
}

func (r ApiCreateProtectionPolicyRequest) Execute() (*ProtectionPolicyResponse, *http.Response, error) {
	return r.ApiService.CreateProtectionPolicyExecute(r)
}

/*
CreateProtectionPolicy Create a Protection Policy.

Create the Protection Policy and returns the newly created policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateProtectionPolicyRequest
*/
func (a *PolicyAPIService) CreateProtectionPolicy(ctx context.Context) ApiCreateProtectionPolicyRequest {
	return ApiCreateProtectionPolicyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectionPolicyResponse
func (a *PolicyAPIService) CreateProtectionPolicyExecute(r ApiCreateProtectionPolicyRequest) (*ProtectionPolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.CreateProtectionPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProtectionPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	id string
}

func (r ApiDeleteProtectionPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProtectionPolicyExecute(r)
}

/*
DeleteProtectionPolicy Delete a Protection Policy.

Deletes a Protection Policy based on given policy id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Policy to delete.
 @return ApiDeleteProtectionPolicyRequest
*/
func (a *PolicyAPIService) DeleteProtectionPolicy(ctx context.Context, id string) ApiDeleteProtectionPolicyRequest {
	return ApiDeleteProtectionPolicyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *PolicyAPIService) DeleteProtectionPolicyExecute(r ApiDeleteProtectionPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.DeleteProtectionPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPolicySummaryRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	id string
	requestInitiatorType *string
	includeAggregatedLastRunSummary *bool
	includeAggregatedRunsSummary *bool
	startTimeUsecs *int64
	endTimeUsecs *int64
	pageCount *int64
	paginationCookie *string
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetPolicySummaryRequest) RequestInitiatorType(requestInitiatorType string) ApiGetPolicySummaryRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Specifies whether to include summary of the last Protection Run of each Protection Source
func (r ApiGetPolicySummaryRequest) IncludeAggregatedLastRunSummary(includeAggregatedLastRunSummary bool) ApiGetPolicySummaryRequest {
	r.includeAggregatedLastRunSummary = &includeAggregatedLastRunSummary
	return r
}

// Specifies whether to include summary of all Protection Runs of the Protection Source or Protection Jobs. If this is set to true, then only the Protection Runs from the provided &#39;startTimeUsecs&#39; and &#39;endTimeUsecs&#39; are processed.
func (r ApiGetPolicySummaryRequest) IncludeAggregatedRunsSummary(includeAggregatedRunsSummary bool) ApiGetPolicySummaryRequest {
	r.includeAggregatedRunsSummary = &includeAggregatedRunsSummary
	return r
}

// Filter by a start time specified as a Unix epoch Timestamp (in microseconds). Only Job Runs that started after the specified time are included in the aggregated runs summary result.
func (r ApiGetPolicySummaryRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetPolicySummaryRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Filter by a end time specified as a Unix epoch Timestamp (in microseconds). Only Job Runs that completed before the specified time are included in the aggregated runs summary result.
func (r ApiGetPolicySummaryRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetPolicySummaryRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Specifies the limit of the number of Protection Sources or Protection Jobs to be returned as a part of the Protection Policy Summary.
func (r ApiGetPolicySummaryRequest) PageCount(pageCount int64) ApiGetPolicySummaryRequest {
	r.pageCount = &pageCount
	return r
}

// If set, i.e. there are more results to display, use this value to get the next set of results, by using this value in paginationCookie param for the next request to GetProtectionPolicySummary.
func (r ApiGetPolicySummaryRequest) PaginationCookie(paginationCookie string) ApiGetPolicySummaryRequest {
	r.paginationCookie = &paginationCookie
	return r
}

func (r ApiGetPolicySummaryRequest) Execute() (*PolicySummaryResponse, *http.Response, error) {
	return r.ApiService.GetPolicySummaryExecute(r)
}

/*
GetPolicySummary Get the protection policy summary

Fetch the summary for a given protection policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the policy whose summary should be retrieved. If this is not set, the API will return error.
 @return ApiGetPolicySummaryRequest
*/
func (a *PolicyAPIService) GetPolicySummary(ctx context.Context, id string) ApiGetPolicySummaryRequest {
	return ApiGetPolicySummaryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PolicySummaryResponse
func (a *PolicyAPIService) GetPolicySummaryExecute(r ApiGetPolicySummaryRequest) (*PolicySummaryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicySummaryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.GetPolicySummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policies/{id}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeAggregatedLastRunSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAggregatedLastRunSummary", r.includeAggregatedLastRunSummary, "")
	}
	if r.includeAggregatedRunsSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAggregatedRunsSummary", r.includeAggregatedRunsSummary, "")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.pageCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageCount", r.pageCount, "")
	}
	if r.paginationCookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginationCookie", r.paginationCookie, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyTemplateByIdRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	id string
}

func (r ApiGetPolicyTemplateByIdRequest) Execute() (*PolicyTemplateResponse, *http.Response, error) {
	return r.ApiService.GetPolicyTemplateByIdExecute(r)
}

/*
GetPolicyTemplateById List details about a single Policy Template.

Returns the Policy Template corresponding to the specified Policy Id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Policy Template to return.
 @return ApiGetPolicyTemplateByIdRequest
*/
func (a *PolicyAPIService) GetPolicyTemplateById(ctx context.Context, id string) ApiGetPolicyTemplateByIdRequest {
	return ApiGetPolicyTemplateByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PolicyTemplateResponse
func (a *PolicyAPIService) GetPolicyTemplateByIdExecute(r ApiGetPolicyTemplateByIdRequest) (*PolicyTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.GetPolicyTemplateById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policy-templates/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPolicyTemplatesRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	requestInitiatorType *string
	ids *[]string
	policyNames *[]string
	tenantIds *[]string
	includeTenants *bool
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetPolicyTemplatesRequest) RequestInitiatorType(requestInitiatorType string) ApiGetPolicyTemplatesRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Filter policies by a list of policy template ids.
func (r ApiGetPolicyTemplatesRequest) Ids(ids []string) ApiGetPolicyTemplatesRequest {
	r.ids = &ids
	return r
}

// Filter policies by a list of policy names.
func (r ApiGetPolicyTemplatesRequest) PolicyNames(policyNames []string) ApiGetPolicyTemplatesRequest {
	r.policyNames = &policyNames
	return r
}

// TenantIds contains ids of the organizations for which objects are to be returned.
func (r ApiGetPolicyTemplatesRequest) TenantIds(tenantIds []string) ApiGetPolicyTemplatesRequest {
	r.tenantIds = &tenantIds
	return r
}

// IncludeTenantPolicies specifies if objects of all the organizations under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiGetPolicyTemplatesRequest) IncludeTenants(includeTenants bool) ApiGetPolicyTemplatesRequest {
	r.includeTenants = &includeTenants
	return r
}

func (r ApiGetPolicyTemplatesRequest) Execute() (*PolicyTemplatesResponseWithPagination, *http.Response, error) {
	return r.ApiService.GetPolicyTemplatesExecute(r)
}

/*
GetPolicyTemplates List Policy Templates filtered by query parameters.

Returns the policy templates based on the filtering parameters. If no parameters are specified, then all the policy templates are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPolicyTemplatesRequest
*/
func (a *PolicyAPIService) GetPolicyTemplates(ctx context.Context) ApiGetPolicyTemplatesRequest {
	return ApiGetPolicyTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PolicyTemplatesResponseWithPagination
func (a *PolicyAPIService) GetPolicyTemplatesExecute(r ApiGetPolicyTemplatesRequest) (*PolicyTemplatesResponseWithPagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyTemplatesResponseWithPagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.GetPolicyTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policy-templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.policyNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyNames", r.policyNames, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionPoliciesRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	requestInitiatorType *string
	ids *[]string
	policyNames *[]string
	tenantIds *[]string
	includeTenants *bool
	types *[]string
	excludeLinkedPolicies *bool
	includeReplicatedPolicies *bool
	includeStats *bool
	vaultIds *[]int64
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectionPoliciesRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectionPoliciesRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Filter policies by a list of policy ids.
func (r ApiGetProtectionPoliciesRequest) Ids(ids []string) ApiGetProtectionPoliciesRequest {
	r.ids = &ids
	return r
}

// Filter policies by a list of policy names.
func (r ApiGetProtectionPoliciesRequest) PolicyNames(policyNames []string) ApiGetProtectionPoliciesRequest {
	r.policyNames = &policyNames
	return r
}

// TenantIds contains ids of the organizations for which objects are to be returned.
func (r ApiGetProtectionPoliciesRequest) TenantIds(tenantIds []string) ApiGetProtectionPoliciesRequest {
	r.tenantIds = &tenantIds
	return r
}

// IncludeTenantPolicies specifies if objects of all the organizations under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiGetProtectionPoliciesRequest) IncludeTenants(includeTenants bool) ApiGetProtectionPoliciesRequest {
	r.includeTenants = &includeTenants
	return r
}

// Types specifies the policy type of policies to be returned
func (r ApiGetProtectionPoliciesRequest) Types(types []string) ApiGetProtectionPoliciesRequest {
	r.types = &types
	return r
}

// If excludeLinkedPolicies is set to true then only local policies created on cluster will be returned. The result will exclude all linked policies created from policy templates.
func (r ApiGetProtectionPoliciesRequest) ExcludeLinkedPolicies(excludeLinkedPolicies bool) ApiGetProtectionPoliciesRequest {
	r.excludeLinkedPolicies = &excludeLinkedPolicies
	return r
}

// If includeReplicatedPolicies is set to true, then response will also contain replicated policies. By default, replication policies are not included in the response.
func (r ApiGetProtectionPoliciesRequest) IncludeReplicatedPolicies(includeReplicatedPolicies bool) ApiGetProtectionPoliciesRequest {
	r.includeReplicatedPolicies = &includeReplicatedPolicies
	return r
}

// If includeStats is set to true, then response will return number of protection groups and objects. By default, the protection stats are not included in the response.
func (r ApiGetProtectionPoliciesRequest) IncludeStats(includeStats bool) ApiGetProtectionPoliciesRequest {
	r.includeStats = &includeStats
	return r
}

// Filter by a list of Vault ids. Policies archiving to any of the specified vaults will be returned.
func (r ApiGetProtectionPoliciesRequest) VaultIds(vaultIds []int64) ApiGetProtectionPoliciesRequest {
	r.vaultIds = &vaultIds
	return r
}

func (r ApiGetProtectionPoliciesRequest) Execute() (*ProtectionPolicyResponseWithPagination, *http.Response, error) {
	return r.ApiService.GetProtectionPoliciesExecute(r)
}

/*
GetProtectionPolicies List Protection Policies based on provided filtering parameters.

Lists protection policies based on filtering query parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProtectionPoliciesRequest
*/
func (a *PolicyAPIService) GetProtectionPolicies(ctx context.Context) ApiGetProtectionPoliciesRequest {
	return ApiGetProtectionPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectionPolicyResponseWithPagination
func (a *PolicyAPIService) GetProtectionPoliciesExecute(r ApiGetProtectionPoliciesRequest) (*ProtectionPolicyResponseWithPagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionPolicyResponseWithPagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.GetProtectionPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.policyNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyNames", r.policyNames, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "csv")
	} else {
		var defaultValue []string = ["Regular"]
		r.types = &defaultValue
	}
	if r.excludeLinkedPolicies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeLinkedPolicies", r.excludeLinkedPolicies, "")
	}
	if r.includeReplicatedPolicies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeReplicatedPolicies", r.includeReplicatedPolicies, "")
	}
	if r.includeStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeStats", r.includeStats, "")
	}
	if r.vaultIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vaultIds", r.vaultIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionPolicyByIdRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	id string
	requestInitiatorType *string
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectionPolicyByIdRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectionPolicyByIdRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

func (r ApiGetProtectionPolicyByIdRequest) Execute() (*ProtectionPolicyResponse, *http.Response, error) {
	return r.ApiService.GetProtectionPolicyByIdExecute(r)
}

/*
GetProtectionPolicyById List details about a single Protection Policy.

Returns the Protection Policy details based on provided Policy Id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Policy to return.
 @return ApiGetProtectionPolicyByIdRequest
*/
func (a *PolicyAPIService) GetProtectionPolicyById(ctx context.Context, id string) ApiGetProtectionPolicyByIdRequest {
	return ApiGetProtectionPolicyByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectionPolicyResponse
func (a *PolicyAPIService) GetProtectionPolicyByIdExecute(r ApiGetProtectionPolicyByIdRequest) (*ProtectionPolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.GetProtectionPolicyById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProtectionPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyAPIService
	id string
	body *ProtectionPolicyRequest
}

// Request to update a Protection Policy.
func (r ApiUpdateProtectionPolicyRequest) Body(body ProtectionPolicyRequest) ApiUpdateProtectionPolicyRequest {
	r.body = &body
	return r
}

func (r ApiUpdateProtectionPolicyRequest) Execute() (*ProtectionPolicyResponse, *http.Response, error) {
	return r.ApiService.UpdateProtectionPolicyExecute(r)
}

/*
UpdateProtectionPolicy Update a Protection Policy.

Specifies the request to update the existing Protection Policy. On successful update, returns the updated policy object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Policy to update.
 @return ApiUpdateProtectionPolicyRequest
*/
func (a *PolicyAPIService) UpdateProtectionPolicy(ctx context.Context, id string) ApiUpdateProtectionPolicyRequest {
	return ApiUpdateProtectionPolicyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectionPolicyResponse
func (a *PolicyAPIService) UpdateProtectionPolicyExecute(r ApiUpdateProtectionPolicyRequest) (*ProtectionPolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyAPIService.UpdateProtectionPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
