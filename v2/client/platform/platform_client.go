// Code generated by go-swagger; DO NOT EDIT.

package platform

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new platform API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new platform API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new platform API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for platform API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeMultipartFormData sets the Content-Type header to "multipart/form-data".
func WithContentTypeMultipartFormData(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"multipart/form-data"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	AddHosts(params *AddHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddHostsCreated, error)

	AddRemoteDisk(params *AddRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddRemoteDiskCreated, error)

	ClearSMTPConfiguration(params *ClearSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClearSMTPConfigurationNoContent, error)

	CreateCluster(params *CreateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterCreated, error)

	CreateClusterVlan(params *CreateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterVlanCreated, error)

	CreateInterfaceGroup(params *CreateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInterfaceGroupCreated, error)

	CreateRacks(params *CreateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRacksCreated, error)

	DeleteAMQPTargetConfig(params *DeleteAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAMQPTargetConfigNoContent, error)

	DeleteClusterPackage(params *DeleteClusterPackageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterPackageAccepted, error)

	DeleteClusterVlan(params *DeleteClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterVlanNoContent, error)

	DeleteHosts(params *DeleteHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteHostsNoContent, error)

	DeleteInterfaceGroup(params *DeleteInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteInterfaceGroupNoContent, error)

	DeleteRackByID(params *DeleteRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRackByIDNoContent, error)

	DeleteRacks(params *DeleteRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRacksNoContent, error)

	DiscoverDisks(params *DiscoverDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiscoverDisksOK, error)

	DiskIdentify(params *DiskIdentifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskIdentifyOK, error)

	DisksAssimilate(params *DisksAssimilateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisksAssimilateOK, error)

	ExpandClusterNodes(params *ExpandClusterNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExpandClusterNodesAccepted, error)

	GetAMQPTargetConfig(params *GetAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAMQPTargetConfigOK, error)

	GetChassis(params *GetChassisParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisOK, error)

	GetChassisByID(params *GetChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisByIDOK, error)

	GetCluster(params *GetClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOK, error)

	GetClusterLocalDomainSID(params *GetClusterLocalDomainSIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterLocalDomainSIDOK, error)

	GetClusterPackages(params *GetClusterPackagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPackagesOK, error)

	GetClusterState(params *GetClusterStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStateOK, error)

	GetClusterVlans(params *GetClusterVlansParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterVlansOK, error)

	GetInterfaceGroups(params *GetInterfaceGroupsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetInterfaceGroupsOK, error)

	GetInterfaces(params *GetInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetInterfacesOK, error)

	GetIpmiLanConfig(params *GetIpmiLanConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiLanConfigOK, error)

	GetIpmiUsers(params *GetIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiUsersOK, error)

	GetIsDMaaSCluster(params *GetIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIsDMaaSClusterOK, error)

	GetNetworkInterfaces(params *GetNetworkInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNetworkInterfacesOK, error)

	GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error)

	GetRackByID(params *GetRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRackByIDOK, error)

	GetRacks(params *GetRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRacksOK, error)

	GetRemoteDisks(params *GetRemoteDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRemoteDisksOK, error)

	GetSMTPConfiguration(params *GetSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSMTPConfigurationOK, error)

	GetSupportChannelConfig(params *GetSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSupportChannelConfigOK, error)

	IdentifyNode(params *IdentifyNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*IdentifyNodeOK, error)

	ImportCrlFile(params *ImportCrlFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImportCrlFileNoContent, error)

	ListDisks(params *ListDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDisksOK, error)

	ListFeatureFlag(params *ListFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFeatureFlagOK, error)

	ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error)

	ListHosts(params *ListHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListHostsOK, error)

	MarkBaseosUpgrade(params *MarkBaseosUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkBaseosUpgradeOK, error)

	MarkDiskRemoval(params *MarkDiskRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkDiskRemovalOK, error)

	MarkNodeRemoval(params *MarkNodeRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeRemovalOK, error)

	NodeInformation(params *NodeInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeInformationOK, error)

	PublicKeyRequest(params *PublicKeyRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublicKeyRequestOK, error)

	RemoveRemoteDisk(params *RemoveRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveRemoteDiskNoContent, error)

	SetNodePower(params *SetNodePowerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetNodePowerNoContent, error)

	UpdateAMQPTargetConfig(params *UpdateAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAMQPTargetConfigOK, error)

	UpdateAirgapConfig(params *UpdateAirgapConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAirgapConfigAccepted, error)

	UpdateChassisByID(params *UpdateChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChassisByIDOK, error)

	UpdateCluster(params *UpdateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterOK, error)

	UpdateClusterVlan(params *UpdateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterVlanOK, error)

	UpdateFeatureFlag(params *UpdateFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateFeatureFlagOK, error)

	UpdateHosts(params *UpdateHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateHostsOK, error)

	UpdateInterface(params *UpdateInterfaceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateInterfaceOK, error)

	UpdateInterfaceGroup(params *UpdateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateInterfaceGroupOK, error)

	UpdateIpmiLanConfig(params *UpdateIpmiLanConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIpmiLanConfigOK, error)

	UpdateIpmiUsers(params *UpdateIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIpmiUsersOK, error)

	UpdateIsDMaaSCluster(params *UpdateIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIsDMaaSClusterOK, error)

	UpdateRackByID(params *UpdateRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRackByIDOK, error)

	UpdateRacks(params *UpdateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRacksOK, error)

	UpdateSMTPConfiguration(params *UpdateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSMTPConfigurationOK, error)

	UpdateSupportChannelConfig(params *UpdateSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSupportChannelConfigOK, error)

	UpgradeCheckGetResults(params *UpgradeCheckGetResultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckGetResultsOK, error)

	UpgradeCheckRunTests(params *UpgradeCheckRunTestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckRunTestsOK, error)

	UpgradeClusterSoftware(params *UpgradeClusterSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeClusterSoftwareAccepted, error)

	UploadPackageByURL(params *UploadPackageByURLParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadPackageByURLAccepted, error)

	ValidateSMTPConfiguration(params *ValidateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ValidateSMTPConfigurationNoContent, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AddHosts creates cluster host mappings

Sends a request to add one or more new entries to the Cluster's /etc/hosts
*/
func (a *Client) AddHosts(params *AddHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddHostsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "AddHosts",
		Method:             "POST",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddHostsCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AddHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
AddRemoteDisk adds remote disk

Add a remote disk.
*/
func (a *Client) AddRemoteDisk(params *AddRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddRemoteDiskCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddRemoteDiskParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "AddRemoteDisk",
		Method:             "POST",
		PathPattern:        "/disks/remote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &AddRemoteDiskReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AddRemoteDiskCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*AddRemoteDiskDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ClearSMTPConfiguration clears SMTP configuration

Clear cluster SMTP configuration.
*/
func (a *Client) ClearSMTPConfiguration(params *ClearSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ClearSMTPConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClearSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ClearSMTPConfiguration",
		Method:             "DELETE",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ClearSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClearSMTPConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ClearSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateCluster creates a cluster

Create a cluster with given network and cluster configuration.
*/
func (a *Client) CreateCluster(params *CreateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateCluster",
		Method:             "POST",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClusterCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateClusterVlan creates vlan

Create a vlan on the cluster.
*/
func (a *Client) CreateClusterVlan(params *CreateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateClusterVlanCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterVlanParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateClusterVlan",
		Method:             "POST",
		PathPattern:        "/network/vlans",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterVlanReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateClusterVlanCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateClusterVlanDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateInterfaceGroup creates interface group

Create an interface group on the cluster.
*/
func (a *Client) CreateInterfaceGroup(params *CreateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateInterfaceGroupCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateInterfaceGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateInterfaceGroup",
		Method:             "POST",
		PathPattern:        "/network/interface-groups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateInterfaceGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateInterfaceGroupCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateInterfaceGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
CreateRacks creates racks

Create list of racks and optionally also assign list of chassis to each rack
*/
func (a *Client) CreateRacks(params *CreateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateRacksCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "CreateRacks",
		Method:             "POST",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CreateRacksCreated)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*CreateRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteAMQPTargetConfig deletes a m q p target config

Delete AMQP target config on the cluster.
*/
func (a *Client) DeleteAMQPTargetConfig(params *DeleteAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteAMQPTargetConfigNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteAMQPTargetConfig",
		Method:             "DELETE",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteAMQPTargetConfigNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteClusterPackage deletes package

Delete a software package on the cluster.
*/
func (a *Client) DeleteClusterPackage(params *DeleteClusterPackageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterPackageAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterPackageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteClusterPackage",
		Method:             "DELETE",
		PathPattern:        "/clusters/packages/{versionName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterPackageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteClusterPackageAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteClusterPackageDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteClusterVlan deletes vlan

Delete a vlan on the cluster.
*/
func (a *Client) DeleteClusterVlan(params *DeleteClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteClusterVlanNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterVlanParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteClusterVlan",
		Method:             "DELETE",
		PathPattern:        "/network/vlans/{interfaceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterVlanReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteClusterVlanNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteClusterVlanDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteHosts deletes multiple host mappings within the cluster

Delete one or more Host Mappings within the cluster.
*/
func (a *Client) DeleteHosts(params *DeleteHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteHostsNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteHosts",
		Method:             "POST",
		PathPattern:        "/clusters/host-mappings/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteHostsNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteInterfaceGroup deletes interface group

Delete an interface group on the cluster.
*/
func (a *Client) DeleteInterfaceGroup(params *DeleteInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteInterfaceGroupNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteInterfaceGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteInterfaceGroup",
		Method:             "DELETE",
		PathPattern:        "/network/interface-groups/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteInterfaceGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteInterfaceGroupNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteInterfaceGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRackByID deletes a rack by id

Delete a given rack by id.
*/
func (a *Client) DeleteRackByID(params *DeleteRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRackByIDNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRackByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRackById",
		Method:             "DELETE",
		PathPattern:        "/racks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRackByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteRackByIDNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRackByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DeleteRacks deletes all the racks

Delete all the racks.
*/
func (a *Client) DeleteRacks(params *DeleteRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteRacksNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DeleteRacks",
		Method:             "DELETE",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteRacksNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DeleteRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DiscoverDisks discovers new disks

Discover disks that are ready for activation
*/
func (a *Client) DiscoverDisks(params *DiscoverDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiscoverDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiscoverDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DiscoverDisks",
		Method:             "GET",
		PathPattern:        "/disks/discover",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiscoverDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiscoverDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiscoverDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DiskIdentify identifies a disk

Turn on/off led light of a disk.
*/
func (a *Client) DiskIdentify(params *DiskIdentifyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DiskIdentifyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDiskIdentifyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DiskIdentify",
		Method:             "POST",
		PathPattern:        "/disks/identify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DiskIdentifyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DiskIdentifyOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DiskIdentifyDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
DisksAssimilate assimilates disks

Assimilate list of disks from one or more nodes of cluster.
*/
func (a *Client) DisksAssimilate(params *DisksAssimilateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DisksAssimilateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisksAssimilateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "DisksAssimilate",
		Method:             "POST",
		PathPattern:        "/disks/assimilate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DisksAssimilateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DisksAssimilateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*DisksAssimilateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ExpandClusterNodes expands the cluster

Expand the cluster by adding new nodes.
*/
func (a *Client) ExpandClusterNodes(params *ExpandClusterNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ExpandClusterNodesAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExpandClusterNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ExpandClusterNodes",
		Method:             "POST",
		PathPattern:        "/clusters/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ExpandClusterNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ExpandClusterNodesAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ExpandClusterNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetAMQPTargetConfig gets a m q p target config

Fetch AMQP target config on the cluster.
*/
func (a *Client) GetAMQPTargetConfig(params *GetAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetAMQPTargetConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAMQPTargetConfig",
		Method:             "GET",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAMQPTargetConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetChassis gets list of chassis

Get list of all chassis info that are part of cluster.
*/
func (a *Client) GetChassis(params *GetChassisParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetChassisParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetChassis",
		Method:             "GET",
		PathPattern:        "/chassis",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetChassisReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetChassisOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetChassisDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetChassisByID gets a chassis by chassis id

Get a chassis info by id.
*/
func (a *Client) GetChassisByID(params *GetChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChassisByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetChassisByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetChassisById",
		Method:             "GET",
		PathPattern:        "/chassis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetChassisByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetChassisByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetChassisByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetCluster retrieves cluster configuration

Retrieve some summary information about the Cluster Configuration.
*/
func (a *Client) GetCluster(params *GetClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetCluster",
		Method:             "GET",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterLocalDomainSID gets cluster local domain s ID

Fetch SID of cluster local domain.
*/
func (a *Client) GetClusterLocalDomainSID(params *GetClusterLocalDomainSIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterLocalDomainSIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterLocalDomainSIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterLocalDomainSID",
		Method:             "GET",
		PathPattern:        "/clusters/local-domain-sid",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterLocalDomainSIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterLocalDomainSIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterLocalDomainSIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterPackages gets packages

Get software packages on the cluster.
*/
func (a *Client) GetClusterPackages(params *GetClusterPackagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterPackagesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterPackagesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterPackages",
		Method:             "GET",
		PathPattern:        "/clusters/packages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterPackagesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterPackagesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterPackagesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterState gets cluster state

Get the current state of the cluster.
*/
func (a *Client) GetClusterState(params *GetClusterStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterStateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterState",
		Method:             "GET",
		PathPattern:        "/clusters/state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterStateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterStateDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetClusterVlans gets vlans

Get vlans on the cluster.
*/
func (a *Client) GetClusterVlans(params *GetClusterVlansParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetClusterVlansOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterVlansParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetClusterVlans",
		Method:             "GET",
		PathPattern:        "/network/vlans",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterVlansReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetClusterVlansOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetClusterVlansDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetInterfaceGroups gets interface groups

Get a list of interface groups configured on the cluster.
*/
func (a *Client) GetInterfaceGroups(params *GetInterfaceGroupsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetInterfaceGroupsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInterfaceGroupsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetInterfaceGroups",
		Method:             "GET",
		PathPattern:        "/network/interface-groups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInterfaceGroupsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetInterfaceGroupsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetInterfaceGroupsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetInterfaces gets interfaces

Get interfaces on a cluster or free node.
*/
func (a *Client) GetInterfaces(params *GetInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetInterfacesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetInterfacesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetInterfaces",
		Method:             "GET",
		PathPattern:        "/network/interfaces",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetInterfacesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetInterfacesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetInterfacesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiLanConfig gets IP m i l a n configuration

Get cluster and node level IPMI LAN configuration.
*/
func (a *Client) GetIpmiLanConfig(params *GetIpmiLanConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiLanConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiLanConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiLanConfig",
		Method:             "GET",
		PathPattern:        "/network/ipmi/lan",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiLanConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiLanConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiLanConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIpmiUsers gets IP m i users

Get cluster and node level IPMI users.
*/
func (a *Client) GetIpmiUsers(params *GetIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIpmiUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIpmiUsersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIpmiUsers",
		Method:             "GET",
		PathPattern:        "/network/ipmi/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIpmiUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIpmiUsersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIpmiUsersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetIsDMaaSCluster gets whether the cluster is a d maa s cluster

Get whether the cluster is a DMaaS cluster.
*/
func (a *Client) GetIsDMaaSCluster(params *GetIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetIsDMaaSClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetIsDMaaSClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetIsDMaaSCluster",
		Method:             "GET",
		PathPattern:        "/clusters/is-dmaas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetIsDMaaSClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetIsDMaaSClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetIsDMaaSClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNetworkInterfaces gets list of interfaces

Get a list of interfaces present on the node or cluster.
*/
func (a *Client) GetNetworkInterfaces(params *GetNetworkInterfacesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNetworkInterfacesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNetworkInterfacesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNetworkInterfaces",
		Method:             "GET",
		PathPattern:        "/network-interfaces",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNetworkInterfacesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNetworkInterfacesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNetworkInterfacesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetNodes lists nodes of the cluster

Gets the list of Nodes in a cluster.
*/
func (a *Client) GetNodes(params *GetNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodes",
		Method:             "GET",
		PathPattern:        "/clusters/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRackByID gets a rack by rack id

Get a rack info by id.
*/
func (a *Client) GetRackByID(params *GetRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRackByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRackByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRackById",
		Method:             "GET",
		PathPattern:        "/racks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRackByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRackByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRackByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRacks gets list of racks

Get list of all racks that are part of cluster.
*/
func (a *Client) GetRacks(params *GetRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRacksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRacks",
		Method:             "GET",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRacksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetRemoteDisks gets remote disks

Get remote disks.
*/
func (a *Client) GetRemoteDisks(params *GetRemoteDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetRemoteDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRemoteDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetRemoteDisks",
		Method:             "GET",
		PathPattern:        "/disks/remote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRemoteDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetRemoteDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetRemoteDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSMTPConfiguration gets SMTP configuration

Get the SMTP cluster configuration.
*/
func (a *Client) GetSMTPConfiguration(params *GetSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSMTPConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSMTPConfiguration",
		Method:             "GET",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSMTPConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
GetSupportChannelConfig gets support channel configuration

Get support channel configuration.
*/
func (a *Client) GetSupportChannelConfig(params *GetSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSupportChannelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSupportChannelConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetSupportChannelConfig",
		Method:             "GET",
		PathPattern:        "/support-channel-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSupportChannelConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetSupportChannelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*GetSupportChannelConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
IdentifyNode identifies node

Turn on/off LED light of a node to identify.
*/
func (a *Client) IdentifyNode(params *IdentifyNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*IdentifyNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewIdentifyNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Identify node",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/identify",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &IdentifyNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*IdentifyNodeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*IdentifyNodeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ImportCrlFile imports crl file

Import a Crl file into the cluster.
*/
func (a *Client) ImportCrlFile(params *ImportCrlFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ImportCrlFileNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportCrlFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ImportCrlFile",
		Method:             "PUT",
		PathPattern:        "/clusters/import-crl-file",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ImportCrlFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ImportCrlFileNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ImportCrlFileDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListDisks gets list of disks

Get list of local disks.
*/
func (a *Client) ListDisks(params *ListDisksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListDisksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDisksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListDisks",
		Method:             "GET",
		PathPattern:        "/disks/local",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListDisksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListDisksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListDisksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListFeatureFlag gets feature flag overrides list

Get the list of feature flag overrides defined on cluster.
*/
func (a *Client) ListFeatureFlag(params *ListFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFeatureFlagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListFeatureFlagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListFeatureFlag",
		Method:             "GET",
		PathPattern:        "/clusters/feature-flag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListFeatureFlagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListFeatureFlagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListFeatureFlagDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListFreeNodes lists the free cohesity nodes present on a network

Sends a request to any Node to list all of the free Nodes that are present on the network.
*/
func (a *Client) ListFreeNodes(params *ListFreeNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFreeNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListFreeNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListFreeNodes",
		Method:             "GET",
		PathPattern:        "/clusters/nodes/free",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListFreeNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListFreeNodesOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListFreeNodesDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ListHosts lists host mappings

Lists the host mappings in /etc/hosts of the nodes in a cluster.
*/
func (a *Client) ListHosts(params *ListHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListHostsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ListHosts",
		Method:             "GET",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ListHostsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ListHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkBaseosUpgrade sets clears the base o s upgrade cluster operation

Sets/clears the BaseOS upgrade cluster operation.
*/
func (a *Client) MarkBaseosUpgrade(params *MarkBaseosUpgradeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkBaseosUpgradeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkBaseosUpgradeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkBaseosUpgrade",
		Method:             "PUT",
		PathPattern:        "/clusters/baseos-upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkBaseosUpgradeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkBaseosUpgradeOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkBaseosUpgradeDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkDiskRemoval marks disk for removal

Mark disk for removal or cancel removal if a disk is already marked for removal.
*/
func (a *Client) MarkDiskRemoval(params *MarkDiskRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkDiskRemovalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkDiskRemovalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkDiskRemoval",
		Method:             "POST",
		PathPattern:        "/disks/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkDiskRemovalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkDiskRemovalOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkDiskRemovalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
MarkNodeRemoval marks node for removal

Mark node for removal or Cancel if a node is already marked for removal.
*/
func (a *Client) MarkNodeRemoval(params *MarkNodeRemovalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MarkNodeRemovalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMarkNodeRemovalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "MarkNodeRemoval",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &MarkNodeRemovalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MarkNodeRemovalOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*MarkNodeRemovalDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
NodeInformation fetches node general information

Fetch general information about the node to which the request is sent to.
*/
func (a *Client) NodeInformation(params *NodeInformationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*NodeInformationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeInformationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "Node Information",
		Method:             "GET",
		PathPattern:        "/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &NodeInformationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeInformationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*NodeInformationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
PublicKeyRequest gets the SSH public key

Get the SSH public key corresponding to the private key used by workloads. For example, users may specify multiple scripts which are supposed to be executed on a remote machine at different progress states of a protection group run (for instance - running a script before the run starts and another after the run completes). The public key returned as part of this response should be added on the remote server where the script is to be executed as there is a specific private key used by the workload for remote login.
*/
func (a *Client) PublicKeyRequest(params *PublicKeyRequestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PublicKeyRequestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicKeyRequestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PublicKeyRequest",
		Method:             "POST",
		PathPattern:        "/clusters/ssh-public-key",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PublicKeyRequestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PublicKeyRequestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*PublicKeyRequestDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
RemoveRemoteDisk removes remote disk

Remove a remote disk.
*/
func (a *Client) RemoveRemoteDisk(params *RemoveRemoteDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveRemoteDiskNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoveRemoteDiskParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "RemoveRemoteDisk",
		Method:             "DELETE",
		PathPattern:        "/disks/remote/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RemoveRemoteDiskReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoveRemoteDiskNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*RemoveRemoteDiskDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
SetNodePower reboots or shutdown nodes in cluster

Reboot or shutdown nodes in cluster.
*/
func (a *Client) SetNodePower(params *SetNodePowerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SetNodePowerNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetNodePowerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "SetNodePower",
		Method:             "POST",
		PathPattern:        "/node-power",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetNodePowerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetNodePowerNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*SetNodePowerDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateAMQPTargetConfig updates a m q p target config

Updates AMQP target config on the cluster.
*/
func (a *Client) UpdateAMQPTargetConfig(params *UpdateAMQPTargetConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAMQPTargetConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAMQPTargetConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateAMQPTargetConfig",
		Method:             "PUT",
		PathPattern:        "/clusters/amqp-target-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAMQPTargetConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAMQPTargetConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateAMQPTargetConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateAirgapConfig updates airgap config

Enable or Disable Airgap on the cluster.
*/
func (a *Client) UpdateAirgapConfig(params *UpdateAirgapConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateAirgapConfigAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAirgapConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateAirgapConfig",
		Method:             "PUT",
		PathPattern:        "/clusters/airgap",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateAirgapConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateAirgapConfigAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateAirgapConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateChassisByID updates a chassis by chassis id

Update selected properties of chassis info by id.
*/
func (a *Client) UpdateChassisByID(params *UpdateChassisByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChassisByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateChassisByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateChassisById",
		Method:             "PATCH",
		PathPattern:        "/chassis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateChassisByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateChassisByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateChassisByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateCluster updates a cluster

Update the Cluster with the given configuration.
*/
func (a *Client) UpdateCluster(params *UpdateClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateCluster",
		Method:             "PUT",
		PathPattern:        "/clusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateClusterVlan updates vlan

Update a vlan on the cluster.
*/
func (a *Client) UpdateClusterVlan(params *UpdateClusterVlanParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateClusterVlanOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterVlanParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateClusterVlan",
		Method:             "PUT",
		PathPattern:        "/network/vlans/{interfaceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterVlanReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateClusterVlanOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateClusterVlanDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateFeatureFlag updates feature flag override status

Update a feature flag override status to cluster.
*/
func (a *Client) UpdateFeatureFlag(params *UpdateFeatureFlagParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateFeatureFlagOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateFeatureFlagParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateFeatureFlag",
		Method:             "PUT",
		PathPattern:        "/clusters/feature-flag",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateFeatureFlagReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateFeatureFlagOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateFeatureFlagDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateHosts updates host mappings

Updates Host Mapping on the Cluster.
*/
func (a *Client) UpdateHosts(params *UpdateHostsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateHostsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateHostsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateHosts",
		Method:             "PUT",
		PathPattern:        "/clusters/host-mappings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateHostsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateHostsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateHostsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateInterface updates interface

Update network interface on a free node.
*/
func (a *Client) UpdateInterface(params *UpdateInterfaceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateInterfaceOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateInterfaceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateInterface",
		Method:             "PUT",
		PathPattern:        "/network/interfaces/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateInterfaceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateInterfaceOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateInterfaceDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateInterfaceGroup updates interface group

Update an interface group on the cluster.
*/
func (a *Client) UpdateInterfaceGroup(params *UpdateInterfaceGroupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateInterfaceGroupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateInterfaceGroupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateInterfaceGroup",
		Method:             "PUT",
		PathPattern:        "/network/interface-groups/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateInterfaceGroupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateInterfaceGroupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateInterfaceGroupDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateIpmiLanConfig updates IP m i l a n configuration

Update cluster and node level IPMI LAN configuration.
*/
func (a *Client) UpdateIpmiLanConfig(params *UpdateIpmiLanConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIpmiLanConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIpmiLanConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateIpmiLanConfig",
		Method:             "PATCH",
		PathPattern:        "/network/ipmi/lan",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIpmiLanConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIpmiLanConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateIpmiLanConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateIpmiUsers updates IP m i users

Update cluster and node level IPMI users.
*/
func (a *Client) UpdateIpmiUsers(params *UpdateIpmiUsersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIpmiUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIpmiUsersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateIpmiUsers",
		Method:             "PATCH",
		PathPattern:        "/network/ipmi/users",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIpmiUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIpmiUsersOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateIpmiUsersDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateIsDMaaSCluster updates whether the cluster is a d maa s cluster

Update whether the cluster is a DMaaS cluster.
*/
func (a *Client) UpdateIsDMaaSCluster(params *UpdateIsDMaaSClusterParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateIsDMaaSClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateIsDMaaSClusterParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateIsDMaaSCluster",
		Method:             "PUT",
		PathPattern:        "/clusters/is-dmaas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateIsDMaaSClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateIsDMaaSClusterOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateIsDMaaSClusterDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRackByID Update selected properties of a rack given by id.
*/
func (a *Client) UpdateRackByID(params *UpdateRackByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRackByIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRackByIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRackById",
		Method:             "PATCH",
		PathPattern:        "/racks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateRackByIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRackByIDOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRackByIDDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateRacks updates racks

Updates list of racks with name, chassis list or/and location
*/
func (a *Client) UpdateRacks(params *UpdateRacksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateRacksOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateRacksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateRacks",
		Method:             "PATCH",
		PathPattern:        "/racks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateRacksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateRacksOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateRacksDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateSMTPConfiguration updates SMTP configuration

Update SMTP configuration.
*/
func (a *Client) UpdateSMTPConfiguration(params *UpdateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSMTPConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateSMTPConfiguration",
		Method:             "PUT",
		PathPattern:        "/clusters/smtp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSMTPConfigurationOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpdateSupportChannelConfig updates support channel configuration

Update support channel configuration.
*/
func (a *Client) UpdateSupportChannelConfig(params *UpdateSupportChannelConfigParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateSupportChannelConfigOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSupportChannelConfigParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpdateSupportChannelConfig",
		Method:             "PUT",
		PathPattern:        "/support-channel-config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSupportChannelConfigReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpdateSupportChannelConfigOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpdateSupportChannelConfigDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeCheckGetResults gets upgrade checks results

Get upgrade checks results.
*/
func (a *Client) UpgradeCheckGetResults(params *UpgradeCheckGetResultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckGetResultsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeCheckGetResultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeCheckGetResults",
		Method:             "GET",
		PathPattern:        "/cluster/upgrade-checks/{testRunInstanceId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeCheckGetResultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeCheckGetResultsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeCheckGetResultsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeCheckRunTests runs upgrade checks on cluster

Run upgrade checks on cluster.
*/
func (a *Client) UpgradeCheckRunTests(params *UpgradeCheckRunTestsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeCheckRunTestsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeCheckRunTestsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeCheckRunTests",
		Method:             "PUT",
		PathPattern:        "/cluster/upgrade-checks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeCheckRunTestsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeCheckRunTestsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeCheckRunTestsDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UpgradeClusterSoftware upgrades cluster

Upgrade the software on the cluster.
*/
func (a *Client) UpgradeClusterSoftware(params *UpgradeClusterSoftwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpgradeClusterSoftwareAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpgradeClusterSoftwareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UpgradeClusterSoftware",
		Method:             "PUT",
		PathPattern:        "/clusters/upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpgradeClusterSoftwareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UpgradeClusterSoftwareAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UpgradeClusterSoftwareDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
UploadPackageByURL uploads package by URL

Upload a package to the cluster by providing the URL where the package is hosted.
*/
func (a *Client) UploadPackageByURL(params *UploadPackageByURLParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UploadPackageByURLAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadPackageByURLParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "UploadPackageByUrl",
		Method:             "POST",
		PathPattern:        "/clusters/packages/url",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UploadPackageByURLReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UploadPackageByURLAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*UploadPackageByURLDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

/*
ValidateSMTPConfiguration validates SMTP configuration

Validate SMTP configuration by sending a test email.
*/
func (a *Client) ValidateSMTPConfiguration(params *ValidateSMTPConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ValidateSMTPConfigurationNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateSMTPConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ValidateSMTPConfiguration",
		Method:             "POST",
		PathPattern:        "/clusters/smtp/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ValidateSMTPConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ValidateSMTPConfigurationNoContent)
	if ok {
		return success, nil
	}
	// unexpected success response
	unexpectedSuccess := result.(*ValidateSMTPConfigurationDefault)
	return nil, runtime.NewAPIError("unexpected success response: content available as default response in error", unexpectedSuccess, unexpectedSuccess.Code())
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
