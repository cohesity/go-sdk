// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterOperationStatus Specifies cluster operation status parameters.
//
// swagger:model ClusterOperationStatus
type ClusterOperationStatus struct {

	// Specifies the id of the cluster.
	ClusterID int64 `json:"clusterId,omitempty"`

	// Specifies the incarnation id of the cluster.
	ClusterIncarnationID int64 `json:"clusterIncarnationId,omitempty"`

	// Specifies the type of cluster operation. 'Destroy' indicates cluster destroy operation. 'Create' indicates cluster create operation. 'NodeAddition' indicates the operation to add nodes to the cluster. 'Upgrade' indicates cluster upgrade operation. 'UploadPackageByUrl' indicates the operation to upload a package by URL. 'UploadPackageAndUpgrade' indicates the operation to upload package by URL and upgrade the cluster. 'NodeRemoval' indicates a node removal operation. 'PackageRemoval' indicates the operation to remove a software package from the cluster.
	// Enum: ["Destroy","Create","NodeAddition","Upgrade","UploadPackageByUrl","UploadPackageAndUpgrade","NodeRemoval","PackageRemoval"]
	Type string `json:"type,omitempty"`

	// Specifies an approximate completion percentage for the operation.
	Percentage int32 `json:"percentage,omitempty"`

	// Specifies an estimated number of seconds until the operation is complete.
	TimeRemainingSeconds int64 `json:"timeRemainingSeconds,omitempty"`

	// Specifies the status of the operation. 'Success' indicates the operation is successful. 'Failed' indicates the operation failed due to an error. 'InProgress' indicates the operation is in progress.
	// Enum: ["InProgress","Success","Failed"]
	Status string `json:"status,omitempty"`

	// Specifies the list of events that took place during the operation.
	Events []*OperationEvents `json:"events,omitempty"`

	// Specifies the operation status of the nodes.
	NodesOperationStatus []*ClusterNodeOperationStatus `json:"nodesOperationStatus,omitempty"`
}

// Validate validates this cluster operation status
func (m *ClusterOperationStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNodesOperationStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterOperationStatusTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Destroy","Create","NodeAddition","Upgrade","UploadPackageByUrl","UploadPackageAndUpgrade","NodeRemoval","PackageRemoval"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterOperationStatusTypeTypePropEnum = append(clusterOperationStatusTypeTypePropEnum, v)
	}
}

const (

	// ClusterOperationStatusTypeDestroy captures enum value "Destroy"
	ClusterOperationStatusTypeDestroy string = "Destroy"

	// ClusterOperationStatusTypeCreate captures enum value "Create"
	ClusterOperationStatusTypeCreate string = "Create"

	// ClusterOperationStatusTypeNodeAddition captures enum value "NodeAddition"
	ClusterOperationStatusTypeNodeAddition string = "NodeAddition"

	// ClusterOperationStatusTypeUpgrade captures enum value "Upgrade"
	ClusterOperationStatusTypeUpgrade string = "Upgrade"

	// ClusterOperationStatusTypeUploadPackageByURL captures enum value "UploadPackageByUrl"
	ClusterOperationStatusTypeUploadPackageByURL string = "UploadPackageByUrl"

	// ClusterOperationStatusTypeUploadPackageAndUpgrade captures enum value "UploadPackageAndUpgrade"
	ClusterOperationStatusTypeUploadPackageAndUpgrade string = "UploadPackageAndUpgrade"

	// ClusterOperationStatusTypeNodeRemoval captures enum value "NodeRemoval"
	ClusterOperationStatusTypeNodeRemoval string = "NodeRemoval"

	// ClusterOperationStatusTypePackageRemoval captures enum value "PackageRemoval"
	ClusterOperationStatusTypePackageRemoval string = "PackageRemoval"
)

// prop value enum
func (m *ClusterOperationStatus) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterOperationStatusTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterOperationStatus) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

var clusterOperationStatusTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["InProgress","Success","Failed"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterOperationStatusTypeStatusPropEnum = append(clusterOperationStatusTypeStatusPropEnum, v)
	}
}

const (

	// ClusterOperationStatusStatusInProgress captures enum value "InProgress"
	ClusterOperationStatusStatusInProgress string = "InProgress"

	// ClusterOperationStatusStatusSuccess captures enum value "Success"
	ClusterOperationStatusStatusSuccess string = "Success"

	// ClusterOperationStatusStatusFailed captures enum value "Failed"
	ClusterOperationStatusStatusFailed string = "Failed"
)

// prop value enum
func (m *ClusterOperationStatus) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, clusterOperationStatusTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ClusterOperationStatus) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ClusterOperationStatus) validateEvents(formats strfmt.Registry) error {
	if swag.IsZero(m.Events) { // not required
		return nil
	}

	for i := 0; i < len(m.Events); i++ {
		if swag.IsZero(m.Events[i]) { // not required
			continue
		}

		if m.Events[i] != nil {
			if err := m.Events[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("events" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) validateNodesOperationStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.NodesOperationStatus) { // not required
		return nil
	}

	for i := 0; i < len(m.NodesOperationStatus); i++ {
		if swag.IsZero(m.NodesOperationStatus[i]) { // not required
			continue
		}

		if m.NodesOperationStatus[i] != nil {
			if err := m.NodesOperationStatus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cluster operation status based on the context it is used
func (m *ClusterOperationStatus) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNodesOperationStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterOperationStatus) contextValidateEvents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Events); i++ {

		if m.Events[i] != nil {

			if swag.IsZero(m.Events[i]) { // not required
				return nil
			}

			if err := m.Events[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("events" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("events" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterOperationStatus) contextValidateNodesOperationStatus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NodesOperationStatus); i++ {

		if m.NodesOperationStatus[i] != nil {

			if swag.IsZero(m.NodesOperationStatus[i]) { // not required
				return nil
			}

			if err := m.NodesOperationStatus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("nodesOperationStatus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterOperationStatus) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterOperationStatus) UnmarshalBinary(b []byte) error {
	var res ClusterOperationStatus
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
