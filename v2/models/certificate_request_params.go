// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CertificateRequestParams Specifies the parameters of a CSR.
//
// swagger:model CertificateRequestParams
type CertificateRequestParams struct {

	// Specifies the organization attribute, which is part of the distinguished name definition. It is used to specify the name of the company.
	// Required: true
	Organization *string `json:"organization"`

	// Specifies the organization unit attribute, which is part of the distinguished name definition. It is used to identify the specific department or business unit in the company that is owning the Cluster.
	// Required: true
	OrganizationUnit *string `json:"organizationUnit"`

	// Specifies the country attribute, which is part of the distinguished name definition. It is used to identify the country where the state is located. It is specified as two letter code defined by the ISO standard.
	// Required: true
	CountryCode *string `json:"countryCode"`

	// Specifies the state attribute, which is part of the distinguished name definition. It is used to identify the state where the city is located.
	// Required: true
	State *string `json:"state"`

	// Specifies the locality attribute, which is part of the distinguished name definition. It is used to identify the city where the company is located or the Cluster is installed.
	// Required: true
	City *string `json:"city"`

	// Specifies the algorithm to be used to generate the key pair. RSA is the default value.
	// Enum: ["RSA_3072","RSA_4096","RSA_7680","ECDSA_256","ECDSA_384","ECDSA_512"]
	KeyType *string `json:"keyType,omitempty"`

	// Specifies the common name attribute, which is part of the distinguished name definition. Common name is used to specify a context for the certificate, for example, the name of the Cluster to which the certificate is to be assigned. Default value is the name of the Cluster.
	// Required: true
	CommonName *string `json:"commonName"`

	// Specifies an alternative subject name component to be included in the certificate. It is used to identify the ways the Cluster will be accessed. It is given as a comma separated list of FQDNs. The default value is the Cluster's VIP hostname.
	// Min Items: 1
	SanList []string `json:"sanList"`

	// Specifies an alternative subject name component to be included in the certificate. Format is a standard e-mail address, for example joe@company.com.
	EmailAddress *string `json:"emailAddress,omitempty"`

	// Specifies duration of the certificate expiry in(hours).
	Duration *string `json:"duration,omitempty"`

	// Specifies the tenant id
	TenantID *string `json:"tenantId,omitempty"`
}

// Validate validates this certificate request params
func (m *CertificateRequestParams) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganizationUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCountryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCommonName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSanList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CertificateRequestParams) validateOrganization(formats strfmt.Registry) error {

	if err := validate.Required("organization", "body", m.Organization); err != nil {
		return err
	}

	return nil
}

func (m *CertificateRequestParams) validateOrganizationUnit(formats strfmt.Registry) error {

	if err := validate.Required("organizationUnit", "body", m.OrganizationUnit); err != nil {
		return err
	}

	return nil
}

func (m *CertificateRequestParams) validateCountryCode(formats strfmt.Registry) error {

	if err := validate.Required("countryCode", "body", m.CountryCode); err != nil {
		return err
	}

	return nil
}

func (m *CertificateRequestParams) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *CertificateRequestParams) validateCity(formats strfmt.Registry) error {

	if err := validate.Required("city", "body", m.City); err != nil {
		return err
	}

	return nil
}

var certificateRequestParamsTypeKeyTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["RSA_3072","RSA_4096","RSA_7680","ECDSA_256","ECDSA_384","ECDSA_512"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		certificateRequestParamsTypeKeyTypePropEnum = append(certificateRequestParamsTypeKeyTypePropEnum, v)
	}
}

const (

	// CertificateRequestParamsKeyTypeRSA3072 captures enum value "RSA_3072"
	CertificateRequestParamsKeyTypeRSA3072 string = "RSA_3072"

	// CertificateRequestParamsKeyTypeRSA4096 captures enum value "RSA_4096"
	CertificateRequestParamsKeyTypeRSA4096 string = "RSA_4096"

	// CertificateRequestParamsKeyTypeRSA7680 captures enum value "RSA_7680"
	CertificateRequestParamsKeyTypeRSA7680 string = "RSA_7680"

	// CertificateRequestParamsKeyTypeECDSA256 captures enum value "ECDSA_256"
	CertificateRequestParamsKeyTypeECDSA256 string = "ECDSA_256"

	// CertificateRequestParamsKeyTypeECDSA384 captures enum value "ECDSA_384"
	CertificateRequestParamsKeyTypeECDSA384 string = "ECDSA_384"

	// CertificateRequestParamsKeyTypeECDSA512 captures enum value "ECDSA_512"
	CertificateRequestParamsKeyTypeECDSA512 string = "ECDSA_512"
)

// prop value enum
func (m *CertificateRequestParams) validateKeyTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, certificateRequestParamsTypeKeyTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CertificateRequestParams) validateKeyType(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyType) { // not required
		return nil
	}

	// value enum
	if err := m.validateKeyTypeEnum("keyType", "body", *m.KeyType); err != nil {
		return err
	}

	return nil
}

func (m *CertificateRequestParams) validateCommonName(formats strfmt.Registry) error {

	if err := validate.Required("commonName", "body", m.CommonName); err != nil {
		return err
	}

	return nil
}

func (m *CertificateRequestParams) validateSanList(formats strfmt.Registry) error {
	if swag.IsZero(m.SanList) { // not required
		return nil
	}

	iSanListSize := int64(len(m.SanList))

	if err := validate.MinItems("sanList", "body", iSanListSize, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this certificate request params based on context it is used
func (m *CertificateRequestParams) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CertificateRequestParams) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CertificateRequestParams) UnmarshalBinary(b []byte) error {
	var res CertificateRequestParams
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
