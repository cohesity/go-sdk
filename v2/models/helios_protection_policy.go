// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HeliosProtectionPolicy Specifies common fields required to define Protection Policy on Helios.
//
// swagger:model HeliosProtectionPolicy
type HeliosProtectionPolicy struct {

	// Specifies the name of the Protection Policy.
	// Required: true
	Name *string `json:"name"`

	// Specifies the type of the Protection Policy to be created on Helios.
	// Required: true
	// Enum: ["GlobalPolicy","DMaaSPolicy","OnPremPolicy"]
	Type *string `json:"type"`

	// Specifies the cluster to which this policy belongs.
	// This required is only for type OnPremPolicy. The format is clusterId:clusterIncarnationId.
	// Pattern: ^([0-9]+:[0-9]+)$
	ClusterIdentifier *string `json:"clusterIdentifier,omitempty"`

	// Specifies the tenants which have access to this object.
	// Read Only: true
	TenantIds []*string `json:"tenantIds"`

	// Specifies the backup schedule of a Protection Policy.
	BackupPolicy *HeliosBackupPolicy `json:"backupPolicy,omitempty"`

	// Specifies the description of the Protection Policy.
	Description *string `json:"description,omitempty"`

	// Blackout Window
	//
	// List of Blackout Windows. If specified, this field defines blackout periods when new Group Runs are not started. If a Group Run has been scheduled but not yet executed and the blackout period starts, the behavior depends on the policy field AbortInBlackoutPeriod.
	BlackoutWindow []*HeliosBlackoutWindow `json:"blackoutWindow"`

	// Extended Retention
	//
	// Specifies additional retention policies that should be applied to the backup snapshots. A backup snapshot will be retained up to a time that is the maximum of all retention policies that are applicable to it.
	ExtendedRetention []*HeliosExtendedRetentionPolicy `json:"extendedRetention"`

	// Specifies the remote, archival or cloudSpin targets where the snapshot is backed up. This only applies to OnPrem policy created from Helios. Does not apply to DMaaS policies.
	RemoteTargetPolicy *HeliosTargetsConfiguration `json:"remoteTargetPolicy,omitempty"`

	// Specifies the retry options of a Protection Policy.
	RetryOptions *HeliosRetryOptions `json:"retryOptions,omitempty"`

	// This field is now deprecated. Please use the DataLockConfig in the backup retention.
	// Enum: ["Compliance","Administrative"]
	DataLock *string `json:"dataLock,omitempty"`
}

// Validate validates this helios protection policy
func (m *HeliosProtectionPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClusterIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlackoutWindow(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExtendedRetention(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteTargetPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetryOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataLock(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HeliosProtectionPolicy) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var heliosProtectionPolicyTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GlobalPolicy","DMaaSPolicy","OnPremPolicy"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		heliosProtectionPolicyTypeTypePropEnum = append(heliosProtectionPolicyTypeTypePropEnum, v)
	}
}

const (

	// HeliosProtectionPolicyTypeGlobalPolicy captures enum value "GlobalPolicy"
	HeliosProtectionPolicyTypeGlobalPolicy string = "GlobalPolicy"

	// HeliosProtectionPolicyTypeDMaaSPolicy captures enum value "DMaaSPolicy"
	HeliosProtectionPolicyTypeDMaaSPolicy string = "DMaaSPolicy"

	// HeliosProtectionPolicyTypeOnPremPolicy captures enum value "OnPremPolicy"
	HeliosProtectionPolicyTypeOnPremPolicy string = "OnPremPolicy"
)

// prop value enum
func (m *HeliosProtectionPolicy) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, heliosProtectionPolicyTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HeliosProtectionPolicy) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *HeliosProtectionPolicy) validateClusterIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(m.ClusterIdentifier) { // not required
		return nil
	}

	if err := validate.Pattern("clusterIdentifier", "body", *m.ClusterIdentifier, `^([0-9]+:[0-9]+)$`); err != nil {
		return err
	}

	return nil
}

func (m *HeliosProtectionPolicy) validateBackupPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupPolicy) { // not required
		return nil
	}

	if m.BackupPolicy != nil {
		if err := m.BackupPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *HeliosProtectionPolicy) validateBlackoutWindow(formats strfmt.Registry) error {
	if swag.IsZero(m.BlackoutWindow) { // not required
		return nil
	}

	for i := 0; i < len(m.BlackoutWindow); i++ {
		if swag.IsZero(m.BlackoutWindow[i]) { // not required
			continue
		}

		if m.BlackoutWindow[i] != nil {
			if err := m.BlackoutWindow[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HeliosProtectionPolicy) validateExtendedRetention(formats strfmt.Registry) error {
	if swag.IsZero(m.ExtendedRetention) { // not required
		return nil
	}

	for i := 0; i < len(m.ExtendedRetention); i++ {
		if swag.IsZero(m.ExtendedRetention[i]) { // not required
			continue
		}

		if m.ExtendedRetention[i] != nil {
			if err := m.ExtendedRetention[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HeliosProtectionPolicy) validateRemoteTargetPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.RemoteTargetPolicy) { // not required
		return nil
	}

	if m.RemoteTargetPolicy != nil {
		if err := m.RemoteTargetPolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteTargetPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteTargetPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *HeliosProtectionPolicy) validateRetryOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.RetryOptions) { // not required
		return nil
	}

	if m.RetryOptions != nil {
		if err := m.RetryOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retryOptions")
			}
			return err
		}
	}

	return nil
}

var heliosProtectionPolicyTypeDataLockPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Compliance","Administrative"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		heliosProtectionPolicyTypeDataLockPropEnum = append(heliosProtectionPolicyTypeDataLockPropEnum, v)
	}
}

const (

	// HeliosProtectionPolicyDataLockCompliance captures enum value "Compliance"
	HeliosProtectionPolicyDataLockCompliance string = "Compliance"

	// HeliosProtectionPolicyDataLockAdministrative captures enum value "Administrative"
	HeliosProtectionPolicyDataLockAdministrative string = "Administrative"
)

// prop value enum
func (m *HeliosProtectionPolicy) validateDataLockEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, heliosProtectionPolicyTypeDataLockPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HeliosProtectionPolicy) validateDataLock(formats strfmt.Registry) error {
	if swag.IsZero(m.DataLock) { // not required
		return nil
	}

	// value enum
	if err := m.validateDataLockEnum("dataLock", "body", *m.DataLock); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this helios protection policy based on the context it is used
func (m *HeliosProtectionPolicy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTenantIds(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlackoutWindow(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExtendedRetention(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRemoteTargetPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRetryOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HeliosProtectionPolicy) contextValidateTenantIds(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "tenantIds", "body", []*string(m.TenantIds)); err != nil {
		return err
	}

	return nil
}

func (m *HeliosProtectionPolicy) contextValidateBackupPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupPolicy != nil {

		if swag.IsZero(m.BackupPolicy) { // not required
			return nil
		}

		if err := m.BackupPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *HeliosProtectionPolicy) contextValidateBlackoutWindow(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BlackoutWindow); i++ {

		if m.BlackoutWindow[i] != nil {

			if swag.IsZero(m.BlackoutWindow[i]) { // not required
				return nil
			}

			if err := m.BlackoutWindow[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("blackoutWindow" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HeliosProtectionPolicy) contextValidateExtendedRetention(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExtendedRetention); i++ {

		if m.ExtendedRetention[i] != nil {

			if swag.IsZero(m.ExtendedRetention[i]) { // not required
				return nil
			}

			if err := m.ExtendedRetention[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("extendedRetention" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *HeliosProtectionPolicy) contextValidateRemoteTargetPolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.RemoteTargetPolicy != nil {

		if swag.IsZero(m.RemoteTargetPolicy) { // not required
			return nil
		}

		if err := m.RemoteTargetPolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("remoteTargetPolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("remoteTargetPolicy")
			}
			return err
		}
	}

	return nil
}

func (m *HeliosProtectionPolicy) contextValidateRetryOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.RetryOptions != nil {

		if swag.IsZero(m.RetryOptions) { // not required
			return nil
		}

		if err := m.RetryOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("retryOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("retryOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *HeliosProtectionPolicy) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HeliosProtectionPolicy) UnmarshalBinary(b []byte) error {
	var res HeliosProtectionPolicy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
