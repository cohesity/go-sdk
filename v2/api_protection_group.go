/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProtectionGroupAPIService ProtectionGroupAPI service
type ProtectionGroupAPIService service

type ApiCreateProtectionGroupRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	body *CreateOrUpdateProtectionGroupRequest
}

// Specifies the parameters to create a Protection Group.
func (r ApiCreateProtectionGroupRequest) Body(body CreateOrUpdateProtectionGroupRequest) ApiCreateProtectionGroupRequest {
	r.body = &body
	return r
}

func (r ApiCreateProtectionGroupRequest) Execute() (*ProtectionGroup, *http.Response, error) {
	return r.ApiService.CreateProtectionGroupExecute(r)
}

/*
CreateProtectionGroup Create a Protection Group.

Create a Protection Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateProtectionGroupRequest
*/
func (a *ProtectionGroupAPIService) CreateProtectionGroup(ctx context.Context) ApiCreateProtectionGroupRequest {
	return ApiCreateProtectionGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectionGroup
func (a *ProtectionGroupAPIService) CreateProtectionGroupExecute(r ApiCreateProtectionGroupRequest) (*ProtectionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.CreateProtectionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateProtectionGroupRunRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	body *CreateProtectionGroupRunRequest
}

// Specifies the parameters to start a protection run.
func (r ApiCreateProtectionGroupRunRequest) Body(body CreateProtectionGroupRunRequest) ApiCreateProtectionGroupRunRequest {
	r.body = &body
	return r
}

func (r ApiCreateProtectionGroupRunRequest) Execute() (*CreateProtectionGroupRunResponseBody, *http.Response, error) {
	return r.ApiService.CreateProtectionGroupRunExecute(r)
}

/*
CreateProtectionGroupRun Create a new protection run.

Create a new protection run. This can be used to start a run for a Protection Group on demand, ignoring the schedule and retention specified in the protection policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @return ApiCreateProtectionGroupRunRequest
*/
func (a *ProtectionGroupAPIService) CreateProtectionGroupRun(ctx context.Context, id string) ApiCreateProtectionGroupRunRequest {
	return ApiCreateProtectionGroupRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CreateProtectionGroupRunResponseBody
func (a *ProtectionGroupAPIService) CreateProtectionGroupRunExecute(r ApiCreateProtectionGroupRunRequest) (*CreateProtectionGroupRunResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateProtectionGroupRunResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.CreateProtectionGroupRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProtectionGroupRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	deleteSnapshots *bool
}

// Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is deleted.
func (r ApiDeleteProtectionGroupRequest) DeleteSnapshots(deleteSnapshots bool) ApiDeleteProtectionGroupRequest {
	r.deleteSnapshots = &deleteSnapshots
	return r
}

func (r ApiDeleteProtectionGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProtectionGroupExecute(r)
}

/*
DeleteProtectionGroup Delete a Protection Group.

Returns Success if the Protection Group is deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @return ApiDeleteProtectionGroupRequest
*/
func (a *ProtectionGroupAPIService) DeleteProtectionGroup(ctx context.Context, id string) ApiDeleteProtectionGroupRequest {
	return ApiDeleteProtectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ProtectionGroupAPIService) DeleteProtectionGroupExecute(r ApiDeleteProtectionGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.DeleteProtectionGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteSnapshots", r.deleteSnapshots, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetProtectionGroupByIdRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	requestInitiatorType *string
	includeLastRunInfo *bool
	pruneExcludedSourceIds *bool
	pruneSourceIds *bool
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectionGroupByIdRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectionGroupByIdRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// If true, the response will include last run info. If it is false or not specified, the last run info won&#39;t be returned.
func (r ApiGetProtectionGroupByIdRequest) IncludeLastRunInfo(includeLastRunInfo bool) ApiGetProtectionGroupByIdRequest {
	r.includeLastRunInfo = &includeLastRunInfo
	return r
}

// If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
func (r ApiGetProtectionGroupByIdRequest) PruneExcludedSourceIds(pruneExcludedSourceIds bool) ApiGetProtectionGroupByIdRequest {
	r.pruneExcludedSourceIds = &pruneExcludedSourceIds
	return r
}

// If true, the response will exclude the list of source IDs within the group specified.
func (r ApiGetProtectionGroupByIdRequest) PruneSourceIds(pruneSourceIds bool) ApiGetProtectionGroupByIdRequest {
	r.pruneSourceIds = &pruneSourceIds
	return r
}

func (r ApiGetProtectionGroupByIdRequest) Execute() (*ProtectionGroup, *http.Response, error) {
	return r.ApiService.GetProtectionGroupByIdExecute(r)
}

/*
GetProtectionGroupById List details about single Protection Group.

Returns the Protection Group corresponding to the specified Group id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @return ApiGetProtectionGroupByIdRequest
*/
func (a *ProtectionGroupAPIService) GetProtectionGroupById(ctx context.Context, id string) ApiGetProtectionGroupByIdRequest {
	return ApiGetProtectionGroupByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectionGroup
func (a *ProtectionGroupAPIService) GetProtectionGroupByIdExecute(r ApiGetProtectionGroupByIdRequest) (*ProtectionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetProtectionGroupById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeLastRunInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLastRunInfo", r.includeLastRunInfo, "")
	}
	if r.pruneExcludedSourceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pruneExcludedSourceIds", r.pruneExcludedSourceIds, "")
	}
	if r.pruneSourceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pruneSourceIds", r.pruneSourceIds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionGroupRunRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	runId string
	requestInitiatorType *string
	tenantIds *[]string
	includeTenants *bool
	includeObjectDetails *bool
	useCachedData *bool
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectionGroupRunRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectionGroupRunRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// TenantIds contains ids of the tenants for which the run is to be returned.
func (r ApiGetProtectionGroupRunRequest) TenantIds(tenantIds []string) ApiGetProtectionGroupRunRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it&#39;s not specified, it is true by default.
func (r ApiGetProtectionGroupRunRequest) IncludeTenants(includeTenants bool) ApiGetProtectionGroupRunRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies if the result includes the object details for a protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
func (r ApiGetProtectionGroupRunRequest) IncludeObjectDetails(includeObjectDetails bool) ApiGetProtectionGroupRunRequest {
	r.includeObjectDetails = &includeObjectDetails
	return r
}

// Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetProtectionGroupRunRequest) UseCachedData(useCachedData bool) ApiGetProtectionGroupRunRequest {
	r.useCachedData = &useCachedData
	return r
}

func (r ApiGetProtectionGroupRunRequest) Execute() (*ProtectionGroupRun, *http.Response, error) {
	return r.ApiService.GetProtectionGroupRunExecute(r)
}

/*
GetProtectionGroupRun Get a run for a Protection Group.

Get a run for a particular Protection Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @param runId Specifies a unique run id of the Protection Group run.
 @return ApiGetProtectionGroupRunRequest
*/
func (a *ProtectionGroupAPIService) GetProtectionGroupRun(ctx context.Context, id string, runId string) ApiGetProtectionGroupRunRequest {
	return ApiGetProtectionGroupRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		runId: runId,
	}
}

// Execute executes the request
//  @return ProtectionGroupRun
func (a *ProtectionGroupAPIService) GetProtectionGroupRunExecute(r ApiGetProtectionGroupRunRequest) (*ProtectionGroupRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionGroupRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetProtectionGroupRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs/{runId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeObjectDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeObjectDetails", r.includeObjectDetails, "")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionGroupRunsRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	requestInitiatorType *string
	runId *string
	startTimeUsecs *int64
	endTimeUsecs *int64
	tenantIds *[]string
	includeTenants *bool
	runTypes *[]string
	includeObjectDetails *bool
	localBackupRunStatus *[]string
	replicationRunStatus *[]string
	archivalRunStatus *[]string
	cloudSpinRunStatus *[]string
	numRuns *int64
	excludeNonRestorableRuns *bool
	runTags *[]string
	useCachedData *bool
	filterByEndTime *bool
	snapshotTargetTypes *[]string
	onlyReturnSuccessfulCopyRun *bool
	filterByCopyTaskEndTime *bool
	truncateResponse *bool
	onlyReturnShellInfo *bool
	excludeErrorRuns *bool
	jobRunStartTimeUsecs *int64
	onlyReturnDataMigrationJobs *bool
	includeExtensionInfo *bool
	includeRpoSnapshots *bool
	sourceId *int64
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectionGroupRunsRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectionGroupRunsRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Specifies the protection run id.
func (r ApiGetProtectionGroupRunsRequest) RunId(runId string) ApiGetProtectionGroupRunsRequest {
	r.runId = &runId
	return r
}

// Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
func (r ApiGetProtectionGroupRunsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionGroupRunsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
func (r ApiGetProtectionGroupRunsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionGroupRunsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetProtectionGroupRunsRequest) TenantIds(tenantIds []string) ApiGetProtectionGroupRunsRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
func (r ApiGetProtectionGroupRunsRequest) IncludeTenants(includeTenants bool) ApiGetProtectionGroupRunsRequest {
	r.includeTenants = &includeTenants
	return r
}

// Filter by run type. Only protection run matching the specified types will be returned.
func (r ApiGetProtectionGroupRunsRequest) RunTypes(runTypes []string) ApiGetProtectionGroupRunsRequest {
	r.runTypes = &runTypes
	return r
}

// Specifies if the result includes the object details for each protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
func (r ApiGetProtectionGroupRunsRequest) IncludeObjectDetails(includeObjectDetails bool) ApiGetProtectionGroupRunsRequest {
	r.includeObjectDetails = &includeObjectDetails
	return r
}

// Specifies a list of local backup status, runs matching the status will be returned.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupRunsRequest) LocalBackupRunStatus(localBackupRunStatus []string) ApiGetProtectionGroupRunsRequest {
	r.localBackupRunStatus = &localBackupRunStatus
	return r
}

// Specifies a list of replication status, runs matching the status will be returned.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupRunsRequest) ReplicationRunStatus(replicationRunStatus []string) ApiGetProtectionGroupRunsRequest {
	r.replicationRunStatus = &replicationRunStatus
	return r
}

// Specifies a list of archival status, runs matching the status will be returned.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupRunsRequest) ArchivalRunStatus(archivalRunStatus []string) ApiGetProtectionGroupRunsRequest {
	r.archivalRunStatus = &archivalRunStatus
	return r
}

// Specifies a list of cloud spin status, runs matching the status will be returned.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupRunsRequest) CloudSpinRunStatus(cloudSpinRunStatus []string) ApiGetProtectionGroupRunsRequest {
	r.cloudSpinRunStatus = &cloudSpinRunStatus
	return r
}

// Specifies the max number of runs. If not specified, at most 100 runs will be returned.
func (r ApiGetProtectionGroupRunsRequest) NumRuns(numRuns int64) ApiGetProtectionGroupRunsRequest {
	r.numRuns = &numRuns
	return r
}

// Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
func (r ApiGetProtectionGroupRunsRequest) ExcludeNonRestorableRuns(excludeNonRestorableRuns bool) ApiGetProtectionGroupRunsRequest {
	r.excludeNonRestorableRuns = &excludeNonRestorableRuns
	return r
}

// Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be returned.
func (r ApiGetProtectionGroupRunsRequest) RunTags(runTags []string) ApiGetProtectionGroupRunsRequest {
	r.runTags = &runTags
	return r
}

// Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetProtectionGroupRunsRequest) UseCachedData(useCachedData bool) ApiGetProtectionGroupRunsRequest {
	r.useCachedData = &useCachedData
	return r
}

// If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with start time in the time range are returned.
func (r ApiGetProtectionGroupRunsRequest) FilterByEndTime(filterByEndTime bool) ApiGetProtectionGroupRunsRequest {
	r.filterByEndTime = &filterByEndTime
	return r
}

// Specifies the snapshot&#39;s target type which should be filtered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
func (r ApiGetProtectionGroupRunsRequest) SnapshotTargetTypes(snapshotTargetTypes []string) ApiGetProtectionGroupRunsRequest {
	r.snapshotTargetTypes = &snapshotTargetTypes
	return r
}

// If set to false, all copy_tasks in any given valid state will be considered. If left empty or set to true, only successful copy_tasks would be considered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
func (r ApiGetProtectionGroupRunsRequest) OnlyReturnSuccessfulCopyRun(onlyReturnSuccessfulCopyRun bool) ApiGetProtectionGroupRunsRequest {
	r.onlyReturnSuccessfulCopyRun = &onlyReturnSuccessfulCopyRun
	return r
}

// If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only one of filterByEndTime and filterByCopyTaskEndTime can be set.
func (r ApiGetProtectionGroupRunsRequest) FilterByCopyTaskEndTime(filterByCopyTaskEndTime bool) ApiGetProtectionGroupRunsRequest {
	r.filterByCopyTaskEndTime = &filterByCopyTaskEndTime
	return r
}

// If set, magneto will truncate the response if it exceeds max size limit governed by magneto_http_rpc_response_size_limit_bytes
func (r ApiGetProtectionGroupRunsRequest) TruncateResponse(truncateResponse bool) ApiGetProtectionGroupRunsRequest {
	r.truncateResponse = &truncateResponse
	return r
}

// If set, returns only shell info such as run&#39;s start time, type, error if any.
func (r ApiGetProtectionGroupRunsRequest) OnlyReturnShellInfo(onlyReturnShellInfo bool) ApiGetProtectionGroupRunsRequest {
	r.onlyReturnShellInfo = &onlyReturnShellInfo
	return r
}

// Specifies whether to exclude runs with error. If no value is specified, then runs with errors are included.
func (r ApiGetProtectionGroupRunsRequest) ExcludeErrorRuns(excludeErrorRuns bool) ApiGetProtectionGroupRunsRequest {
	r.excludeErrorRuns = &excludeErrorRuns
	return r
}

// Return a specific Job Run by specifying a time and a group id. Specify the time when the Job Run started as a Unix epoch Timestamp (in microseconds). If this field is specified, jobId must also be specified.
func (r ApiGetProtectionGroupRunsRequest) JobRunStartTimeUsecs(jobRunStartTimeUsecs int64) ApiGetProtectionGroupRunsRequest {
	r.jobRunStartTimeUsecs = &jobRunStartTimeUsecs
	return r
}

// Specifies if only data stubbing jobs should be returned. If not set, no data migration job will be returned.
func (r ApiGetProtectionGroupRunsRequest) OnlyReturnDataMigrationJobs(onlyReturnDataMigrationJobs bool) ApiGetProtectionGroupRunsRequest {
	r.onlyReturnDataMigrationJobs = &onlyReturnDataMigrationJobs
	return r
}

// Specifies if needs to include proto extensions if they are extended.
func (r ApiGetProtectionGroupRunsRequest) IncludeExtensionInfo(includeExtensionInfo bool) ApiGetProtectionGroupRunsRequest {
	r.includeExtensionInfo = &includeExtensionInfo
	return r
}

// If true, then the snapshots for Protection Sources protected by Rpo policies will also be returned.
func (r ApiGetProtectionGroupRunsRequest) IncludeRpoSnapshots(includeRpoSnapshots bool) ApiGetProtectionGroupRunsRequest {
	r.includeRpoSnapshots = &includeRpoSnapshots
	return r
}

// Filter by source id. Only Job Runs protecting the specified source (such as a VM or View) are returned. The source id is assigned by the Cohesity Cluster.
func (r ApiGetProtectionGroupRunsRequest) SourceId(sourceId int64) ApiGetProtectionGroupRunsRequest {
	r.sourceId = &sourceId
	return r
}

func (r ApiGetProtectionGroupRunsRequest) Execute() (*ProtectionGroupRuns, *http.Response, error) {
	return r.ApiService.GetProtectionGroupRunsExecute(r)
}

/*
GetProtectionGroupRuns Get the list of runs for a Protection Group.

Get the runs for a particular Protection Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @return ApiGetProtectionGroupRunsRequest
*/
func (a *ProtectionGroupAPIService) GetProtectionGroupRuns(ctx context.Context, id string) ApiGetProtectionGroupRunsRequest {
	return ApiGetProtectionGroupRunsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectionGroupRuns
func (a *ProtectionGroupAPIService) GetProtectionGroupRunsExecute(r ApiGetProtectionGroupRunsRequest) (*ProtectionGroupRuns, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionGroupRuns
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetProtectionGroupRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.runId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runId", r.runId, "")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.runTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTypes", r.runTypes, "csv")
	}
	if r.includeObjectDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeObjectDetails", r.includeObjectDetails, "")
	}
	if r.localBackupRunStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "localBackupRunStatus", r.localBackupRunStatus, "csv")
	}
	if r.replicationRunStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replicationRunStatus", r.replicationRunStatus, "csv")
	}
	if r.archivalRunStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archivalRunStatus", r.archivalRunStatus, "csv")
	}
	if r.cloudSpinRunStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cloudSpinRunStatus", r.cloudSpinRunStatus, "csv")
	}
	if r.numRuns != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numRuns", r.numRuns, "")
	}
	if r.excludeNonRestorableRuns != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeNonRestorableRuns", r.excludeNonRestorableRuns, "")
	} else {
		var defaultValue bool = false
		r.excludeNonRestorableRuns = &defaultValue
	}
	if r.runTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTags", r.runTags, "csv")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	if r.filterByEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByEndTime", r.filterByEndTime, "")
	}
	if r.snapshotTargetTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotTargetTypes", r.snapshotTargetTypes, "csv")
	}
	if r.onlyReturnSuccessfulCopyRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyReturnSuccessfulCopyRun", r.onlyReturnSuccessfulCopyRun, "")
	}
	if r.filterByCopyTaskEndTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterByCopyTaskEndTime", r.filterByCopyTaskEndTime, "")
	}
	if r.truncateResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "truncateResponse", r.truncateResponse, "")
	}
	if r.onlyReturnShellInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyReturnShellInfo", r.onlyReturnShellInfo, "")
	}
	if r.excludeErrorRuns != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeErrorRuns", r.excludeErrorRuns, "")
	}
	if r.jobRunStartTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobRunStartTimeUsecs", r.jobRunStartTimeUsecs, "")
	}
	if r.onlyReturnDataMigrationJobs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyReturnDataMigrationJobs", r.onlyReturnDataMigrationJobs, "")
	}
	if r.includeExtensionInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeExtensionInfo", r.includeExtensionInfo, "")
	}
	if r.includeRpoSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRpoSnapshots", r.includeRpoSnapshots, "")
	}
	if r.sourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceId", r.sourceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionGroupsRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	requestInitiatorType *string
	ids *[]string
	names *[]string
	policyIds *[]string
	storageDomainId *int64
	includeGroupsWithDatalockOnly *bool
	environments *[]string
	office365Workloads *[]string
	isActive *bool
	isDeleted *bool
	isPaused *bool
	lastRunLocalBackupStatus *[]string
	lastRunReplicationStatus *[]string
	lastRunArchivalStatus *[]string
	lastRunCloudSpinStatus *[]string
	lastRunAnyStatus *[]string
	isLastRunSlaViolated *bool
	tenantIds *[]string
	includeTenants *bool
	includeLastRunInfo *bool
	pruneExcludedSourceIds *bool
	pruneSourceIds *bool
	useCachedData *bool
	sourceIds *[]int64
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectionGroupsRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectionGroupsRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Filter by a list of Protection Group ids.
func (r ApiGetProtectionGroupsRequest) Ids(ids []string) ApiGetProtectionGroupsRequest {
	r.ids = &ids
	return r
}

// Filter by a list of Protection Group names.
func (r ApiGetProtectionGroupsRequest) Names(names []string) ApiGetProtectionGroupsRequest {
	r.names = &names
	return r
}

// Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the specified Policy ids, are returned.
func (r ApiGetProtectionGroupsRequest) PolicyIds(policyIds []string) ApiGetProtectionGroupsRequest {
	r.policyIds = &policyIds
	return r
}

// Filter by Storage Domain id. Only Protection Groups writing data to this Storage Domain will be returned.
func (r ApiGetProtectionGroupsRequest) StorageDomainId(storageDomainId int64) ApiGetProtectionGroupsRequest {
	r.storageDomainId = &storageDomainId
	return r
}

// Whether to only return Protection Groups with a datalock.
func (r ApiGetProtectionGroupsRequest) IncludeGroupsWithDatalockOnly(includeGroupsWithDatalockOnly bool) ApiGetProtectionGroupsRequest {
	r.includeGroupsWithDatalockOnly = &includeGroupsWithDatalockOnly
	return r
}

// Filter by environment types such as &#39;kVMware&#39;, &#39;kView&#39;, etc. Only Protection Groups protecting the specified environment types are returned.
func (r ApiGetProtectionGroupsRequest) Environments(environments []string) ApiGetProtectionGroupsRequest {
	r.environments = &environments
	return r
}

func (r ApiGetProtectionGroupsRequest) Office365Workloads(office365Workloads []string) ApiGetProtectionGroupsRequest {
	r.office365Workloads = &office365Workloads
	return r
}

// Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned. If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is deactivated, the Protection Group becomes Inactive.
func (r ApiGetProtectionGroupsRequest) IsActive(isActive bool) ApiGetProtectionGroupsRequest {
	r.isActive = &isActive
	return r
}

// If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these cases.
func (r ApiGetProtectionGroupsRequest) IsDeleted(isDeleted bool) ApiGetProtectionGroupsRequest {
	r.isDeleted = &isDeleted
	return r
}

// Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are returned.
func (r ApiGetProtectionGroupsRequest) IsPaused(isPaused bool) ApiGetProtectionGroupsRequest {
	r.isPaused = &isPaused
	return r
}

// Filter by last local backup run status.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupsRequest) LastRunLocalBackupStatus(lastRunLocalBackupStatus []string) ApiGetProtectionGroupsRequest {
	r.lastRunLocalBackupStatus = &lastRunLocalBackupStatus
	return r
}

// Filter by last remote replication run status.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupsRequest) LastRunReplicationStatus(lastRunReplicationStatus []string) ApiGetProtectionGroupsRequest {
	r.lastRunReplicationStatus = &lastRunReplicationStatus
	return r
}

// Filter by last cloud archival run status.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupsRequest) LastRunArchivalStatus(lastRunArchivalStatus []string) ApiGetProtectionGroupsRequest {
	r.lastRunArchivalStatus = &lastRunArchivalStatus
	return r
}

// Filter by last cloud spin run status.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupsRequest) LastRunCloudSpinStatus(lastRunCloudSpinStatus []string) ApiGetProtectionGroupsRequest {
	r.lastRunCloudSpinStatus = &lastRunCloudSpinStatus
	return r
}

// Filter by last any run status.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Paused&#39; indicates that the ongoing run has been paused.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionGroupsRequest) LastRunAnyStatus(lastRunAnyStatus []string) ApiGetProtectionGroupsRequest {
	r.lastRunAnyStatus = &lastRunAnyStatus
	return r
}

// If true, return Protection Groups for which last run SLA was violated.
func (r ApiGetProtectionGroupsRequest) IsLastRunSlaViolated(isLastRunSlaViolated bool) ApiGetProtectionGroupsRequest {
	r.isLastRunSlaViolated = &isLastRunSlaViolated
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetProtectionGroupsRequest) TenantIds(tenantIds []string) ApiGetProtectionGroupsRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
func (r ApiGetProtectionGroupsRequest) IncludeTenants(includeTenants bool) ApiGetProtectionGroupsRequest {
	r.includeTenants = &includeTenants
	return r
}

// If true, the response will include last run info. If it is false or not specified, the last run info won&#39;t be returned.
func (r ApiGetProtectionGroupsRequest) IncludeLastRunInfo(includeLastRunInfo bool) ApiGetProtectionGroupsRequest {
	r.includeLastRunInfo = &includeLastRunInfo
	return r
}

// If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
func (r ApiGetProtectionGroupsRequest) PruneExcludedSourceIds(pruneExcludedSourceIds bool) ApiGetProtectionGroupsRequest {
	r.pruneExcludedSourceIds = &pruneExcludedSourceIds
	return r
}

// If true, the response will exclude the list of source IDs within the group specified.
func (r ApiGetProtectionGroupsRequest) PruneSourceIds(pruneSourceIds bool) ApiGetProtectionGroupsRequest {
	r.pruneSourceIds = &pruneSourceIds
	return r
}

// Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetProtectionGroupsRequest) UseCachedData(useCachedData bool) ApiGetProtectionGroupsRequest {
	r.useCachedData = &useCachedData
	return r
}

// Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the specified Source ids, are returned.
func (r ApiGetProtectionGroupsRequest) SourceIds(sourceIds []int64) ApiGetProtectionGroupsRequest {
	r.sourceIds = &sourceIds
	return r
}

func (r ApiGetProtectionGroupsRequest) Execute() (*ProtectionGroups, *http.Response, error) {
	return r.ApiService.GetProtectionGroupsExecute(r)
}

/*
GetProtectionGroups Get the list of Protection Groups.

Get the list of Protection Groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProtectionGroupsRequest
*/
func (a *ProtectionGroupAPIService) GetProtectionGroups(ctx context.Context) ApiGetProtectionGroupsRequest {
	return ApiGetProtectionGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectionGroups
func (a *ProtectionGroupAPIService) GetProtectionGroupsExecute(r ApiGetProtectionGroupsRequest) (*ProtectionGroups, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionGroups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetProtectionGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "csv")
	}
	if r.policyIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIds", r.policyIds, "csv")
	}
	if r.storageDomainId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainId", r.storageDomainId, "")
	}
	if r.includeGroupsWithDatalockOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGroupsWithDatalockOnly", r.includeGroupsWithDatalockOnly, "")
	}
	if r.environments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environments", r.environments, "csv")
	}
	if r.office365Workloads != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "office365Workloads", r.office365Workloads, "csv")
	}
	if r.isActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isActive", r.isActive, "")
	}
	if r.isDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDeleted", r.isDeleted, "")
	}
	if r.isPaused != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPaused", r.isPaused, "")
	}
	if r.lastRunLocalBackupStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunLocalBackupStatus", r.lastRunLocalBackupStatus, "csv")
	}
	if r.lastRunReplicationStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunReplicationStatus", r.lastRunReplicationStatus, "csv")
	}
	if r.lastRunArchivalStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunArchivalStatus", r.lastRunArchivalStatus, "csv")
	}
	if r.lastRunCloudSpinStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunCloudSpinStatus", r.lastRunCloudSpinStatus, "csv")
	}
	if r.lastRunAnyStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunAnyStatus", r.lastRunAnyStatus, "csv")
	}
	if r.isLastRunSlaViolated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLastRunSlaViolated", r.isLastRunSlaViolated, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeLastRunInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLastRunInfo", r.includeLastRunInfo, "")
	}
	if r.pruneExcludedSourceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pruneExcludedSourceIds", r.pruneExcludedSourceIds, "")
	}
	if r.pruneSourceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pruneSourceIds", r.pruneSourceIds, "")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	if r.sourceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", r.sourceIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionRunProgressRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	runId string
	objects *[]int64
	tenantIds *[]string
	includeTenants *bool
	includeFinishedTasks *bool
	startTimeUsecs *int64
	endTimeUsecs *int64
	maxTasksNum *int32
	excludeObjectDetails *bool
	includeEventLogs *bool
	maxLogLevel *int32
	runTaskPath *string
	objectTaskPaths *[]string
}

// Specifies the objects whose progress will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run progress will not be returned and only the progress of the specified objects will be returned.
func (r ApiGetProtectionRunProgressRequest) Objects(objects []int64) ApiGetProtectionRunProgressRequest {
	r.objects = &objects
	return r
}

// TenantIds contains ids of the tenants for which the run is to be returned.
func (r ApiGetProtectionRunProgressRequest) TenantIds(tenantIds []string) ApiGetProtectionRunProgressRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it&#39;s not specified, it is true by default.
func (r ApiGetProtectionRunProgressRequest) IncludeTenants(includeTenants bool) ApiGetProtectionRunProgressRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies whether to return finished tasks. By default only active tasks are returned.
func (r ApiGetProtectionRunProgressRequest) IncludeFinishedTasks(includeFinishedTasks bool) ApiGetProtectionRunProgressRequest {
	r.includeFinishedTasks = &includeFinishedTasks
	return r
}

// Specifies the time after which the progress task starts in Unix epoch Timestamp(in microseconds).
func (r ApiGetProtectionRunProgressRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionRunProgressRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Specifies the time before which the progress task ends in Unix epoch Timestamp(in microseconds).
func (r ApiGetProtectionRunProgressRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionRunProgressRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Specifies the maximum number of tasks to return.
func (r ApiGetProtectionRunProgressRequest) MaxTasksNum(maxTasksNum int32) ApiGetProtectionRunProgressRequest {
	r.maxTasksNum = &maxTasksNum
	return r
}

// Specifies whether to return objects. By default all the task tree are returned.
func (r ApiGetProtectionRunProgressRequest) ExcludeObjectDetails(excludeObjectDetails bool) ApiGetProtectionRunProgressRequest {
	r.excludeObjectDetails = &excludeObjectDetails
	return r
}

// Specifies whether to include event logs
func (r ApiGetProtectionRunProgressRequest) IncludeEventLogs(includeEventLogs bool) ApiGetProtectionRunProgressRequest {
	r.includeEventLogs = &includeEventLogs
	return r
}

// Specifies the number of levels till which to fetch the event logs. This is applicable only when includeEventLogs is true.
func (r ApiGetProtectionRunProgressRequest) MaxLogLevel(maxLogLevel int32) ApiGetProtectionRunProgressRequest {
	r.maxLogLevel = &maxLogLevel
	return r
}

// Specifies the task path of the run or object run. This is applicable only if progress of a protection group with one or more object is required.If provided this will be used to fetch progress details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
func (r ApiGetProtectionRunProgressRequest) RunTaskPath(runTaskPath string) ApiGetProtectionRunProgressRequest {
	r.runTaskPath = &runTaskPath
	return r
}

// Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch progress details directly without looking actuall task path of the object.
func (r ApiGetProtectionRunProgressRequest) ObjectTaskPaths(objectTaskPaths []string) ApiGetProtectionRunProgressRequest {
	r.objectTaskPaths = &objectTaskPaths
	return r
}

func (r ApiGetProtectionRunProgressRequest) Execute() (*GetProtectionRunProgressBody, *http.Response, error) {
	return r.ApiService.GetProtectionRunProgressExecute(r)
}

/*
GetProtectionRunProgress Get the progress of a run.

Get the progress of a run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runId Specifies a unique run id of the Protection Run.
 @return ApiGetProtectionRunProgressRequest
*/
func (a *ProtectionGroupAPIService) GetProtectionRunProgress(ctx context.Context, runId string) ApiGetProtectionRunProgressRequest {
	return ApiGetProtectionRunProgressRequest{
		ApiService: a,
		ctx: ctx,
		runId: runId,
	}
}

// Execute executes the request
//  @return GetProtectionRunProgressBody
func (a *ProtectionGroupAPIService) GetProtectionRunProgressExecute(r ApiGetProtectionRunProgressRequest) (*GetProtectionRunProgressBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProtectionRunProgressBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetProtectionRunProgress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/runs/{runId}/progress"
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.objects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objects", r.objects, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeFinishedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFinishedTasks", r.includeFinishedTasks, "")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.maxTasksNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxTasksNum", r.maxTasksNum, "")
	}
	if r.excludeObjectDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeObjectDetails", r.excludeObjectDetails, "")
	}
	if r.includeEventLogs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeEventLogs", r.includeEventLogs, "")
	}
	if r.maxLogLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxLogLevel", r.maxLogLevel, "")
	}
	if r.runTaskPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTaskPath", r.runTaskPath, "")
	}
	if r.objectTaskPaths != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectTaskPaths", r.objectTaskPaths, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionRunStatsRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	runId string
	objects *[]int64
	tenantIds *[]string
	includeTenants *bool
	includeFinishedTasks *bool
	startTimeUsecs *int64
	endTimeUsecs *int64
	maxTasksNum *int32
	excludeObjectDetails *bool
	runTaskPath *string
	objectTaskPaths *[]string
}

// Specifies the objects whose stats will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run stats will not be returned and only the stats of the specified objects will be returned.
func (r ApiGetProtectionRunStatsRequest) Objects(objects []int64) ApiGetProtectionRunStatsRequest {
	r.objects = &objects
	return r
}

// TenantIds contains ids of the tenants for which the run is to be returned.
func (r ApiGetProtectionRunStatsRequest) TenantIds(tenantIds []string) ApiGetProtectionRunStatsRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it&#39;s not specified, it is true by default.
func (r ApiGetProtectionRunStatsRequest) IncludeTenants(includeTenants bool) ApiGetProtectionRunStatsRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies whether to return finished tasks. By default only active tasks are returned.
func (r ApiGetProtectionRunStatsRequest) IncludeFinishedTasks(includeFinishedTasks bool) ApiGetProtectionRunStatsRequest {
	r.includeFinishedTasks = &includeFinishedTasks
	return r
}

// Specifies the time after which the stats task starts in Unix epoch Timestamp(in microseconds).
func (r ApiGetProtectionRunStatsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionRunStatsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Specifies the time before which the stats task ends in Unix epoch Timestamp(in microseconds).
func (r ApiGetProtectionRunStatsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionRunStatsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Specifies the maximum number of tasks to return.
func (r ApiGetProtectionRunStatsRequest) MaxTasksNum(maxTasksNum int32) ApiGetProtectionRunStatsRequest {
	r.maxTasksNum = &maxTasksNum
	return r
}

// Specifies whether to return objects. By default all the task tree are returned.
func (r ApiGetProtectionRunStatsRequest) ExcludeObjectDetails(excludeObjectDetails bool) ApiGetProtectionRunStatsRequest {
	r.excludeObjectDetails = &excludeObjectDetails
	return r
}

// Specifies the task path of the run or object run. This is applicable only if stats of a protection group with one or more object is required. If provided this will be used to fetch stats details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
func (r ApiGetProtectionRunStatsRequest) RunTaskPath(runTaskPath string) ApiGetProtectionRunStatsRequest {
	r.runTaskPath = &runTaskPath
	return r
}

// Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch stats details directly without looking actuall task path of the object.
func (r ApiGetProtectionRunStatsRequest) ObjectTaskPaths(objectTaskPaths []string) ApiGetProtectionRunStatsRequest {
	r.objectTaskPaths = &objectTaskPaths
	return r
}

func (r ApiGetProtectionRunStatsRequest) Execute() (*GetProtectionRunStatsBody, *http.Response, error) {
	return r.ApiService.GetProtectionRunStatsExecute(r)
}

/*
GetProtectionRunStats Get the stats for a run.

Get the stats for a run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param runId Specifies a unique run id of the Protection Run.
 @return ApiGetProtectionRunStatsRequest
*/
func (a *ProtectionGroupAPIService) GetProtectionRunStats(ctx context.Context, runId string) ApiGetProtectionRunStatsRequest {
	return ApiGetProtectionRunStatsRequest{
		ApiService: a,
		ctx: ctx,
		runId: runId,
	}
}

// Execute executes the request
//  @return GetProtectionRunStatsBody
func (a *ProtectionGroupAPIService) GetProtectionRunStatsExecute(r ApiGetProtectionRunStatsRequest) (*GetProtectionRunStatsBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProtectionRunStatsBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetProtectionRunStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/runs/{runId}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.runId) > 255 {
		return localVarReturnValue, nil, reportError("runId must have less than 255 elements")
	}

	if r.objects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objects", r.objects, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeFinishedTasks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFinishedTasks", r.includeFinishedTasks, "")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.maxTasksNum != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxTasksNum", r.maxTasksNum, "")
	}
	if r.excludeObjectDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeObjectDetails", r.excludeObjectDetails, "")
	}
	if r.runTaskPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTaskPath", r.runTaskPath, "")
	}
	if r.objectTaskPaths != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectTaskPaths", r.objectTaskPaths, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionRunsRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	startTimeUsecs *int64
	endTimeUsecs *int64
	runStatus *[]string
}

// Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
func (r ApiGetProtectionRunsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionRunsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
func (r ApiGetProtectionRunsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionRunsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Specifies a list of status, runs matching the status will be returned.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetProtectionRunsRequest) RunStatus(runStatus []string) ApiGetProtectionRunsRequest {
	r.runStatus = &runStatus
	return r
}

func (r ApiGetProtectionRunsRequest) Execute() (*ProtectionRunsSummary, *http.Response, error) {
	return r.ApiService.GetProtectionRunsExecute(r)
}

/*
GetProtectionRuns Get the list of runs.

Get a list of protection runs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProtectionRunsRequest
*/
func (a *ProtectionGroupAPIService) GetProtectionRuns(ctx context.Context) ApiGetProtectionRunsRequest {
	return ApiGetProtectionRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectionRunsSummary
func (a *ProtectionGroupAPIService) GetProtectionRunsExecute(r ApiGetProtectionRunsRequest) (*ProtectionRunsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionRunsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetProtectionRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/runs/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.runStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runStatus", r.runStatus, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRunDebugLogsRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	runId string
	objectId *string
}

// Specifies the id of the object for which debug logs are to be returned. 
func (r ApiGetRunDebugLogsRequest) ObjectId(objectId string) ApiGetRunDebugLogsRequest {
	r.objectId = &objectId
	return r
}

func (r ApiGetRunDebugLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRunDebugLogsExecute(r)
}

/*
GetRunDebugLogs Get the debug logs for a run from a Protection Group.

Get the debug logs for all objects of a run for a particular Protection Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @param runId Specifies a unique run id of the Protection Group run.
 @return ApiGetRunDebugLogsRequest
*/
func (a *ProtectionGroupAPIService) GetRunDebugLogs(ctx context.Context, id string, runId string) ApiGetRunDebugLogsRequest {
	return ApiGetRunDebugLogsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		runId: runId,
	}
}

// Execute executes the request
func (a *ProtectionGroupAPIService) GetRunDebugLogsExecute(r ApiGetRunDebugLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetRunDebugLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs/{runId}/debug-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.objectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectId", r.objectId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRunDebugLogsForObjectRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	runId string
	objectId string
}

func (r ApiGetRunDebugLogsForObjectRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRunDebugLogsForObjectExecute(r)
}

/*
GetRunDebugLogsForObject Get the debug logs for a particular object in a run from a Protection Group.

Get the debug logs for a particular object of a run for a particular Protection Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @param runId Specifies a unique run id of the Protection Group run.
 @param objectId Specifies the id of the object for which debug logs are to be returned. 
 @return ApiGetRunDebugLogsForObjectRequest
*/
func (a *ProtectionGroupAPIService) GetRunDebugLogsForObject(ctx context.Context, id string, runId string, objectId string) ApiGetRunDebugLogsForObjectRequest {
	return ApiGetRunDebugLogsForObjectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		runId: runId,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *ProtectionGroupAPIService) GetRunDebugLogsForObjectExecute(r ApiGetRunDebugLogsForObjectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetRunDebugLogsForObject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs/{runId}/objects/{objectId}/debug-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRunMessagesReportRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	runId string
	objectId string
	fileType *string
	name *string
}

// Specifies the downloaded type, i.e: inclusion_exclusion_reports, error_files_list. default: error_files_list
func (r ApiGetRunMessagesReportRequest) FileType(fileType string) ApiGetRunMessagesReportRequest {
	r.fileType = &fileType
	return r
}

// Specifies the name of the source being backed up
func (r ApiGetRunMessagesReportRequest) Name(name string) ApiGetRunMessagesReportRequest {
	r.name = &name
	return r
}

func (r ApiGetRunMessagesReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRunMessagesReportExecute(r)
}

/*
GetRunMessagesReport Get the CSV of various Proto Messages for a given run and an object.

Get an CSV report for given objectId and run id. Each row in CSV report contains the fields from correspoinding proto message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @param runId Specifies a unique run id of the Protection Group run.
 @param objectId Specifies the id of the object for which errors/warnings are to be returned. 
 @return ApiGetRunMessagesReportRequest
*/
func (a *ProtectionGroupAPIService) GetRunMessagesReport(ctx context.Context, id string, runId string, objectId string) ApiGetRunMessagesReportRequest {
	return ApiGetRunMessagesReportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		runId: runId,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *ProtectionGroupAPIService) GetRunMessagesReportExecute(r ApiGetRunMessagesReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetRunMessagesReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs/{runId}/objects/{objectId}/download-messages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileType", r.fileType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRunsReportRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	runId string
	objectId string
	fileType *string
	name *string
}

// Specifies the downloaded type, i.e: success_files_list, default: success_files_list
func (r ApiGetRunsReportRequest) FileType(fileType string) ApiGetRunsReportRequest {
	r.fileType = &fileType
	return r
}

// Specifies the name of the source being backed up
func (r ApiGetRunsReportRequest) Name(name string) ApiGetRunsReportRequest {
	r.name = &name
	return r
}

func (r ApiGetRunsReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRunsReportExecute(r)
}

/*
GetRunsReport Get the CSV of errors/warnings for a given run and an object.

Get an CSV report for given objectId and run id. Report will depend on the query parameter fileType, default will be: success_files_list where each row contains the name of file backedup successfully.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @param runId Specifies a unique run id of the Protection Group run.
 @param objectId Specifies the id of the object for which errors/warnings are to be returned. 
 @return ApiGetRunsReportRequest
*/
func (a *ProtectionGroupAPIService) GetRunsReport(ctx context.Context, id string, runId string, objectId string) ApiGetRunsReportRequest {
	return ApiGetRunsReportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		runId: runId,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *ProtectionGroupAPIService) GetRunsReportExecute(r ApiGetRunsReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.GetRunsReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs/{runId}/objects/{objectId}/downloadFiles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileType", r.fileType, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPerformActionOnProtectionGroupRunRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	body *PerformActionOnProtectionGroupRunRequest
}

// Specifies the parameters to perform an action on a protection run.
func (r ApiPerformActionOnProtectionGroupRunRequest) Body(body PerformActionOnProtectionGroupRunRequest) ApiPerformActionOnProtectionGroupRunRequest {
	r.body = &body
	return r
}

func (r ApiPerformActionOnProtectionGroupRunRequest) Execute() (*PerformRunActionResponse, *http.Response, error) {
	return r.ApiService.PerformActionOnProtectionGroupRunExecute(r)
}

/*
PerformActionOnProtectionGroupRun Actions on protection group run.

Perform various actions on a Protection Group run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @return ApiPerformActionOnProtectionGroupRunRequest
*/
func (a *ProtectionGroupAPIService) PerformActionOnProtectionGroupRun(ctx context.Context, id string) ApiPerformActionOnProtectionGroupRunRequest {
	return ApiPerformActionOnProtectionGroupRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PerformRunActionResponse
func (a *ProtectionGroupAPIService) PerformActionOnProtectionGroupRunExecute(r ApiPerformActionOnProtectionGroupRunRequest) (*PerformRunActionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PerformRunActionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.PerformActionOnProtectionGroupRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProtectionGroupRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	body *CreateOrUpdateProtectionGroupRequest
}

// Specifies the parameters to update a Protection Group.
func (r ApiUpdateProtectionGroupRequest) Body(body CreateOrUpdateProtectionGroupRequest) ApiUpdateProtectionGroupRequest {
	r.body = &body
	return r
}

func (r ApiUpdateProtectionGroupRequest) Execute() (*ProtectionGroup, *http.Response, error) {
	return r.ApiService.UpdateProtectionGroupExecute(r)
}

/*
UpdateProtectionGroup Update a Protection Group.

Update the specified Protection Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Protection Group.
 @return ApiUpdateProtectionGroupRequest
*/
func (a *ProtectionGroupAPIService) UpdateProtectionGroup(ctx context.Context, id string) ApiUpdateProtectionGroupRequest {
	return ApiUpdateProtectionGroupRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectionGroup
func (a *ProtectionGroupAPIService) UpdateProtectionGroupExecute(r ApiUpdateProtectionGroupRequest) (*ProtectionGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectionGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.UpdateProtectionGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProtectionGroupRunRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	id string
	body *UpdateProtectionGroupRunRequestBody
}

// Specifies the parameters to update a Protection Group Run.
func (r ApiUpdateProtectionGroupRunRequest) Body(body UpdateProtectionGroupRunRequestBody) ApiUpdateProtectionGroupRunRequest {
	r.body = &body
	return r
}

func (r ApiUpdateProtectionGroupRunRequest) Execute() (*UpdateProtectionGroupRunResponseBody, *http.Response, error) {
	return r.ApiService.UpdateProtectionGroupRunExecute(r)
}

/*
UpdateProtectionGroupRun Update runs for a particular Protection Group.

Update runs for a particular Protection Group. A user can perform the following actions: 1. Extend or reduce retention of a local, replication and archival snapshots. 2. Can perform resync operation on failed copy snapshots attempts in this Run. 3. Add new replication and archival snapshot targets to the Run. 4. Add or remove legal hold on the snapshots. Only a user with DSO role can perform this operation. 5. Delete the snapshots that were created as a part of this Run. 6. Apply datalock on existing snapshots where a user cannot manually delete snapshots before the expiry time. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Protection Group.
 @return ApiUpdateProtectionGroupRunRequest
*/
func (a *ProtectionGroupAPIService) UpdateProtectionGroupRun(ctx context.Context, id string) ApiUpdateProtectionGroupRunRequest {
	return ApiUpdateProtectionGroupRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UpdateProtectionGroupRunResponseBody
func (a *ProtectionGroupAPIService) UpdateProtectionGroupRunExecute(r ApiUpdateProtectionGroupRunRequest) (*UpdateProtectionGroupRunResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateProtectionGroupRunResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.UpdateProtectionGroupRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/{id}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProtectionGroupsStateRequest struct {
	ctx context.Context
	ApiService *ProtectionGroupAPIService
	body *UpdateProtectionGroupsStateRequest
}

// Specifies the parameters to perform an action of list of Protection Groups.
func (r ApiUpdateProtectionGroupsStateRequest) Body(body UpdateProtectionGroupsStateRequest) ApiUpdateProtectionGroupsStateRequest {
	r.body = &body
	return r
}

func (r ApiUpdateProtectionGroupsStateRequest) Execute() (*UpdateProtectionGroupsState, *http.Response, error) {
	return r.ApiService.UpdateProtectionGroupsStateExecute(r)
}

/*
UpdateProtectionGroupsState Perform an action like pause, resume, active, deactivate on all specified Protection Groups.

Perform an action like pause, resume, active, deactivate on all specified Protection Groups. Note that the pause or resume actions will take effect from next Protection Run. Also, user can specify only one type of action on all the Protection Groups. Deactivate and activate actions are independent of pause and resume state. Deactivate and activate actions are useful in case of failover situations. Returns success if the state of all the Protection Groups state is changed successfully.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateProtectionGroupsStateRequest
*/
func (a *ProtectionGroupAPIService) UpdateProtectionGroupsState(ctx context.Context) ApiUpdateProtectionGroupsStateRequest {
	return ApiUpdateProtectionGroupsStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateProtectionGroupsState
func (a *ProtectionGroupAPIService) UpdateProtectionGroupsStateExecute(r ApiUpdateProtectionGroupsStateRequest) (*UpdateProtectionGroupsState, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateProtectionGroupsState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionGroupAPIService.UpdateProtectionGroupsState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/protection-groups/states"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
