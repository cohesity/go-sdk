/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ExternalTargetAPIService ExternalTargetAPI service
type ExternalTargetAPIService service

type ApiCreateExternalTargetRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	body *ExternalTarget
}

// Specifies the parameters to create a External Target.
func (r ApiCreateExternalTargetRequest) Body(body ExternalTarget) ApiCreateExternalTargetRequest {
	r.body = &body
	return r
}

func (r ApiCreateExternalTargetRequest) Execute() (*ExternalTarget, *http.Response, error) {
	return r.ApiService.CreateExternalTargetExecute(r)
}

/*
CreateExternalTarget Create a External Target.

Create a External Target.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateExternalTargetRequest
*/
func (a *ExternalTargetAPIService) CreateExternalTarget(ctx context.Context) ApiCreateExternalTargetRequest {
	return ApiCreateExternalTargetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExternalTarget
func (a *ExternalTargetAPIService) CreateExternalTargetExecute(r ApiCreateExternalTargetRequest) (*ExternalTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.CreateExternalTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteExternalTargetRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	id int64
	forceDelete *bool
}

// Specifies whether to force delete the External target.
func (r ApiDeleteExternalTargetRequest) ForceDelete(forceDelete bool) ApiDeleteExternalTargetRequest {
	r.forceDelete = &forceDelete
	return r
}

func (r ApiDeleteExternalTargetRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExternalTargetExecute(r)
}

/*
DeleteExternalTarget Delete a External Target.

Returns Success if the External Target is deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the External Target.
 @return ApiDeleteExternalTargetRequest
*/
func (a *ExternalTargetAPIService) DeleteExternalTarget(ctx context.Context, id int64) ApiDeleteExternalTargetRequest {
	return ApiDeleteExternalTargetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalTargetAPIService) DeleteExternalTargetExecute(r ApiDeleteExternalTargetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.DeleteExternalTarget")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDelete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDelete", r.forceDelete, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetExternalTargetByIdRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	id int64
}

func (r ApiGetExternalTargetByIdRequest) Execute() (*ExternalTarget, *http.Response, error) {
	return r.ApiService.GetExternalTargetByIdExecute(r)
}

/*
GetExternalTargetById List details about single External Target.

Returns the External Target corresponding to the specified Group id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the External Target.
 @return ApiGetExternalTargetByIdRequest
*/
func (a *ExternalTargetAPIService) GetExternalTargetById(ctx context.Context, id int64) ApiGetExternalTargetByIdRequest {
	return ApiGetExternalTargetByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalTarget
func (a *ExternalTargetAPIService) GetExternalTargetByIdExecute(r ApiGetExternalTargetByIdRequest) (*ExternalTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.GetExternalTargetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTargetEncryptionKeyInfoRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	id int64
}

func (r ApiGetExternalTargetEncryptionKeyInfoRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetExternalTargetEncryptionKeyInfoExecute(r)
}

/*
GetExternalTargetEncryptionKeyInfo Get the encryption key info for an external target

Get the encryption key info for an external target

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the External Target.
 @return ApiGetExternalTargetEncryptionKeyInfoRequest
*/
func (a *ExternalTargetAPIService) GetExternalTargetEncryptionKeyInfo(ctx context.Context, id int64) ApiGetExternalTargetEncryptionKeyInfoRequest {
	return ApiGetExternalTargetEncryptionKeyInfoRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ExternalTargetAPIService) GetExternalTargetEncryptionKeyInfoExecute(r ApiGetExternalTargetEncryptionKeyInfoRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.GetExternalTargetEncryptionKeyInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets/{id}/encryption-key"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTargetMediaInfoRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	clusterId *int64
	clusterIncarnationId *int64
	archivalJobId *int64
	restoreTaskId *int64
	entityIds *[]int64
}

// Specifies the id of the Cohesity cluster which archived to a QStart media target.
func (r ApiGetExternalTargetMediaInfoRequest) ClusterId(clusterId int64) ApiGetExternalTargetMediaInfoRequest {
	r.clusterId = &clusterId
	return r
}

// Specifies the incarnation Id of the Cohesity cluster which archived to a QStart media target.
func (r ApiGetExternalTargetMediaInfoRequest) ClusterIncarnationId(clusterIncarnationId int64) ApiGetExternalTargetMediaInfoRequest {
	r.clusterIncarnationId = &clusterIncarnationId
	return r
}

// Specifies the id of the Job that archived to a QStar media Vault.
func (r ApiGetExternalTargetMediaInfoRequest) ArchivalJobId(archivalJobId int64) ApiGetExternalTargetMediaInfoRequest {
	r.archivalJobId = &archivalJobId
	return r
}

// Specifies the id of the restore task to optionally filter by.
func (r ApiGetExternalTargetMediaInfoRequest) RestoreTaskId(restoreTaskId int64) ApiGetExternalTargetMediaInfoRequest {
	r.restoreTaskId = &restoreTaskId
	return r
}

// Specifies an array of entityIds to optionally filter by. An entityId is a unique id for a VM assigned by the Cohesity Cluster.
func (r ApiGetExternalTargetMediaInfoRequest) EntityIds(entityIds []int64) ApiGetExternalTargetMediaInfoRequest {
	r.entityIds = &entityIds
	return r
}

func (r ApiGetExternalTargetMediaInfoRequest) Execute() (*ArchivalMediaInfo, *http.Response, error) {
	return r.ApiService.GetExternalTargetMediaInfoExecute(r)
}

/*
GetExternalTargetMediaInfo List archive media information

Returns the media information about the specified archive service uid (such as a QStar tape archive service).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExternalTargetMediaInfoRequest
*/
func (a *ExternalTargetAPIService) GetExternalTargetMediaInfo(ctx context.Context) ApiGetExternalTargetMediaInfoRequest {
	return ApiGetExternalTargetMediaInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArchivalMediaInfo
func (a *ExternalTargetAPIService) GetExternalTargetMediaInfoExecute(r ApiGetExternalTargetMediaInfoRequest) (*ArchivalMediaInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArchivalMediaInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.GetExternalTargetMediaInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets/media-info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return localVarReturnValue, nil, reportError("clusterId is required and must be specified")
	}
	if r.clusterIncarnationId == nil {
		return localVarReturnValue, nil, reportError("clusterIncarnationId is required and must be specified")
	}
	if r.archivalJobId == nil {
		return localVarReturnValue, nil, reportError("archivalJobId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "clusterId", r.clusterId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "clusterIncarnationId", r.clusterIncarnationId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "archivalJobId", r.archivalJobId, "")
	if r.restoreTaskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restoreTaskId", r.restoreTaskId, "")
	}
	if r.entityIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", r.entityIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTargetSettingsRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
}

func (r ApiGetExternalTargetSettingsRequest) Execute() (*ExternalTarget, *http.Response, error) {
	return r.ApiService.GetExternalTargetSettingsExecute(r)
}

/*
GetExternalTargetSettings Get the list of External Target Settings.

Get the list of External Target Settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExternalTargetSettingsRequest
*/
func (a *ExternalTargetAPIService) GetExternalTargetSettings(ctx context.Context) ApiGetExternalTargetSettingsRequest {
	return ApiGetExternalTargetSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExternalTarget
func (a *ExternalTargetAPIService) GetExternalTargetSettingsExecute(r ApiGetExternalTargetSettingsRequest) (*ExternalTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.GetExternalTargetSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalTargetsRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	ids *[]int64
	globalIds *[]string
	names *[]string
	purposeTypes *[]string
	storageTypes *[]string
	storageClasses *[]string
	ownershipContexts *[]string
}

// Filter by a list of External Target ids.
func (r ApiGetExternalTargetsRequest) Ids(ids []int64) ApiGetExternalTargetsRequest {
	r.ids = &ids
	return r
}

// Filter by a list of External Target global ids.
func (r ApiGetExternalTargetsRequest) GlobalIds(globalIds []string) ApiGetExternalTargetsRequest {
	r.globalIds = &globalIds
	return r
}

// Filter by a list of External Target names.
func (r ApiGetExternalTargetsRequest) Names(names []string) ApiGetExternalTargetsRequest {
	r.names = &names
	return r
}

// Filter by a list of External Target purpose types.
func (r ApiGetExternalTargetsRequest) PurposeTypes(purposeTypes []string) ApiGetExternalTargetsRequest {
	r.purposeTypes = &purposeTypes
	return r
}

// Filter by a list of External Target storage types. Nas option in archival_target_storage_type will soon be deprecated. Please use NAS instead.
func (r ApiGetExternalTargetsRequest) StorageTypes(storageTypes []string) ApiGetExternalTargetsRequest {
	r.storageTypes = &storageTypes
	return r
}

// Filter by a list of External Target storage classes.
func (r ApiGetExternalTargetsRequest) StorageClasses(storageClasses []string) ApiGetExternalTargetsRequest {
	r.storageClasses = &storageClasses
	return r
}

// Specifies whether how this external target is being consumed either Local or FortKnox.
func (r ApiGetExternalTargetsRequest) OwnershipContexts(ownershipContexts []string) ApiGetExternalTargetsRequest {
	r.ownershipContexts = &ownershipContexts
	return r
}

func (r ApiGetExternalTargetsRequest) Execute() (*ExternalTargets, *http.Response, error) {
	return r.ApiService.GetExternalTargetsExecute(r)
}

/*
GetExternalTargets Get the list of External Targets.

Get the list of External Targets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetExternalTargetsRequest
*/
func (a *ExternalTargetAPIService) GetExternalTargets(ctx context.Context) ApiGetExternalTargetsRequest {
	return ApiGetExternalTargetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ExternalTargets
func (a *ExternalTargetAPIService) GetExternalTargetsExecute(r ApiGetExternalTargetsRequest) (*ExternalTargets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalTargets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.GetExternalTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.globalIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globalIds", r.globalIds, "csv")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "csv")
	}
	if r.purposeTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purposeTypes", r.purposeTypes, "csv")
	}
	if r.storageTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageTypes", r.storageTypes, "csv")
	}
	if r.storageClasses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageClasses", r.storageClasses, "csv")
	}
	if r.ownershipContexts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownershipContexts", r.ownershipContexts, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExternalTargetRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	id int64
	body *ExternalTarget
}

// Specifies the parameters to update a External Target.
func (r ApiUpdateExternalTargetRequest) Body(body ExternalTarget) ApiUpdateExternalTargetRequest {
	r.body = &body
	return r
}

func (r ApiUpdateExternalTargetRequest) Execute() (*ExternalTarget, *http.Response, error) {
	return r.ApiService.UpdateExternalTargetExecute(r)
}

/*
UpdateExternalTarget Update a External Target.

Update the specified External Target.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the External Target.
 @return ApiUpdateExternalTargetRequest
*/
func (a *ExternalTargetAPIService) UpdateExternalTarget(ctx context.Context, id int64) ApiUpdateExternalTargetRequest {
	return ApiUpdateExternalTargetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalTarget
func (a *ExternalTargetAPIService) UpdateExternalTargetExecute(r ApiUpdateExternalTargetRequest) (*ExternalTarget, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalTarget
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.UpdateExternalTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateExternalTargetSettingsRequest struct {
	ctx context.Context
	ApiService *ExternalTargetAPIService
	body *GlobalBandwidthSettings
}

// Specifies the parameters to update a External Target Settings.
func (r ApiUpdateExternalTargetSettingsRequest) Body(body GlobalBandwidthSettings) ApiUpdateExternalTargetSettingsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateExternalTargetSettingsRequest) Execute() (*GlobalBandwidthSettings, *http.Response, error) {
	return r.ApiService.UpdateExternalTargetSettingsExecute(r)
}

/*
UpdateExternalTargetSettings Update External Target Settings

Update External Target Settings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateExternalTargetSettingsRequest
*/
func (a *ExternalTargetAPIService) UpdateExternalTargetSettings(ctx context.Context) ApiUpdateExternalTargetSettingsRequest {
	return ApiUpdateExternalTargetSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GlobalBandwidthSettings
func (a *ExternalTargetAPIService) UpdateExternalTargetSettingsExecute(r ApiUpdateExternalTargetSettingsRequest) (*GlobalBandwidthSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GlobalBandwidthSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalTargetAPIService.UpdateExternalTargetSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/external-targets/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
