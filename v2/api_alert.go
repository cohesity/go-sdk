/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AlertAPIService AlertAPI service
type AlertAPIService service

type ApiGetAlertSummaryRequest struct {
	ctx context.Context
	ApiService *AlertAPIService
	startTimeUsecs *int64
	endTimeUsecs *int64
	includeTenants *bool
	tenantIds *[]string
	statesList *[]string
}

// Filter by start time. Specify the start time as a Unix epoch Timestamp (in microseconds). By default it is current time minus a day.
func (r ApiGetAlertSummaryRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetAlertSummaryRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Filter by end time. Specify the end time as a Unix epoch Timestamp (in microseconds). By default it is current time.
func (r ApiGetAlertSummaryRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetAlertSummaryRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// IncludeTenants specifies if alerts of all the tenants under the hierarchy of the logged in user&#39;s organization should be used to compute summary.
func (r ApiGetAlertSummaryRequest) IncludeTenants(includeTenants bool) ApiGetAlertSummaryRequest {
	r.includeTenants = &includeTenants
	return r
}

// TenantIds contains ids of the tenants for which alerts are to be used to compute summary.
func (r ApiGetAlertSummaryRequest) TenantIds(tenantIds []string) ApiGetAlertSummaryRequest {
	r.tenantIds = &tenantIds
	return r
}

// Specifies list of alert states to filter alerts by. If not specified, only open alerts will be used to get summary.
func (r ApiGetAlertSummaryRequest) StatesList(statesList []string) ApiGetAlertSummaryRequest {
	r.statesList = &statesList
	return r
}

func (r ApiGetAlertSummaryRequest) Execute() (*AlertsSummaryResponse, *http.Response, error) {
	return r.ApiService.GetAlertSummaryExecute(r)
}

/*
GetAlertSummary Get alerts summary.

Get alerts summary grouped by category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAlertSummaryRequest
*/
func (a *AlertAPIService) GetAlertSummary(ctx context.Context) ApiGetAlertSummaryRequest {
	return ApiGetAlertSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertsSummaryResponse
func (a *AlertAPIService) GetAlertSummaryExecute(r ApiGetAlertSummaryRequest) (*AlertsSummaryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertsSummaryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertAPIService.GetAlertSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.statesList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statesList", r.statesList, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertsRequest struct {
	ctx context.Context
	ApiService *AlertAPIService
	alertIds *[]string
	alertTypes *[]int32
	alertCategories *[]string
	alertStates *[]string
	alertSeverities *[]string
	alertTypeBuckets *[]string
	startTimeUsecs *int64
	endTimeUsecs *int64
	maxAlerts *int32
	propertyKey *string
	propertyValue *string
	alertName *string
	resolutionIds *[]int64
	tenantIds *[]string
	allUnderHierarchy *bool
}

// Filter by list of alert ids.
func (r ApiGetAlertsRequest) AlertIds(alertIds []string) ApiGetAlertsRequest {
	r.alertIds = &alertIds
	return r
}

// Filter by list of alert types.
func (r ApiGetAlertsRequest) AlertTypes(alertTypes []int32) ApiGetAlertsRequest {
	r.alertTypes = &alertTypes
	return r
}

// Filter by list of alert categories.
func (r ApiGetAlertsRequest) AlertCategories(alertCategories []string) ApiGetAlertsRequest {
	r.alertCategories = &alertCategories
	return r
}

// Filter by list of alert states.
func (r ApiGetAlertsRequest) AlertStates(alertStates []string) ApiGetAlertsRequest {
	r.alertStates = &alertStates
	return r
}

// Filter by list of alert severity types.
func (r ApiGetAlertsRequest) AlertSeverities(alertSeverities []string) ApiGetAlertsRequest {
	r.alertSeverities = &alertSeverities
	return r
}

// Filter by list of alert type buckets.
func (r ApiGetAlertsRequest) AlertTypeBuckets(alertTypeBuckets []string) ApiGetAlertsRequest {
	r.alertTypeBuckets = &alertTypeBuckets
	return r
}

// Specifies start time Unix epoch time in microseconds to filter alerts by.
func (r ApiGetAlertsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetAlertsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Specifies end time Unix epoch time in microseconds to filter alerts by.
func (r ApiGetAlertsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetAlertsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Specifies maximum number of alerts to return.The default value is 100 and maximum allowed value is 1000
func (r ApiGetAlertsRequest) MaxAlerts(maxAlerts int32) ApiGetAlertsRequest {
	r.maxAlerts = &maxAlerts
	return r
}

// Specifies name of the property to filter alerts by.
func (r ApiGetAlertsRequest) PropertyKey(propertyKey string) ApiGetAlertsRequest {
	r.propertyKey = &propertyKey
	return r
}

// Specifies value of the property to filter alerts by.
func (r ApiGetAlertsRequest) PropertyValue(propertyValue string) ApiGetAlertsRequest {
	r.propertyValue = &propertyValue
	return r
}

// Specifies name of alert to filter alerts by.
func (r ApiGetAlertsRequest) AlertName(alertName string) ApiGetAlertsRequest {
	r.alertName = &alertName
	return r
}

// Specifies alert resolution ids to filter alerts by.
func (r ApiGetAlertsRequest) ResolutionIds(resolutionIds []int64) ApiGetAlertsRequest {
	r.resolutionIds = &resolutionIds
	return r
}

// Filter by tenant ids.
func (r ApiGetAlertsRequest) TenantIds(tenantIds []string) ApiGetAlertsRequest {
	r.tenantIds = &tenantIds
	return r
}

// Filter by objects of all the tenants under the hierarchy of the logged in user&#39;s organization.
func (r ApiGetAlertsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetAlertsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}

func (r ApiGetAlertsRequest) Execute() (*AlertList, *http.Response, error) {
	return r.ApiService.GetAlertsExecute(r)
}

/*
GetAlerts Get alerts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAlertsRequest
*/
func (a *AlertAPIService) GetAlerts(ctx context.Context) ApiGetAlertsRequest {
	return ApiGetAlertsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertList
func (a *AlertAPIService) GetAlertsExecute(r ApiGetAlertsRequest) (*AlertList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertAPIService.GetAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.alertIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertIds", r.alertIds, "csv")
	}
	if r.alertTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertTypes", r.alertTypes, "csv")
	}
	if r.alertCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertCategories", r.alertCategories, "csv")
	}
	if r.alertStates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertStates", r.alertStates, "csv")
	}
	if r.alertSeverities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertSeverities", r.alertSeverities, "csv")
	}
	if r.alertTypeBuckets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertTypeBuckets", r.alertTypeBuckets, "csv")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.maxAlerts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAlerts", r.maxAlerts, "")
	}
	if r.propertyKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertyKey", r.propertyKey, "")
	}
	if r.propertyValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "propertyValue", r.propertyValue, "")
	}
	if r.alertName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alertName", r.alertName, "")
	}
	if r.resolutionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolutionIds", r.resolutionIds, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.allUnderHierarchy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allUnderHierarchy", r.allUnderHierarchy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
