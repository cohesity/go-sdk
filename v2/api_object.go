/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ObjectAPIService ObjectAPI service
type ObjectAPIService service

type ApiAssociateEntityMetadataRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	body *AssociateEntityMetadataRequest
}

// Specifies the parameters to associate metadata with entities in the entity hierarchy.
func (r ApiAssociateEntityMetadataRequest) Body(body AssociateEntityMetadataRequest) ApiAssociateEntityMetadataRequest {
	r.body = &body
	return r
}

func (r ApiAssociateEntityMetadataRequest) Execute() (*AssociateEntityMetadataResult, *http.Response, error) {
	return r.ApiService.AssociateEntityMetadataExecute(r)
}

/*
AssociateEntityMetadata Associate Metadata with Entity

Associates metadata with entities in the entity hierarchy. This metadata can be of various types (eg. Credentials). Returns a list of entity id and corresponding errors encountered (if any) while associating metadata with that entity. Note that a partial success response is possible where we succeed in associating metadata with some of the entities but fail for others. The API also expects the entities being updated belong to same source.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAssociateEntityMetadataRequest
*/
func (a *ObjectAPIService) AssociateEntityMetadata(ctx context.Context) ApiAssociateEntityMetadataRequest {
	return ApiAssociateEntityMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AssociateEntityMetadataResult
func (a *ObjectAPIService) AssociateEntityMetadataExecute(r ApiAssociateEntityMetadataRequest) (*AssociateEntityMetadataResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssociateEntityMetadataResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.AssociateEntityMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBrowseObjectContentsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	body *ObjectBrowseRequest
}

// Specifies the parameters to fetch contents of an object.
func (r ApiBrowseObjectContentsRequest) Body(body ObjectBrowseRequest) ApiBrowseObjectContentsRequest {
	r.body = &body
	return r
}

func (r ApiBrowseObjectContentsRequest) Execute() (*FileFolderInfo, *http.Response, error) {
	return r.ApiService.BrowseObjectContentsExecute(r)
}

/*
BrowseObjectContents Fetch the contents (files & folders) for the specified object.

Fetch the contents (files & folders) of the specified path inside the specified object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Object.
 @return ApiBrowseObjectContentsRequest
*/
func (a *ObjectAPIService) BrowseObjectContents(ctx context.Context, id int64) ApiBrowseObjectContentsRequest {
	return ApiBrowseObjectContentsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FileFolderInfo
func (a *ObjectAPIService) BrowseObjectContentsExecute(r ApiBrowseObjectContentsRequest) (*FileFolderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileFolderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.BrowseObjectContents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/browse"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelObjectRunsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	body *CancelObjectRunsRequest
}

// Specifies the parameters to cancel object runs.
func (r ApiCancelObjectRunsRequest) Body(body CancelObjectRunsRequest) ApiCancelObjectRunsRequest {
	r.body = &body
	return r
}

func (r ApiCancelObjectRunsRequest) Execute() (*CancelObjectRunsResults, *http.Response, error) {
	return r.ApiService.CancelObjectRunsExecute(r)
}

/*
CancelObjectRuns Cancel object runs.

Cancel object runs for object based protection. This does not apply to Group based protection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelObjectRunsRequest
*/
func (a *ObjectAPIService) CancelObjectRuns(ctx context.Context) ApiCancelObjectRunsRequest {
	return ApiCancelObjectRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CancelObjectRunsResults
func (a *ObjectAPIService) CancelObjectRunsExecute(r ApiCancelObjectRunsRequest) (*CancelObjectRunsResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelObjectRunsResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.CancelObjectRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/runs/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConstructMetaInfoRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	snapshotId string
	body *ConstructMetaInfoRequest
}

// Specifies the parameters to construct meta info for desired workflow.
func (r ApiConstructMetaInfoRequest) Body(body ConstructMetaInfoRequest) ApiConstructMetaInfoRequest {
	r.body = &body
	return r
}

func (r ApiConstructMetaInfoRequest) Execute() (*ConstructMetaInfoResult, *http.Response, error) {
	return r.ApiService.ConstructMetaInfoExecute(r)
}

/*
ConstructMetaInfo Construct meta info for any workflow from object snapshot and some other information.

Construct meta info from object snapshot and some additional params.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param snapshotId Specifies the snapshot id.
 @return ApiConstructMetaInfoRequest
*/
func (a *ObjectAPIService) ConstructMetaInfo(ctx context.Context, snapshotId string) ApiConstructMetaInfoRequest {
	return ApiConstructMetaInfoRequest{
		ApiService: a,
		ctx: ctx,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return ConstructMetaInfoResult
func (a *ObjectAPIService) ConstructMetaInfoExecute(r ApiConstructMetaInfoRequest) (*ConstructMetaInfoResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConstructMetaInfoResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.ConstructMetaInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/snapshots/{snapshotId}/meta-info"
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEntityMetadataRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	metadataType *string
	environmentType *string
}

// Specifies the metadata type to be deleted. This is a required field currently and the API will error out if this field is not provided.
func (r ApiDeleteEntityMetadataRequest) MetadataType(metadataType string) ApiDeleteEntityMetadataRequest {
	r.metadataType = &metadataType
	return r
}

// Specifies the environment type for the Credentials metadata to be deleted. This will be only set when the metadata type is Credentials.
func (r ApiDeleteEntityMetadataRequest) EnvironmentType(environmentType string) ApiDeleteEntityMetadataRequest {
	r.environmentType = &environmentType
	return r
}

func (r ApiDeleteEntityMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEntityMetadataExecute(r)
}

/*
DeleteEntityMetadata Delete Metadata with Entity

Deletes entity metadata for the given entity Id. Currently only supported for RDS and Aurora Postgres Credential metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Entity.
 @return ApiDeleteEntityMetadataRequest
*/
func (a *ObjectAPIService) DeleteEntityMetadata(ctx context.Context, id int64) ApiDeleteEntityMetadataRequest {
	return ApiDeleteEntityMetadataRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ObjectAPIService) DeleteEntityMetadataExecute(r ApiDeleteEntityMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.DeleteEntityMetadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/metadata/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metadataType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadataType", r.metadataType, "")
	}
	if r.environmentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environmentType", r.environmentType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFilterObjectsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	body *FilterObjectsRequest
}

// Specifies the parameters to filter objects.
func (r ApiFilterObjectsRequest) Body(body FilterObjectsRequest) ApiFilterObjectsRequest {
	r.body = &body
	return r
}

func (r ApiFilterObjectsRequest) Execute() (*FilteredObjectsResponseBody, *http.Response, error) {
	return r.ApiService.FilterObjectsExecute(r)
}

/*
FilterObjects List all the filtered objects.

List all the filtered objects using given regular expressions and wildcard supported search strings. We are currenly supporting this for only SQL adapter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFilterObjectsRequest
*/
func (a *ObjectAPIService) FilterObjects(ctx context.Context) ApiFilterObjectsRequest {
	return ApiFilterObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilteredObjectsResponseBody
func (a *ObjectAPIService) FilterObjectsExecute(r ApiFilterObjectsRequest) (*FilteredObjectsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilteredObjectsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.FilterObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/filter/objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllIndexedObjectSnapshotsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	objectId int64
	indexedObjectName *string
	protectionGroupId *string
	includeIndexedSnapshotsOnly *bool
	fromTimeUsecs *int64
	toTimeUsecs *int64
	runTypes *[]string
	useCachedData *bool
	objectActionKey *string
}

// Specifies the indexed object name.
func (r ApiGetAllIndexedObjectSnapshotsRequest) IndexedObjectName(indexedObjectName string) ApiGetAllIndexedObjectSnapshotsRequest {
	r.indexedObjectName = &indexedObjectName
	return r
}

// Specifies the protection group id.
func (r ApiGetAllIndexedObjectSnapshotsRequest) ProtectionGroupId(protectionGroupId string) ApiGetAllIndexedObjectSnapshotsRequest {
	r.protectionGroupId = &protectionGroupId
	return r
}

// Specifies whether to only return snapshots which are indexed. In an indexed snapshot files are guaranteed to exist, while in a non-indexed snapshot files may not exist.
func (r ApiGetAllIndexedObjectSnapshotsRequest) IncludeIndexedSnapshotsOnly(includeIndexedSnapshotsOnly bool) ApiGetAllIndexedObjectSnapshotsRequest {
	r.includeIndexedSnapshotsOnly = &includeIndexedSnapshotsOnly
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter indexed object&#39;s snapshots which are taken after this value.
func (r ApiGetAllIndexedObjectSnapshotsRequest) FromTimeUsecs(fromTimeUsecs int64) ApiGetAllIndexedObjectSnapshotsRequest {
	r.fromTimeUsecs = &fromTimeUsecs
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter indexed object&#39;s snapshots which are taken before this value.
func (r ApiGetAllIndexedObjectSnapshotsRequest) ToTimeUsecs(toTimeUsecs int64) ApiGetAllIndexedObjectSnapshotsRequest {
	r.toTimeUsecs = &toTimeUsecs
	return r
}

// Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
func (r ApiGetAllIndexedObjectSnapshotsRequest) RunTypes(runTypes []string) ApiGetAllIndexedObjectSnapshotsRequest {
	r.runTypes = &runTypes
	return r
}

// Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetAllIndexedObjectSnapshotsRequest) UseCachedData(useCachedData bool) ApiGetAllIndexedObjectSnapshotsRequest {
	r.useCachedData = &useCachedData
	return r
}

// Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
func (r ApiGetAllIndexedObjectSnapshotsRequest) ObjectActionKey(objectActionKey string) ApiGetAllIndexedObjectSnapshotsRequest {
	r.objectActionKey = &objectActionKey
	return r
}

func (r ApiGetAllIndexedObjectSnapshotsRequest) Execute() (*GetIndexedObjectSnapshotsResponseBody, *http.Response, error) {
	return r.ApiService.GetAllIndexedObjectSnapshotsExecute(r)
}

/*
GetAllIndexedObjectSnapshots Get snapshots of indexed object.

Get snapshots of indexed object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId Specifies the object id.
 @return ApiGetAllIndexedObjectSnapshotsRequest
*/
func (a *ObjectAPIService) GetAllIndexedObjectSnapshots(ctx context.Context, objectId int64) ApiGetAllIndexedObjectSnapshotsRequest {
	return ApiGetAllIndexedObjectSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return GetIndexedObjectSnapshotsResponseBody
func (a *ObjectAPIService) GetAllIndexedObjectSnapshotsExecute(r ApiGetAllIndexedObjectSnapshotsRequest) (*GetIndexedObjectSnapshotsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIndexedObjectSnapshotsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetAllIndexedObjectSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{objectId}/indexed-objects/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.indexedObjectName == nil {
		return localVarReturnValue, nil, reportError("indexedObjectName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "indexedObjectName", r.indexedObjectName, "")
	if r.protectionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectionGroupId", r.protectionGroupId, "")
	}
	if r.includeIndexedSnapshotsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeIndexedSnapshotsOnly", r.includeIndexedSnapshotsOnly, "")
	} else {
		var defaultValue bool = false
		r.includeIndexedSnapshotsOnly = &defaultValue
	}
	if r.fromTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTimeUsecs", r.fromTimeUsecs, "")
	}
	if r.toTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTimeUsecs", r.toTimeUsecs, "")
	}
	if r.runTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTypes", r.runTypes, "csv")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	if r.objectActionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectActionKey", r.objectActionKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEntityMetadataRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	sourceId int64
	entityIds *[]int64
}

// EntityIds contains ids of the entities for which objects are to be returned.
func (r ApiGetEntityMetadataRequest) EntityIds(entityIds []int64) ApiGetEntityMetadataRequest {
	r.entityIds = &entityIds
	return r
}

func (r ApiGetEntityMetadataRequest) Execute() (*GetEntityMetadataResult, *http.Response, error) {
	return r.ApiService.GetEntityMetadataExecute(r)
}

/*
GetEntityMetadata Get Metadata of Entities

Gets entity metadata for entities. This can be used as a input for the PUT API. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId Specifies the source ID for which objects should be returned.
 @return ApiGetEntityMetadataRequest
*/
func (a *ObjectAPIService) GetEntityMetadata(ctx context.Context, sourceId int64) ApiGetEntityMetadataRequest {
	return ApiGetEntityMetadataRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return GetEntityMetadataResult
func (a *ObjectAPIService) GetEntityMetadataExecute(r ApiGetEntityMetadataRequest) (*GetEntityMetadataResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetEntityMetadataResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetEntityMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{sourceId}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceId"+"}", url.PathEscape(parameterValueToString(r.sourceId, "sourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.entityIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityIds", r.entityIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIndexedObjectSnapshotsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	protectionGroupId string
	objectId int64
	indexedObjectName *string
	includeIndexedSnapshotsOnly *bool
	fromTimeUsecs *int64
	toTimeUsecs *int64
	runTypes *[]string
	useCachedData *bool
	objectActionKey *string
}

// Specifies the indexed object name.
func (r ApiGetIndexedObjectSnapshotsRequest) IndexedObjectName(indexedObjectName string) ApiGetIndexedObjectSnapshotsRequest {
	r.indexedObjectName = &indexedObjectName
	return r
}

// Specifies whether to only return snapshots which are indexed. In an indexed snapshots file are guaranteed to exist, while in a non-indexed snapshots file may not exist.
func (r ApiGetIndexedObjectSnapshotsRequest) IncludeIndexedSnapshotsOnly(includeIndexedSnapshotsOnly bool) ApiGetIndexedObjectSnapshotsRequest {
	r.includeIndexedSnapshotsOnly = &includeIndexedSnapshotsOnly
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter indexed object&#39;s snapshots which are taken after this value.
func (r ApiGetIndexedObjectSnapshotsRequest) FromTimeUsecs(fromTimeUsecs int64) ApiGetIndexedObjectSnapshotsRequest {
	r.fromTimeUsecs = &fromTimeUsecs
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter indexed object&#39;s snapshots which are taken before this value.
func (r ApiGetIndexedObjectSnapshotsRequest) ToTimeUsecs(toTimeUsecs int64) ApiGetIndexedObjectSnapshotsRequest {
	r.toTimeUsecs = &toTimeUsecs
	return r
}

// Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
func (r ApiGetIndexedObjectSnapshotsRequest) RunTypes(runTypes []string) ApiGetIndexedObjectSnapshotsRequest {
	r.runTypes = &runTypes
	return r
}

// Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetIndexedObjectSnapshotsRequest) UseCachedData(useCachedData bool) ApiGetIndexedObjectSnapshotsRequest {
	r.useCachedData = &useCachedData
	return r
}

// Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
func (r ApiGetIndexedObjectSnapshotsRequest) ObjectActionKey(objectActionKey string) ApiGetIndexedObjectSnapshotsRequest {
	r.objectActionKey = &objectActionKey
	return r
}

func (r ApiGetIndexedObjectSnapshotsRequest) Execute() (*GetIndexedObjectSnapshotsResponseBody, *http.Response, error) {
	return r.ApiService.GetIndexedObjectSnapshotsExecute(r)
}

/*
GetIndexedObjectSnapshots Get snapshots of indexed object.

Get snapshots of indexed object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param protectionGroupId Specifies the protection group id.
 @param objectId Specifies the object id.
 @return ApiGetIndexedObjectSnapshotsRequest
*/
func (a *ObjectAPIService) GetIndexedObjectSnapshots(ctx context.Context, protectionGroupId string, objectId int64) ApiGetIndexedObjectSnapshotsRequest {
	return ApiGetIndexedObjectSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		protectionGroupId: protectionGroupId,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return GetIndexedObjectSnapshotsResponseBody
func (a *ObjectAPIService) GetIndexedObjectSnapshotsExecute(r ApiGetIndexedObjectSnapshotsRequest) (*GetIndexedObjectSnapshotsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIndexedObjectSnapshotsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetIndexedObjectSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{objectId}/protection-groups/{protectionGroupId}/indexed-objects/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"protectionGroupId"+"}", url.PathEscape(parameterValueToString(r.protectionGroupId, "protectionGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.indexedObjectName == nil {
		return localVarReturnValue, nil, reportError("indexedObjectName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "indexedObjectName", r.indexedObjectName, "")
	if r.includeIndexedSnapshotsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeIndexedSnapshotsOnly", r.includeIndexedSnapshotsOnly, "")
	} else {
		var defaultValue bool = false
		r.includeIndexedSnapshotsOnly = &defaultValue
	}
	if r.fromTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTimeUsecs", r.fromTimeUsecs, "")
	}
	if r.toTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTimeUsecs", r.toTimeUsecs, "")
	}
	if r.runTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTypes", r.runTypes, "csv")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	if r.objectActionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectActionKey", r.objectActionKey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectRunByRunIdRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	runId string
}

func (r ApiGetObjectRunByRunIdRequest) Execute() (*ObjectProtectionRunSummary, *http.Response, error) {
	return r.ApiService.GetObjectRunByRunIdExecute(r)
}

/*
GetObjectRunByRunId Get a run for an object.

Get a run for an object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the object.
 @param runId Specifies the id of the run.
 @return ApiGetObjectRunByRunIdRequest
*/
func (a *ObjectAPIService) GetObjectRunByRunId(ctx context.Context, id int64, runId string) ApiGetObjectRunByRunIdRequest {
	return ApiGetObjectRunByRunIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		runId: runId,
	}
}

// Execute executes the request
//  @return ObjectProtectionRunSummary
func (a *ObjectAPIService) GetObjectRunByRunIdExecute(r ApiGetObjectRunByRunIdRequest) (*ObjectProtectionRunSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectProtectionRunSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectRunByRunId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/runs/{runId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"runId"+"}", url.PathEscape(parameterValueToString(r.runId, "runId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectRunsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	runId *string
	startTimeUsecs *int64
	endTimeUsecs *int64
	tenantIds *[]string
	includeTenants *bool
	runTypes *[]string
	localBackupObjectStatus *[]string
	replicationObjectStatus *[]string
	archivalObjectStatus *[]string
	cloudSpinRunStatus *[]string
	numRuns *int64
	paginationCookie *string
	excludeNonRestorableRuns *bool
}

// Specifies a unique id of the run.
func (r ApiGetObjectRunsRequest) RunId(runId string) ApiGetObjectRunsRequest {
	r.runId = &runId
	return r
}

// Filter by a start time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
func (r ApiGetObjectRunsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetObjectRunsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Filter by a end time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
func (r ApiGetObjectRunsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetObjectRunsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetObjectRunsRequest) TenantIds(tenantIds []string) ApiGetObjectRunsRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
func (r ApiGetObjectRunsRequest) IncludeTenants(includeTenants bool) ApiGetObjectRunsRequest {
	r.includeTenants = &includeTenants
	return r
}

// Filter by run type. Only protection run matching the specified types will be returned.
func (r ApiGetObjectRunsRequest) RunTypes(runTypes []string) ApiGetObjectRunsRequest {
	r.runTypes = &runTypes
	return r
}

// Specifies a list of status for the object in the backup run.
func (r ApiGetObjectRunsRequest) LocalBackupObjectStatus(localBackupObjectStatus []string) ApiGetObjectRunsRequest {
	r.localBackupObjectStatus = &localBackupObjectStatus
	return r
}

// Specifies a list of status for the object in the replication run.
func (r ApiGetObjectRunsRequest) ReplicationObjectStatus(replicationObjectStatus []string) ApiGetObjectRunsRequest {
	r.replicationObjectStatus = &replicationObjectStatus
	return r
}

// Specifies a list of status for the object in the archival run.
func (r ApiGetObjectRunsRequest) ArchivalObjectStatus(archivalObjectStatus []string) ApiGetObjectRunsRequest {
	r.archivalObjectStatus = &archivalObjectStatus
	return r
}

// Specifies a list of status for the object in the cloud spin run.
func (r ApiGetObjectRunsRequest) CloudSpinRunStatus(cloudSpinRunStatus []string) ApiGetObjectRunsRequest {
	r.cloudSpinRunStatus = &cloudSpinRunStatus
	return r
}

// Specifies the max number of runs. If not specified, at most 100 runs will be returned.
func (r ApiGetObjectRunsRequest) NumRuns(numRuns int64) ApiGetObjectRunsRequest {
	r.numRuns = &numRuns
	return r
}

// Specifies the pagination cookie with which subsequent parts of the response can be fetched. Users can use this to get next runs
func (r ApiGetObjectRunsRequest) PaginationCookie(paginationCookie string) ApiGetObjectRunsRequest {
	r.paginationCookie = &paginationCookie
	return r
}

// Specifies whether to exclude non restorable runs. Run is treated restorable only if there is at least one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
func (r ApiGetObjectRunsRequest) ExcludeNonRestorableRuns(excludeNonRestorableRuns bool) ApiGetObjectRunsRequest {
	r.excludeNonRestorableRuns = &excludeNonRestorableRuns
	return r
}

func (r ApiGetObjectRunsRequest) Execute() (*GetObjectRunsResponseBody, *http.Response, error) {
	return r.ApiService.GetObjectRunsExecute(r)
}

/*
GetObjectRuns Get the list of runs for an object.

Get the runs for a particular object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the object.
 @return ApiGetObjectRunsRequest
*/
func (a *ObjectAPIService) GetObjectRuns(ctx context.Context, id int64) ApiGetObjectRunsRequest {
	return ApiGetObjectRunsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetObjectRunsResponseBody
func (a *ObjectAPIService) GetObjectRunsExecute(r ApiGetObjectRunsRequest) (*GetObjectRunsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetObjectRunsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectRuns")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/runs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.runId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runId", r.runId, "")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.runTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTypes", r.runTypes, "csv")
	}
	if r.localBackupObjectStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "localBackupObjectStatus", r.localBackupObjectStatus, "csv")
	}
	if r.replicationObjectStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replicationObjectStatus", r.replicationObjectStatus, "csv")
	}
	if r.archivalObjectStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archivalObjectStatus", r.archivalObjectStatus, "csv")
	}
	if r.cloudSpinRunStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cloudSpinRunStatus", r.cloudSpinRunStatus, "csv")
	}
	if r.numRuns != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numRuns", r.numRuns, "")
	}
	if r.paginationCookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginationCookie", r.paginationCookie, "")
	}
	if r.excludeNonRestorableRuns != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeNonRestorableRuns", r.excludeNonRestorableRuns, "")
	} else {
		var defaultValue bool = false
		r.excludeNonRestorableRuns = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectSnapshotInfoRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	snapshotId string
}

func (r ApiGetObjectSnapshotInfoRequest) Execute() (*ObjectSnapshot, *http.Response, error) {
	return r.ApiService.GetObjectSnapshotInfoExecute(r)
}

/*
GetObjectSnapshotInfo Get details of object snapshot.

Get details of object snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param snapshotId Specifies the snapshot id.
 @return ApiGetObjectSnapshotInfoRequest
*/
func (a *ObjectAPIService) GetObjectSnapshotInfo(ctx context.Context, snapshotId string) ApiGetObjectSnapshotInfoRequest {
	return ApiGetObjectSnapshotInfoRequest{
		ApiService: a,
		ctx: ctx,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return ObjectSnapshot
func (a *ObjectAPIService) GetObjectSnapshotInfoExecute(r ApiGetObjectSnapshotInfoRequest) (*ObjectSnapshot, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectSnapshotInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/snapshots/{snapshotId}"
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectSnapshotVolumeInfoRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	snapshotId string
	includeSupportedOnly *bool
	pointInTimeUsecs *float32
	useCachedData *bool
}

// Specifies whether to only return supported volumes.
func (r ApiGetObjectSnapshotVolumeInfoRequest) IncludeSupportedOnly(includeSupportedOnly bool) ApiGetObjectSnapshotVolumeInfoRequest {
	r.includeSupportedOnly = &includeSupportedOnly
	return r
}

// Specifies the point-in-time timestamp (in usecs from epoch) between snapshots for which the volume info is to be returned.
func (r ApiGetObjectSnapshotVolumeInfoRequest) PointInTimeUsecs(pointInTimeUsecs float32) ApiGetObjectSnapshotVolumeInfoRequest {
	r.pointInTimeUsecs = &pointInTimeUsecs
	return r
}

// Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetObjectSnapshotVolumeInfoRequest) UseCachedData(useCachedData bool) ApiGetObjectSnapshotVolumeInfoRequest {
	r.useCachedData = &useCachedData
	return r
}

func (r ApiGetObjectSnapshotVolumeInfoRequest) Execute() (*ObjectSnapshotVolumeInfo, *http.Response, error) {
	return r.ApiService.GetObjectSnapshotVolumeInfoExecute(r)
}

/*
GetObjectSnapshotVolumeInfo Get volume info of object snapshot.

Get volume info of object snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param snapshotId Specifies the snapshot id.
 @return ApiGetObjectSnapshotVolumeInfoRequest
*/
func (a *ObjectAPIService) GetObjectSnapshotVolumeInfo(ctx context.Context, snapshotId string) ApiGetObjectSnapshotVolumeInfoRequest {
	return ApiGetObjectSnapshotVolumeInfoRequest{
		ApiService: a,
		ctx: ctx,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return ObjectSnapshotVolumeInfo
func (a *ObjectAPIService) GetObjectSnapshotVolumeInfoExecute(r ApiGetObjectSnapshotVolumeInfoRequest) (*ObjectSnapshotVolumeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectSnapshotVolumeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectSnapshotVolumeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/snapshots/{snapshotId}/volume"
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeSupportedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSupportedOnly", r.includeSupportedOnly, "")
	}
	if r.pointInTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pointInTimeUsecs", r.pointInTimeUsecs, "")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectSnapshotsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	fromTimeUsecs *int64
	toTimeUsecs *int64
	runStartFromTimeUsecs *int64
	runStartToTimeUsecs *int64
	snapshotActions *[]string
	runTypes *[]string
	protectionGroupIds *[]string
	runInstanceIds *[]int64
	regionIds *[]string
	objectActionKeys *[]string
}

// Specifies the timestamp in Unix time epoch in microseconds to filter Object&#39;s snapshots which were taken after this value.
func (r ApiGetObjectSnapshotsRequest) FromTimeUsecs(fromTimeUsecs int64) ApiGetObjectSnapshotsRequest {
	r.fromTimeUsecs = &fromTimeUsecs
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter Object&#39;s snapshots which were taken before this value.
func (r ApiGetObjectSnapshotsRequest) ToTimeUsecs(toTimeUsecs int64) ApiGetObjectSnapshotsRequest {
	r.toTimeUsecs = &toTimeUsecs
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter Object&#39;s snapshots which were run after this value.
func (r ApiGetObjectSnapshotsRequest) RunStartFromTimeUsecs(runStartFromTimeUsecs int64) ApiGetObjectSnapshotsRequest {
	r.runStartFromTimeUsecs = &runStartFromTimeUsecs
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter Object&#39;s snapshots which were run before this value.
func (r ApiGetObjectSnapshotsRequest) RunStartToTimeUsecs(runStartToTimeUsecs int64) ApiGetObjectSnapshotsRequest {
	r.runStartToTimeUsecs = &runStartToTimeUsecs
	return r
}

// Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.
func (r ApiGetObjectSnapshotsRequest) SnapshotActions(snapshotActions []string) ApiGetObjectSnapshotsRequest {
	r.snapshotActions = &snapshotActions
	return r
}

// Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
func (r ApiGetObjectSnapshotsRequest) RunTypes(runTypes []string) ApiGetObjectSnapshotsRequest {
	r.runTypes = &runTypes
	return r
}

// If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection group IDs.
func (r ApiGetObjectSnapshotsRequest) ProtectionGroupIds(protectionGroupIds []string) ApiGetObjectSnapshotsRequest {
	r.protectionGroupIds = &protectionGroupIds
	return r
}

// Filter by a list run instance ids. If specified, only snapshots created by these protection runs will be returned.
func (r ApiGetObjectSnapshotsRequest) RunInstanceIds(runInstanceIds []int64) ApiGetObjectSnapshotsRequest {
	r.runInstanceIds = &runInstanceIds
	return r
}

// Filter by a list of region ids.
func (r ApiGetObjectSnapshotsRequest) RegionIds(regionIds []string) ApiGetObjectSnapshotsRequest {
	r.regionIds = &regionIds
	return r
}

// Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, only snapshots matching given action keys are returned for corresponding object.
func (r ApiGetObjectSnapshotsRequest) ObjectActionKeys(objectActionKeys []string) ApiGetObjectSnapshotsRequest {
	r.objectActionKeys = &objectActionKeys
	return r
}

func (r ApiGetObjectSnapshotsRequest) Execute() (*GetObjectSnapshotsResponseBody, *http.Response, error) {
	return r.ApiService.GetObjectSnapshotsExecute(r)
}

/*
GetObjectSnapshots List the snapshots for a given object.

List the snapshots for a given object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Object.
 @return ApiGetObjectSnapshotsRequest
*/
func (a *ObjectAPIService) GetObjectSnapshots(ctx context.Context, id int64) ApiGetObjectSnapshotsRequest {
	return ApiGetObjectSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetObjectSnapshotsResponseBody
func (a *ObjectAPIService) GetObjectSnapshotsExecute(r ApiGetObjectSnapshotsRequest) (*GetObjectSnapshotsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetObjectSnapshotsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTimeUsecs", r.fromTimeUsecs, "")
	}
	if r.toTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTimeUsecs", r.toTimeUsecs, "")
	}
	if r.runStartFromTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runStartFromTimeUsecs", r.runStartFromTimeUsecs, "")
	}
	if r.runStartToTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runStartToTimeUsecs", r.runStartToTimeUsecs, "")
	}
	if r.snapshotActions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotActions", r.snapshotActions, "csv")
	}
	if r.runTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runTypes", r.runTypes, "csv")
	}
	if r.protectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectionGroupIds", r.protectionGroupIds, "csv")
	}
	if r.runInstanceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runInstanceIds", r.runInstanceIds, "csv")
	}
	if r.regionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionIds", r.regionIds, "csv")
	}
	if r.objectActionKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectActionKeys", r.objectActionKeys, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectStatsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	regionIds *[]string
}

// Filter by a list of region ids.
func (r ApiGetObjectStatsRequest) RegionIds(regionIds []string) ApiGetObjectStatsRequest {
	r.regionIds = &regionIds
	return r
}

func (r ApiGetObjectStatsRequest) Execute() (*ObjectStats, *http.Response, error) {
	return r.ApiService.GetObjectStatsExecute(r)
}

/*
GetObjectStats Get stats for a given object.

Get stats for a given object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Object.
 @return ApiGetObjectStatsRequest
*/
func (a *ObjectAPIService) GetObjectStats(ctx context.Context, id int64) ApiGetObjectStatsRequest {
	return ApiGetObjectStatsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectStats
func (a *ObjectAPIService) GetObjectStatsExecute(r ApiGetObjectStatsRequest) (*ObjectStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.regionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionIds", r.regionIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectTreeRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
}

func (r ApiGetObjectTreeRequest) Execute() (*ObjectWithChildren, *http.Response, error) {
	return r.ApiService.GetObjectTreeExecute(r)
}

/*
GetObjectTree Get the objects tree hierarchy for for an Object.

Get the objects tree hierarchy for for an Object. If the object does not have a hierarchy then a single object will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Object.
 @return ApiGetObjectTreeRequest
*/
func (a *ObjectAPIService) GetObjectTree(ctx context.Context, id int64) ApiGetObjectTreeRequest {
	return ApiGetObjectTreeRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ObjectWithChildren
func (a *ObjectAPIService) GetObjectTreeExecute(r ApiGetObjectTreeRequest) (*ObjectWithChildren, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectWithChildren
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectTree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectsLastRunRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	ids *[]int64
	tenantIds *[]string
	includeTenants *bool
	paginationCookie *string
	count *int32
}

// Specifies a list of object ids, only last runs for these objects will be returned.
func (r ApiGetObjectsLastRunRequest) Ids(ids []int64) ApiGetObjectsLastRunRequest {
	r.ids = &ids
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetObjectsLastRunRequest) TenantIds(tenantIds []string) ApiGetObjectsLastRunRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
func (r ApiGetObjectsLastRunRequest) IncludeTenants(includeTenants bool) ApiGetObjectsLastRunRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies the pagination cookie with which subsequent parts of the response can be fetched.
func (r ApiGetObjectsLastRunRequest) PaginationCookie(paginationCookie string) ApiGetObjectsLastRunRequest {
	r.paginationCookie = &paginationCookie
	return r
}

// Specifies the number of objects to be fetched for the specified pagination cookie.
func (r ApiGetObjectsLastRunRequest) Count(count int32) ApiGetObjectsLastRunRequest {
	r.count = &count
	return r
}

func (r ApiGetObjectsLastRunRequest) Execute() (*ObjectsLastRun, *http.Response, error) {
	return r.ApiService.GetObjectsLastRunExecute(r)
}

/*
GetObjectsLastRun Get last protection run of objects.

Get last protection run of objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetObjectsLastRunRequest
*/
func (a *ObjectAPIService) GetObjectsLastRun(ctx context.Context) ApiGetObjectsLastRunRequest {
	return ApiGetObjectsLastRunRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectsLastRun
func (a *ObjectAPIService) GetObjectsLastRunExecute(r ApiGetObjectsLastRunRequest) (*ObjectsLastRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectsLastRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetObjectsLastRun")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/last-run"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.paginationCookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginationCookie", r.paginationCookie, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPITRangesForProtectedObjectRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	fromTimeUsecs *int64
	toTimeUsecs *int64
	protectionGroupIds *[]string
}

// If specified, return the restore ranges that lie after this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
func (r ApiGetPITRangesForProtectedObjectRequest) FromTimeUsecs(fromTimeUsecs int64) ApiGetPITRangesForProtectedObjectRequest {
	r.fromTimeUsecs = &fromTimeUsecs
	return r
}

// If specified, return the restore ranges that lie before this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
func (r ApiGetPITRangesForProtectedObjectRequest) ToTimeUsecs(toTimeUsecs int64) ApiGetPITRangesForProtectedObjectRequest {
	r.toTimeUsecs = &toTimeUsecs
	return r
}

// If specified, return only the points in time corresponding to these protection group IDs.
func (r ApiGetPITRangesForProtectedObjectRequest) ProtectionGroupIds(protectionGroupIds []string) ApiGetPITRangesForProtectedObjectRequest {
	r.protectionGroupIds = &protectionGroupIds
	return r
}

func (r ApiGetPITRangesForProtectedObjectRequest) Execute() (*GetPITRangesProtectedObjectResponseBody, *http.Response, error) {
	return r.ApiService.GetPITRangesForProtectedObjectExecute(r)
}

/*
GetPITRangesForProtectedObject Get PIT ranges for an object

Returns the ranges in various types like time, SCN etc. within which the specified protected object can be restored to any Point in time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the ID of the protected object.
 @return ApiGetPITRangesForProtectedObjectRequest
*/
func (a *ObjectAPIService) GetPITRangesForProtectedObject(ctx context.Context, id int64) ApiGetPITRangesForProtectedObjectRequest {
	return ApiGetPITRangesForProtectedObjectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetPITRangesProtectedObjectResponseBody
func (a *ObjectAPIService) GetPITRangesForProtectedObjectExecute(r ApiGetPITRangesForProtectedObjectRequest) (*GetPITRangesProtectedObjectResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPITRangesProtectedObjectResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetPITRangesForProtectedObject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/pit-ranges"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fromTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromTimeUsecs", r.fromTimeUsecs, "")
	}
	if r.toTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toTimeUsecs", r.toTimeUsecs, "")
	}
	if r.protectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectionGroupIds", r.protectionGroupIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectedObjectOfAnyTypeByIdRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	requestInitiatorType *string
	objectActionKey *[]string
	onlyProtectedObjects *bool
	storageDomainId *int64
	environments *[]string
	tenantIds *[]string
	includeTenants *bool
	includeLastRunInfo *bool
	onlyAutoProtectedObjects *bool
	onlyLeafObjects *bool
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id and this vec&#39;s size needs to be same as &#39;id&#39;.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) ObjectActionKey(objectActionKey []string) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.objectActionKey = &objectActionKey
	return r
}

// If true, the response will include only objects which have been protected.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) OnlyProtectedObjects(onlyProtectedObjects bool) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.onlyProtectedObjects = &onlyProtectedObjects
	return r
}

// Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) StorageDomainId(storageDomainId int64) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.storageDomainId = &storageDomainId
	return r
}

// Filter by environment types such as &#39;kVMware&#39;, &#39;kView&#39;, etc. Only Protected objects protecting the specified environment types are returned.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) Environments(environments []string) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.environments = &environments
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) TenantIds(tenantIds []string) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) IncludeTenants(includeTenants bool) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.includeTenants = &includeTenants
	return r
}

// If true, the response will include information about the last protection run on this object.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) IncludeLastRunInfo(includeLastRunInfo bool) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.includeLastRunInfo = &includeLastRunInfo
	return r
}

// If true, the response will include only the auto protected objects.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) OnlyAutoProtectedObjects(onlyAutoProtectedObjects bool) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.onlyAutoProtectedObjects = &onlyAutoProtectedObjects
	return r
}

// If true, the response will include only the leaf level objects.
func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) OnlyLeafObjects(onlyLeafObjects bool) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	r.onlyLeafObjects = &onlyLeafObjects
	return r
}

func (r ApiGetProtectedObjectOfAnyTypeByIdRequest) Execute() (*ProtectedObjectInfo, *http.Response, error) {
	return r.ApiService.GetProtectedObjectOfAnyTypeByIdExecute(r)
}

/*
GetProtectedObjectOfAnyTypeById Get an Object.

Get Object configurations for given object id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Object.
 @return ApiGetProtectedObjectOfAnyTypeByIdRequest
*/
func (a *ObjectAPIService) GetProtectedObjectOfAnyTypeById(ctx context.Context, id int64) ApiGetProtectedObjectOfAnyTypeByIdRequest {
	return ApiGetProtectedObjectOfAnyTypeByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ProtectedObjectInfo
func (a *ObjectAPIService) GetProtectedObjectOfAnyTypeByIdExecute(r ApiGetProtectedObjectOfAnyTypeByIdRequest) (*ProtectedObjectInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectedObjectInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetProtectedObjectOfAnyTypeById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.objectActionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectActionKey", r.objectActionKey, "csv")
	}
	if r.onlyProtectedObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyProtectedObjects", r.onlyProtectedObjects, "")
	}
	if r.storageDomainId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainId", r.storageDomainId, "")
	}
	if r.environments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environments", r.environments, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeLastRunInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLastRunInfo", r.includeLastRunInfo, "")
	}
	if r.onlyAutoProtectedObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyAutoProtectedObjects", r.onlyAutoProtectedObjects, "")
	}
	if r.onlyLeafObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyLeafObjects", r.onlyLeafObjects, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectedObjectsOfAnyTypeRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	requestInitiatorType *string
	ids *[]int64
	objectActionKeys *[]string
	policyIds *[]string
	parentId *int64
	onlyProtectedObjects *bool
	storageDomainId *int64
	environments *[]string
	tenantIds *[]string
	includeTenants *bool
	includeLastRunInfo *bool
	onlyAutoProtectedObjects *bool
	onlyLeafObjects *bool
	regionIds *[]string
	maxCount *int32
	cookie *string
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) RequestInitiatorType(requestInitiatorType string) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Filter by a list of Object ids.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) Ids(ids []int64) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.ids = &ids
	return r
}

// Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id. The vec&#39;s size needs to be of either length one or same as the length of &#39;ids&#39;. If the length of objectActionKey is one, it will be repeated as many number of times equal to the length of objectIds, as mandated by backend validation. If the length of objectActionKey and object ids are same then it will be passed as it is.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) ObjectActionKeys(objectActionKeys []string) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.objectActionKeys = &objectActionKeys
	return r
}

// Filter by Policy ids that are associated with Protected Objects.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) PolicyIds(policyIds []string) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.policyIds = &policyIds
	return r
}

// Filter by Parent Id. Parent id is a unique object Id which may contain protected objects underneath in the source tree.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) ParentId(parentId int64) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.parentId = &parentId
	return r
}

// If true, the response will include only objects which have been protected.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) OnlyProtectedObjects(onlyProtectedObjects bool) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.onlyProtectedObjects = &onlyProtectedObjects
	return r
}

// Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) StorageDomainId(storageDomainId int64) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.storageDomainId = &storageDomainId
	return r
}

// Filter by environment types such as &#39;kVMware&#39;, &#39;kView&#39;, etc. Only Protected objects protecting the specified environment types are returned.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) Environments(environments []string) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.environments = &environments
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) TenantIds(tenantIds []string) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) IncludeTenants(includeTenants bool) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.includeTenants = &includeTenants
	return r
}

// If true, the response will include information about the last protection run on this object.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) IncludeLastRunInfo(includeLastRunInfo bool) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.includeLastRunInfo = &includeLastRunInfo
	return r
}

// If true, the response will include only the auto protected objects.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) OnlyAutoProtectedObjects(onlyAutoProtectedObjects bool) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.onlyAutoProtectedObjects = &onlyAutoProtectedObjects
	return r
}

// If true, the response will include only the leaf level objects.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) OnlyLeafObjects(onlyLeafObjects bool) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.onlyLeafObjects = &onlyLeafObjects
	return r
}

// Filter by a list of region ids.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) RegionIds(regionIds []string) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.regionIds = &regionIds
	return r
}

// Specifies the max number of objects to return.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) MaxCount(maxCount int32) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.maxCount = &maxCount
	return r
}

// Specifies the pagination cookie.
func (r ApiGetProtectedObjectsOfAnyTypeRequest) Cookie(cookie string) ApiGetProtectedObjectsOfAnyTypeRequest {
	r.cookie = &cookie
	return r
}

func (r ApiGetProtectedObjectsOfAnyTypeRequest) Execute() (*GetProtectedObjectsResponse, *http.Response, error) {
	return r.ApiService.GetProtectedObjectsOfAnyTypeExecute(r)
}

/*
GetProtectedObjectsOfAnyType Get Objects.

Get Objects Configurations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProtectedObjectsOfAnyTypeRequest
*/
func (a *ObjectAPIService) GetProtectedObjectsOfAnyType(ctx context.Context) ApiGetProtectedObjectsOfAnyTypeRequest {
	return ApiGetProtectedObjectsOfAnyTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProtectedObjectsResponse
func (a *ObjectAPIService) GetProtectedObjectsOfAnyTypeExecute(r ApiGetProtectedObjectsOfAnyTypeRequest) (*GetProtectedObjectsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProtectedObjectsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetProtectedObjectsOfAnyType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.objectActionKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectActionKeys", r.objectActionKeys, "csv")
	}
	if r.policyIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "policyIds", r.policyIds, "csv")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	if r.onlyProtectedObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyProtectedObjects", r.onlyProtectedObjects, "")
	}
	if r.storageDomainId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainId", r.storageDomainId, "")
	}
	if r.environments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environments", r.environments, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeLastRunInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLastRunInfo", r.includeLastRunInfo, "")
	}
	if r.onlyAutoProtectedObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyAutoProtectedObjects", r.onlyAutoProtectedObjects, "")
	}
	if r.onlyLeafObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyLeafObjects", r.onlyLeafObjects, "")
	}
	if r.regionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionIds", r.regionIds, "csv")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.cookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cookie", r.cookie, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSnapshotDiffRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	body *SnapshotDiffParams
}

func (r ApiGetSnapshotDiffRequest) Body(body SnapshotDiffParams) ApiGetSnapshotDiffRequest {
	r.body = &body
	return r
}

func (r ApiGetSnapshotDiffRequest) Execute() (*SnapshotDiffResult, *http.Response, error) {
	return r.ApiService.GetSnapshotDiffExecute(r)
}

/*
GetSnapshotDiff Get diff between two snapshots of a given object.

Get diff (files added/deleted) between two snapshots of a given object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetSnapshotDiffRequest
*/
func (a *ObjectAPIService) GetSnapshotDiff(ctx context.Context, id int64) ApiGetSnapshotDiffRequest {
	return ApiGetSnapshotDiffRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SnapshotDiffResult
func (a *ObjectAPIService) GetSnapshotDiffExecute(r ApiGetSnapshotDiffRequest) (*SnapshotDiffResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SnapshotDiffResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetSnapshotDiff")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/snapshot-diff"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSourceHierarchyObjectsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	sourceId int64
	parentId *int64
	tenantIds *[]string
	includeTenants *bool
	vmwareObjectTypes *[]string
	netappObjectTypes *[]string
	o365ObjectTypes *[]string
	cassandraObjectTypes *[]string
	mongodbObjectTypes *[]string
	couchbaseObjectTypes *[]string
	hdfsObjectTypes *[]string
	hbaseObjectTypes *[]string
	hiveObjectTypes *[]string
	hypervObjectTypes *[]string
	azureObjectTypes *[]string
	kvmObjectTypes *[]string
	awsObjectTypes *[]string
	gcpObjectTypes *[]string
	acropolisObjectTypes *[]string
	genericNasObjectTypes *[]string
	isilonObjectTypes *[]string
	flashbladeObjectTypes *[]string
	elastifileObjectTypes *[]string
	gpfsObjectTypes *[]string
	pureObjectTypes *[]string
	nimbleObjectTypes *[]string
	physicalObjectTypes *[]string
	kubernetesObjectTypes *[]string
	exchangeObjectTypes *[]string
	adObjectTypes *[]string
	mssqlObjectTypes *[]string
	oracleObjectTypes *[]string
	useCachedData *bool
}

// Specifies the parent ID under which objects should be returned.
func (r ApiGetSourceHierarchyObjectsRequest) ParentId(parentId int64) ApiGetSourceHierarchyObjectsRequest {
	r.parentId = &parentId
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetSourceHierarchyObjectsRequest) TenantIds(tenantIds []string) ApiGetSourceHierarchyObjectsRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
func (r ApiGetSourceHierarchyObjectsRequest) IncludeTenants(includeTenants bool) ApiGetSourceHierarchyObjectsRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies the VMware object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) VmwareObjectTypes(vmwareObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.vmwareObjectTypes = &vmwareObjectTypes
	return r
}

// Specifies the Netapp object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) NetappObjectTypes(netappObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.netappObjectTypes = &netappObjectTypes
	return r
}

// Specifies the Office 365 object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) O365ObjectTypes(o365ObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.o365ObjectTypes = &o365ObjectTypes
	return r
}

// Specifies the Cassandra object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) CassandraObjectTypes(cassandraObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.cassandraObjectTypes = &cassandraObjectTypes
	return r
}

// Specifies the Mongo DB object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) MongodbObjectTypes(mongodbObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.mongodbObjectTypes = &mongodbObjectTypes
	return r
}

// Specifies the Couchbase object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) CouchbaseObjectTypes(couchbaseObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.couchbaseObjectTypes = &couchbaseObjectTypes
	return r
}

// Specifies the HDFS object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) HdfsObjectTypes(hdfsObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.hdfsObjectTypes = &hdfsObjectTypes
	return r
}

// Specifies the Hbase object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) HbaseObjectTypes(hbaseObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.hbaseObjectTypes = &hbaseObjectTypes
	return r
}

// Specifies the Hive object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) HiveObjectTypes(hiveObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.hiveObjectTypes = &hiveObjectTypes
	return r
}

// Specifies the HyperV object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) HypervObjectTypes(hypervObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.hypervObjectTypes = &hypervObjectTypes
	return r
}

// Specifies the Azure object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) AzureObjectTypes(azureObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.azureObjectTypes = &azureObjectTypes
	return r
}

// Specifies the KVM object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) KvmObjectTypes(kvmObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.kvmObjectTypes = &kvmObjectTypes
	return r
}

// Specifies the AWS object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) AwsObjectTypes(awsObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.awsObjectTypes = &awsObjectTypes
	return r
}

// Specifies the GCP object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) GcpObjectTypes(gcpObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.gcpObjectTypes = &gcpObjectTypes
	return r
}

// Specifies the Acropolis object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) AcropolisObjectTypes(acropolisObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.acropolisObjectTypes = &acropolisObjectTypes
	return r
}

// Specifies the generic NAS object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) GenericNasObjectTypes(genericNasObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.genericNasObjectTypes = &genericNasObjectTypes
	return r
}

// Specifies the Isilon object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) IsilonObjectTypes(isilonObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.isilonObjectTypes = &isilonObjectTypes
	return r
}

// Specifies the Flashblade object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) FlashbladeObjectTypes(flashbladeObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.flashbladeObjectTypes = &flashbladeObjectTypes
	return r
}

// Specifies the Elastifile object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) ElastifileObjectTypes(elastifileObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.elastifileObjectTypes = &elastifileObjectTypes
	return r
}

// Specifies the GPFS object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) GpfsObjectTypes(gpfsObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.gpfsObjectTypes = &gpfsObjectTypes
	return r
}

// Specifies the Pure object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) PureObjectTypes(pureObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.pureObjectTypes = &pureObjectTypes
	return r
}

// Specifies the Nimble object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) NimbleObjectTypes(nimbleObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.nimbleObjectTypes = &nimbleObjectTypes
	return r
}

// Specifies the Physical object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) PhysicalObjectTypes(physicalObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.physicalObjectTypes = &physicalObjectTypes
	return r
}

// Specifies the Kubernetes object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) KubernetesObjectTypes(kubernetesObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.kubernetesObjectTypes = &kubernetesObjectTypes
	return r
}

// Specifies the Exchange object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) ExchangeObjectTypes(exchangeObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.exchangeObjectTypes = &exchangeObjectTypes
	return r
}

// Specifies the AD object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) AdObjectTypes(adObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.adObjectTypes = &adObjectTypes
	return r
}

// Specifies the MSSQL object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) MssqlObjectTypes(mssqlObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.mssqlObjectTypes = &mssqlObjectTypes
	return r
}

// Specifies the Oracle object types to filter objects.
func (r ApiGetSourceHierarchyObjectsRequest) OracleObjectTypes(oracleObjectTypes []string) ApiGetSourceHierarchyObjectsRequest {
	r.oracleObjectTypes = &oracleObjectTypes
	return r
}

// Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetSourceHierarchyObjectsRequest) UseCachedData(useCachedData bool) ApiGetSourceHierarchyObjectsRequest {
	r.useCachedData = &useCachedData
	return r
}

func (r ApiGetSourceHierarchyObjectsRequest) Execute() (*SourceHierarchyObjectSummaries, *http.Response, error) {
	return r.ApiService.GetSourceHierarchyObjectsExecute(r)
}

/*
GetSourceHierarchyObjects List objects on a source which can be used for data protection.

List objects which can be used for data protection.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceId Specifies the source ID for which objects should be returned.
 @return ApiGetSourceHierarchyObjectsRequest
*/
func (a *ObjectAPIService) GetSourceHierarchyObjects(ctx context.Context, sourceId int64) ApiGetSourceHierarchyObjectsRequest {
	return ApiGetSourceHierarchyObjectsRequest{
		ApiService: a,
		ctx: ctx,
		sourceId: sourceId,
	}
}

// Execute executes the request
//  @return SourceHierarchyObjectSummaries
func (a *ObjectAPIService) GetSourceHierarchyObjectsExecute(r ApiGetSourceHierarchyObjectsRequest) (*SourceHierarchyObjectSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SourceHierarchyObjectSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.GetSourceHierarchyObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/sources/{sourceId}/objects"
	localVarPath = strings.Replace(localVarPath, "{"+"sourceId"+"}", url.PathEscape(parameterValueToString(r.sourceId, "sourceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.vmwareObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vmwareObjectTypes", r.vmwareObjectTypes, "csv")
	}
	if r.netappObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "netappObjectTypes", r.netappObjectTypes, "csv")
	}
	if r.o365ObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "o365ObjectTypes", r.o365ObjectTypes, "csv")
	}
	if r.cassandraObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cassandraObjectTypes", r.cassandraObjectTypes, "csv")
	}
	if r.mongodbObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mongodbObjectTypes", r.mongodbObjectTypes, "csv")
	}
	if r.couchbaseObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "couchbaseObjectTypes", r.couchbaseObjectTypes, "csv")
	}
	if r.hdfsObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hdfsObjectTypes", r.hdfsObjectTypes, "csv")
	}
	if r.hbaseObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hbaseObjectTypes", r.hbaseObjectTypes, "csv")
	}
	if r.hiveObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hiveObjectTypes", r.hiveObjectTypes, "csv")
	}
	if r.hypervObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hypervObjectTypes", r.hypervObjectTypes, "csv")
	}
	if r.azureObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "azureObjectTypes", r.azureObjectTypes, "csv")
	}
	if r.kvmObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvmObjectTypes", r.kvmObjectTypes, "csv")
	}
	if r.awsObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "awsObjectTypes", r.awsObjectTypes, "csv")
	}
	if r.gcpObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gcpObjectTypes", r.gcpObjectTypes, "csv")
	}
	if r.acropolisObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acropolisObjectTypes", r.acropolisObjectTypes, "csv")
	}
	if r.genericNasObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "genericNasObjectTypes", r.genericNasObjectTypes, "csv")
	}
	if r.isilonObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isilonObjectTypes", r.isilonObjectTypes, "csv")
	}
	if r.flashbladeObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flashbladeObjectTypes", r.flashbladeObjectTypes, "csv")
	}
	if r.elastifileObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "elastifileObjectTypes", r.elastifileObjectTypes, "csv")
	}
	if r.gpfsObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gpfsObjectTypes", r.gpfsObjectTypes, "csv")
	}
	if r.pureObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pureObjectTypes", r.pureObjectTypes, "csv")
	}
	if r.nimbleObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nimbleObjectTypes", r.nimbleObjectTypes, "csv")
	}
	if r.physicalObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "physicalObjectTypes", r.physicalObjectTypes, "csv")
	}
	if r.kubernetesObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kubernetesObjectTypes", r.kubernetesObjectTypes, "csv")
	}
	if r.exchangeObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeObjectTypes", r.exchangeObjectTypes, "csv")
	}
	if r.adObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adObjectTypes", r.adObjectTypes, "csv")
	}
	if r.mssqlObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mssqlObjectTypes", r.mssqlObjectTypes, "csv")
	}
	if r.oracleObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "oracleObjectTypes", r.oracleObjectTypes, "csv")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiObjectsActionsRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	body *ObjectsActionRequest
}

// Specifies the parameters to execute actions on given list of objects.
func (r ApiObjectsActionsRequest) Body(body ObjectsActionRequest) ApiObjectsActionsRequest {
	r.body = &body
	return r
}

func (r ApiObjectsActionsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsActionsExecute(r)
}

/*
ObjectsActions Actions on Objects

Specifies the request to perform various actions on multiple objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsActionsRequest
*/
func (a *ObjectAPIService) ObjectsActions(ctx context.Context) ApiObjectsActionsRequest {
	return ApiObjectsActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ObjectAPIService) ObjectsActionsExecute(r ApiObjectsActionsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.ObjectsActions")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPerformActionOnObjectRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	body *ObjectActionRequest
}

// Specifies the parameters to perform an action on an object.
func (r ApiPerformActionOnObjectRequest) Body(body ObjectActionRequest) ApiPerformActionOnObjectRequest {
	r.body = &body
	return r
}

func (r ApiPerformActionOnObjectRequest) Execute() (*http.Response, error) {
	return r.ApiService.PerformActionOnObjectExecute(r)
}

/*
PerformActionOnObject Perform an action on an object.

Perform an action on an object. Depending on the object environment type, different actions are available.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Object.
 @return ApiPerformActionOnObjectRequest
*/
func (a *ObjectAPIService) PerformActionOnObject(ctx context.Context, id int64) ApiPerformActionOnObjectRequest {
	return ApiPerformActionOnObjectRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ObjectAPIService) PerformActionOnObjectExecute(r ApiPerformActionOnObjectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.PerformActionOnObject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateObjectSnapshotRequest struct {
	ctx context.Context
	ApiService *ObjectAPIService
	id int64
	snapshotId string
	body *UpdateObjectSnapshotRequest
}

// Specifies the parameters update an object snapshot.
func (r ApiUpdateObjectSnapshotRequest) Body(body UpdateObjectSnapshotRequest) ApiUpdateObjectSnapshotRequest {
	r.body = &body
	return r
}

func (r ApiUpdateObjectSnapshotRequest) Execute() (*ObjectSnapshot, *http.Response, error) {
	return r.ApiService.UpdateObjectSnapshotExecute(r)
}

/*
UpdateObjectSnapshot Update an object snapshot.

Update an object snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of the Object.
 @param snapshotId Specifies the id of the snapshot.<br> Note: 1. If the snapshotid of one of the apps is specified, it applies for all the databases in the Protection Run.<br> 2. In case of volume based jobs, please specify the snapshotid of the source not the database. if source snapshot is specified, applied to source snapshot. if database snapshotid is specified in case of volume based jobs, then it is applicable for host's snapshot.
 @return ApiUpdateObjectSnapshotRequest
*/
func (a *ObjectAPIService) UpdateObjectSnapshot(ctx context.Context, id int64, snapshotId string) ApiUpdateObjectSnapshotRequest {
	return ApiUpdateObjectSnapshotRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		snapshotId: snapshotId,
	}
}

// Execute executes the request
//  @return ObjectSnapshot
func (a *ObjectAPIService) UpdateObjectSnapshotExecute(r ApiUpdateObjectSnapshotRequest) (*ObjectSnapshot, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ObjectAPIService.UpdateObjectSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/objects/{id}/snapshots/{snapshotId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"snapshotId"+"}", url.PathEscape(parameterValueToString(r.snapshotId, "snapshotId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
