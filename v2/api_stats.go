/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// StatsAPIService StatsAPI service
type StatsAPIService service

type ApiGetClusterStorageStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
}

func (r ApiGetClusterStorageStatsRequest) Execute() (*ClusterStorageStats, *http.Response, error) {
	return r.ApiService.GetClusterStorageStatsExecute(r)
}

/*
GetClusterStorageStats Get Cluster Storage Stats.

Get Cluster Storage Stats.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetClusterStorageStatsRequest
*/
func (a *StatsAPIService) GetClusterStorageStats(ctx context.Context) ApiGetClusterStorageStatsRequest {
	return ApiGetClusterStorageStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClusterStorageStats
func (a *StatsAPIService) GetClusterStorageStatsExecute(r ApiGetClusterStorageStatsRequest) (*ClusterStorageStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClusterStorageStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetClusterStorageStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/cluster-storage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilesStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
	entityType *string
}

// Specifies the entity type based on which the files stats are calculated. By default stats are calculated based on Cluster
func (r ApiGetFilesStatsRequest) EntityType(entityType string) ApiGetFilesStatsRequest {
	r.entityType = &entityType
	return r
}

func (r ApiGetFilesStatsRequest) Execute() (*FilesStats, *http.Response, error) {
	return r.ApiService.GetFilesStatsExecute(r)
}

/*
GetFilesStats Get Stats of Files.

Get Stats of files.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilesStatsRequest
*/
func (a *StatsAPIService) GetFilesStats(ctx context.Context) ApiGetFilesStatsRequest {
	return ApiGetFilesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FilesStats
func (a *StatsAPIService) GetFilesStatsExecute(r ApiGetFilesStatsRequest) (*FilesStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FilesStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetFilesStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.entityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityType", r.entityType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionRunsStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
	startTimeUsecs *int64
	endTimeUsecs *int64
	runStatus *[]string
}

// Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be counted. By default it is current time minus a day.
func (r ApiGetProtectionRunsStatsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionRunsStatsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be counted. By default it is current time.
func (r ApiGetProtectionRunsStatsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionRunsStatsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Specifies a list of status, runs matching the status will be returned. &#39;Running&#39; indicates that the run is still running. &#39;Canceled&#39; indicates that the run has been canceled. &#39;Failed&#39; indicates that the run has failed. &#39;Succeeded&#39; indicates that the run has finished successfully. &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.
func (r ApiGetProtectionRunsStatsRequest) RunStatus(runStatus []string) ApiGetProtectionRunsStatsRequest {
	r.runStatus = &runStatus
	return r
}

func (r ApiGetProtectionRunsStatsRequest) Execute() (*GetProtectionRunsStatusResponseBody, *http.Response, error) {
	return r.ApiService.GetProtectionRunsStatsExecute(r)
}

/*
GetProtectionRunsStats Get statistics of protection runs.

Get statistics of protection runs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProtectionRunsStatsRequest
*/
func (a *StatsAPIService) GetProtectionRunsStats(ctx context.Context) ApiGetProtectionRunsStatsRequest {
	return ApiGetProtectionRunsStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProtectionRunsStatusResponseBody
func (a *StatsAPIService) GetProtectionRunsStatsExecute(r ApiGetProtectionRunsStatsRequest) (*GetProtectionRunsStatusResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProtectionRunsStatusResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetProtectionRunsStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/protection-runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.runStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runStatus", r.runStatus, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimeSeriesStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
	schemaName *string
	metricNames *[]string
	startTimeMsecs *int64
	entityId *string
	entityIdList *[]string
	prorateDataPoints *bool
	includeGrowthChange *bool
	endTimeMsecs *int64
	rollupFunction *string
	rollupIntervalSecs *int32
}

// Specifies the schema name.
func (r ApiGetTimeSeriesStatsRequest) SchemaName(schemaName string) ApiGetTimeSeriesStatsRequest {
	r.schemaName = &schemaName
	return r
}

// Specifies a list of metric names.
func (r ApiGetTimeSeriesStatsRequest) MetricNames(metricNames []string) ApiGetTimeSeriesStatsRequest {
	r.metricNames = &metricNames
	return r
}

// Specifies the start time of series stats.
func (r ApiGetTimeSeriesStatsRequest) StartTimeMsecs(startTimeMsecs int64) ApiGetTimeSeriesStatsRequest {
	r.startTimeMsecs = &startTimeMsecs
	return r
}

// Specifies the entity id.
func (r ApiGetTimeSeriesStatsRequest) EntityId(entityId string) ApiGetTimeSeriesStatsRequest {
	r.entityId = &entityId
	return r
}

// Specifies an entity id list represented as a string. The stats result will be the sum over all these entities. Duplicate id&#39;s will be ignored. If both EntityIdList and EntityId are specified, EntityId will be ignored.
func (r ApiGetTimeSeriesStatsRequest) EntityIdList(entityIdList []string) ApiGetTimeSeriesStatsRequest {
	r.entityIdList = &entityIdList
	return r
}

// Specifies to create pro rated data point for every rollup interval instead of returning the actual raw data points. This should be used only when rollup function is provided.
func (r ApiGetTimeSeriesStatsRequest) ProrateDataPoints(prorateDataPoints bool) ApiGetTimeSeriesStatsRequest {
	r.prorateDataPoints = &prorateDataPoints
	return r
}

// Specifies if the response should return the difference of a data point with the previous datapoint. Used for determining the change in growth rate. Datapoint could be +x, 0, -x showing the growth is up, no change or down respectively.
func (r ApiGetTimeSeriesStatsRequest) IncludeGrowthChange(includeGrowthChange bool) ApiGetTimeSeriesStatsRequest {
	r.includeGrowthChange = &includeGrowthChange
	return r
}

// Specifies the end time of series stats, by default it is current time.
func (r ApiGetTimeSeriesStatsRequest) EndTimeMsecs(endTimeMsecs int64) ApiGetTimeSeriesStatsRequest {
	r.endTimeMsecs = &endTimeMsecs
	return r
}

// Specifies the rollup function to apply to the data points for the time interval specified by rollupInternalSecs.
func (r ApiGetTimeSeriesStatsRequest) RollupFunction(rollupFunction string) ApiGetTimeSeriesStatsRequest {
	r.rollupFunction = &rollupFunction
	return r
}

// Specifies the time interval granularity for the specified rollup function.
func (r ApiGetTimeSeriesStatsRequest) RollupIntervalSecs(rollupIntervalSecs int32) ApiGetTimeSeriesStatsRequest {
	r.rollupIntervalSecs = &rollupIntervalSecs
	return r
}

func (r ApiGetTimeSeriesStatsRequest) Execute() (*TimeSeriesStats, *http.Response, error) {
	return r.ApiService.GetTimeSeriesStatsExecute(r)
}

/*
GetTimeSeriesStats Get Time Series Stats.

Get Time Series Stats.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimeSeriesStatsRequest
*/
func (a *StatsAPIService) GetTimeSeriesStats(ctx context.Context) ApiGetTimeSeriesStatsRequest {
	return ApiGetTimeSeriesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TimeSeriesStats
func (a *StatsAPIService) GetTimeSeriesStatsExecute(r ApiGetTimeSeriesStatsRequest) (*TimeSeriesStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimeSeriesStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetTimeSeriesStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/time-series-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.schemaName == nil {
		return localVarReturnValue, nil, reportError("schemaName is required and must be specified")
	}
	if r.metricNames == nil {
		return localVarReturnValue, nil, reportError("metricNames is required and must be specified")
	}
	if len(*r.metricNames) < 1 {
		return localVarReturnValue, nil, reportError("metricNames must have at least 1 elements")
	}
	if r.startTimeMsecs == nil {
		return localVarReturnValue, nil, reportError("startTimeMsecs is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "schemaName", r.schemaName, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "metricNames", r.metricNames, "csv")
	if r.entityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityId", r.entityId, "")
	}
	if r.entityIdList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityIdList", r.entityIdList, "csv")
	}
	if r.prorateDataPoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prorateDataPoints", r.prorateDataPoints, "")
	}
	if r.includeGrowthChange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeGrowthChange", r.includeGrowthChange, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeMsecs", r.startTimeMsecs, "")
	if r.endTimeMsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeMsecs", r.endTimeMsecs, "")
	}
	if r.rollupFunction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rollupFunction", r.rollupFunction, "")
	}
	if r.rollupIntervalSecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rollupIntervalSecs", r.rollupIntervalSecs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTopViewsStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
	metric *string
	protocol *string
	numTopViews *int64
	lastHours *int64
}

// Specifies the metric to which stats has to be sorted. Defaults to kNumBytesRead.
func (r ApiGetTopViewsStatsRequest) Metric(metric string) ApiGetTopViewsStatsRequest {
	r.metric = &metric
	return r
}

// Specifies the protocol to sort. Defaults to kAny.
func (r ApiGetTopViewsStatsRequest) Protocol(protocol string) ApiGetTopViewsStatsRequest {
	r.protocol = &protocol
	return r
}

// Specifies the number of view for which stats has to be computed. Returned Views will be sorted in descending order based on the &#39;metric&#39; param. Minimum value has to be 1. Defaults to 100.
func (r ApiGetTopViewsStatsRequest) NumTopViews(numTopViews int64) ApiGetTopViewsStatsRequest {
	r.numTopViews = &numTopViews
	return r
}

// Specifies the last hours of stats to sort. Defaults to 24.
func (r ApiGetTopViewsStatsRequest) LastHours(lastHours int64) ApiGetTopViewsStatsRequest {
	r.lastHours = &lastHours
	return r
}

func (r ApiGetTopViewsStatsRequest) Execute() (*ViewsStats, *http.Response, error) {
	return r.ApiService.GetTopViewsStatsExecute(r)
}

/*
GetTopViewsStats Get stats for the top views, which are the views with largest value of 'stats.valueInLastHours' for a given combination of 'metric', 'protocol' & 'lastHours' params. The API uses suitable defaults if any of the parameters are not specified.

Get stats for the top views, which are the views with largest value of 'stats.valueInLastHours' for a given combination of 'metric', 'protocol' & 'lastHours' params. The API uses suitable defaults if any of the parameters are not specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTopViewsStatsRequest
*/
func (a *StatsAPIService) GetTopViewsStats(ctx context.Context) ApiGetTopViewsStatsRequest {
	return ApiGetTopViewsStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewsStats
func (a *StatsAPIService) GetTopViewsStatsExecute(r ApiGetTopViewsStatsRequest) (*ViewsStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewsStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetTopViewsStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/top-views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric", r.metric, "")
	} else {
		var defaultValue string = "kNumBytesRead"
		r.metric = &defaultValue
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "")
	} else {
		var defaultValue string = "kAny"
		r.protocol = &defaultValue
	}
	if r.numTopViews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numTopViews", r.numTopViews, "")
	} else {
		var defaultValue int64 = 100
		r.numTopViews = &defaultValue
	}
	if r.lastHours != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastHours", r.lastHours, "")
	} else {
		var defaultValue int64 = 24
		r.lastHours = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewClientStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
	metric *string
	numTopViewClients *int64
	lastHours *int64
}

// Specifies the metric to which stats has to be sorted.
func (r ApiGetViewClientStatsRequest) Metric(metric string) ApiGetViewClientStatsRequest {
	r.metric = &metric
	return r
}

// Specifies the number of view clients for which stats has to be computed. Specifying this field will return the Views sorted in the descending order on the metric specified. If specified, minimum value is 1. If not specified, all view clients will be returned. If metric is not specified, this parameter must also not be specified.
func (r ApiGetViewClientStatsRequest) NumTopViewClients(numTopViewClients int64) ApiGetViewClientStatsRequest {
	r.numTopViewClients = &numTopViewClients
	return r
}

// Specifies the last hours of stats to sort.
func (r ApiGetViewClientStatsRequest) LastHours(lastHours int64) ApiGetViewClientStatsRequest {
	r.lastHours = &lastHours
	return r
}

func (r ApiGetViewClientStatsRequest) Execute() (*ViewClientsStats, *http.Response, error) {
	return r.ApiService.GetViewClientStatsExecute(r)
}

/*
GetViewClientStats Get Stats of View Clients

Get Stats of View Clients.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetViewClientStatsRequest
*/
func (a *StatsAPIService) GetViewClientStats(ctx context.Context) ApiGetViewClientStatsRequest {
	return ApiGetViewClientStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewClientsStats
func (a *StatsAPIService) GetViewClientStatsExecute(r ApiGetViewClientStatsRequest) (*ViewClientsStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewClientsStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetViewClientStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/view-clients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric", r.metric, "")
	}
	if r.numTopViewClients != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numTopViewClients", r.numTopViewClients, "")
	}
	if r.lastHours != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastHours", r.lastHours, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewsStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
	metric *string
	protocol *string
	numTopViews *int64
	lastHours *int64
}

// Specifies the metric to which stats has to be sorted. Defaults to kNumBytesRead.
func (r ApiGetViewsStatsRequest) Metric(metric string) ApiGetViewsStatsRequest {
	r.metric = &metric
	return r
}

// Specifies the protocol to sort. Defaults to kAny.
func (r ApiGetViewsStatsRequest) Protocol(protocol string) ApiGetViewsStatsRequest {
	r.protocol = &protocol
	return r
}

// Specifies the number of view for which stats has to be computed. Returned Views will be sorted in descending order based on the &#39;metric&#39; param. Minimum value has to be 1. Defaults to 100.
func (r ApiGetViewsStatsRequest) NumTopViews(numTopViews int64) ApiGetViewsStatsRequest {
	r.numTopViews = &numTopViews
	return r
}

// Specifies the last hours of stats to sort. Defaults to 24.
func (r ApiGetViewsStatsRequest) LastHours(lastHours int64) ApiGetViewsStatsRequest {
	r.lastHours = &lastHours
	return r
}

func (r ApiGetViewsStatsRequest) Execute() (*ViewsStats, *http.Response, error) {
	return r.ApiService.GetViewsStatsExecute(r)
}

/*
GetViewsStats Get stats for the top views, which are the views with largest value of 'stats.valueInLastHours' for a given combination of 'metric', 'protocol' & 'lastHours' params. The API uses suitable defaults if any of the parameters are not specified.

This api will be deprecated. Use the API '/stats/top-views' instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetViewsStatsRequest

Deprecated
*/
func (a *StatsAPIService) GetViewsStats(ctx context.Context) ApiGetViewsStatsRequest {
	return ApiGetViewsStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewsStats
// Deprecated
func (a *StatsAPIService) GetViewsStatsExecute(r ApiGetViewsStatsRequest) (*ViewsStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewsStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetViewsStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.metric != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric", r.metric, "")
	} else {
		var defaultValue string = "kNumBytesRead"
		r.metric = &defaultValue
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "")
	} else {
		var defaultValue string = "kAny"
		r.protocol = &defaultValue
	}
	if r.numTopViews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numTopViews", r.numTopViews, "")
	} else {
		var defaultValue int64 = 100
		r.numTopViews = &defaultValue
	}
	if r.lastHours != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastHours", r.lastHours, "")
	} else {
		var defaultValue int64 = 24
		r.lastHours = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWorkloadStatsRequest struct {
	ctx context.Context
	ApiService *StatsAPIService
}

func (r ApiGetWorkloadStatsRequest) Execute() (*WorkloadStatsSummary, *http.Response, error) {
	return r.ApiService.GetWorkloadStatsExecute(r)
}

/*
GetWorkloadStats Get Workload Stats Schema.

Get Workload Stats Schema. API will provide the high level information about different Workloads on Cohesity cluster along with their Entity Ids.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetWorkloadStatsRequest
*/
func (a *StatsAPIService) GetWorkloadStats(ctx context.Context) ApiGetWorkloadStatsRequest {
	return ApiGetWorkloadStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WorkloadStatsSummary
func (a *StatsAPIService) GetWorkloadStatsExecute(r ApiGetWorkloadStatsRequest) (*WorkloadStatsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkloadStatsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsAPIService.GetWorkloadStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/stats/workload-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
