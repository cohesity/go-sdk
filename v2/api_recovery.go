/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// RecoveryAPIService RecoveryAPI service
type RecoveryAPIService service

type ApiCancelRecoveryByIdRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	id string
}

func (r ApiCancelRecoveryByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelRecoveryByIdExecute(r)
}

/*
CancelRecoveryById Cancel Recovery for a given id.

Cancel Recovery for a given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of a Recovery.
 @return ApiCancelRecoveryByIdRequest
*/
func (a *RecoveryAPIService) CancelRecoveryById(ctx context.Context, id string) ApiCancelRecoveryByIdRequest {
	return ApiCancelRecoveryByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *RecoveryAPIService) CancelRecoveryByIdExecute(r ApiCancelRecoveryByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.CancelRecoveryById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/{id}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateDownloadFilesAndFoldersRecoveryRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	body *DownloadFilesAndFoldersRequestParams
}

// Specifies the parameters to create a download files and folder recovery.
func (r ApiCreateDownloadFilesAndFoldersRecoveryRequest) Body(body DownloadFilesAndFoldersRequestParams) ApiCreateDownloadFilesAndFoldersRecoveryRequest {
	r.body = &body
	return r
}

func (r ApiCreateDownloadFilesAndFoldersRecoveryRequest) Execute() (*Recovery, *http.Response, error) {
	return r.ApiService.CreateDownloadFilesAndFoldersRecoveryExecute(r)
}

/*
CreateDownloadFilesAndFoldersRecovery Create a download files and folders recovery.

Creates a download files and folders recovery.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDownloadFilesAndFoldersRecoveryRequest
*/
func (a *RecoveryAPIService) CreateDownloadFilesAndFoldersRecovery(ctx context.Context) ApiCreateDownloadFilesAndFoldersRecoveryRequest {
	return ApiCreateDownloadFilesAndFoldersRecoveryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Recovery
func (a *RecoveryAPIService) CreateDownloadFilesAndFoldersRecoveryExecute(r ApiCreateDownloadFilesAndFoldersRecoveryRequest) (*Recovery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Recovery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.CreateDownloadFilesAndFoldersRecovery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/download-files-folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRecoveryRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	body *CreateRecoveryRequest
	requestInitiatorType *string
}

// Specifies the parameters to create a Recovery.
func (r ApiCreateRecoveryRequest) Body(body CreateRecoveryRequest) ApiCreateRecoveryRequest {
	r.body = &body
	return r
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiCreateRecoveryRequest) RequestInitiatorType(requestInitiatorType string) ApiCreateRecoveryRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

func (r ApiCreateRecoveryRequest) Execute() (*Recovery, *http.Response, error) {
	return r.ApiService.CreateRecoveryExecute(r)
}

/*
CreateRecovery Performs a Recovery.

Performs a Recovery.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateRecoveryRequest
*/
func (a *RecoveryAPIService) CreateRecovery(ctx context.Context) ApiCreateRecoveryRequest {
	return ApiCreateRecoveryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Recovery
func (a *RecoveryAPIService) CreateRecoveryExecute(r ApiCreateRecoveryRequest) (*Recovery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Recovery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.CreateRecovery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRecoveryCloneTaskByIdRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	id int64
}

func (r ApiDeleteRecoveryCloneTaskByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecoveryCloneTaskByIdExecute(r)
}

/*
DeleteRecoveryCloneTaskById Delete a restore clone task

Delete a restore clone task with specified id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the Clone Task to delete.
 @return ApiDeleteRecoveryCloneTaskByIdRequest
*/
func (a *RecoveryAPIService) DeleteRecoveryCloneTaskById(ctx context.Context, id int64) ApiDeleteRecoveryCloneTaskByIdRequest {
	return ApiDeleteRecoveryCloneTaskByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *RecoveryAPIService) DeleteRecoveryCloneTaskByIdExecute(r ApiDeleteRecoveryCloneTaskByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.DeleteRecoveryCloneTaskById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/clone/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadFilesFromRecoveryRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	id string
	startOffset *int64
	length *int64
	fileType *string
	sourceName *string
	startTime *string
	includeTenants *bool
}

// Specifies the start offset of file chunk to be downloaded.
func (r ApiDownloadFilesFromRecoveryRequest) StartOffset(startOffset int64) ApiDownloadFilesFromRecoveryRequest {
	r.startOffset = &startOffset
	return r
}

// Specifies the length of bytes to download. This can not be greater than 8MB (8388608 byets)
func (r ApiDownloadFilesFromRecoveryRequest) Length(length int64) ApiDownloadFilesFromRecoveryRequest {
	r.length = &length
	return r
}

// Specifies the downloaded type, i.e: error, success_files_list
func (r ApiDownloadFilesFromRecoveryRequest) FileType(fileType string) ApiDownloadFilesFromRecoveryRequest {
	r.fileType = &fileType
	return r
}

// Specifies the name of the source on which restore is done
func (r ApiDownloadFilesFromRecoveryRequest) SourceName(sourceName string) ApiDownloadFilesFromRecoveryRequest {
	r.sourceName = &sourceName
	return r
}

// Specifies the start time of restore task
func (r ApiDownloadFilesFromRecoveryRequest) StartTime(startTime string) ApiDownloadFilesFromRecoveryRequest {
	r.startTime = &startTime
	return r
}

// Specifies if objects of all the organizations under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiDownloadFilesFromRecoveryRequest) IncludeTenants(includeTenants bool) ApiDownloadFilesFromRecoveryRequest {
	r.includeTenants = &includeTenants
	return r
}

func (r ApiDownloadFilesFromRecoveryRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadFilesFromRecoveryExecute(r)
}

/*
DownloadFilesFromRecovery Download files from the given download file recovery.

Download files from the given download file recovery.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of a Recovery.
 @return ApiDownloadFilesFromRecoveryRequest
*/
func (a *RecoveryAPIService) DownloadFilesFromRecovery(ctx context.Context, id string) ApiDownloadFilesFromRecoveryRequest {
	return ApiDownloadFilesFromRecoveryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *RecoveryAPIService) DownloadFilesFromRecoveryExecute(r ApiDownloadFilesFromRecoveryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.DownloadFilesFromRecovery")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/{id}/download-files"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startOffset", r.startOffset, "")
	}
	if r.length != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "length", r.length, "")
	}
	if r.fileType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileType", r.fileType, "")
	}
	if r.sourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceName", r.sourceName, "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTime", r.startTime, "")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFetchUptierDataRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	archiveUId *string
}

// Archive UID of the current restore.
func (r ApiFetchUptierDataRequest) ArchiveUId(archiveUId string) ApiFetchUptierDataRequest {
	r.archiveUId = &archiveUId
	return r
}

func (r ApiFetchUptierDataRequest) Execute() (*FetchUptierDataResponse, *http.Response, error) {
	return r.ApiService.FetchUptierDataExecute(r)
}

/*
FetchUptierData Fetches the uptier data.

Fetches the uptier data for a restore job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchUptierDataRequest
*/
func (a *RecoveryAPIService) FetchUptierData(ctx context.Context) ApiFetchUptierDataRequest {
	return ApiFetchUptierDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FetchUptierDataResponse
func (a *RecoveryAPIService) FetchUptierDataExecute(r ApiFetchUptierDataRequest) (*FetchUptierDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FetchUptierDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.FetchUptierData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/fetch-uptier-data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.archiveUId == nil {
		return localVarReturnValue, nil, reportError("archiveUId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "archiveUId", r.archiveUId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecoveriesRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	ids *[]string
	returnOnlyChildRecoveries *bool
	tenantIds *[]string
	includeTenants *bool
	startTimeUsecs *int64
	endTimeUsecs *int64
	storageDomainId *int64
	snapshotTargetType *[]string
	archivalTargetType *[]string
	snapshotEnvironments *[]string
	status *[]string
	recoveryActions *[]string
}

// Filter Recoveries for given ids.
func (r ApiGetRecoveriesRequest) Ids(ids []string) ApiGetRecoveriesRequest {
	r.ids = &ids
	return r
}

// Returns only child recoveries if passed as true. This filter should always be used along with &#39;ids&#39; filter. 
func (r ApiGetRecoveriesRequest) ReturnOnlyChildRecoveries(returnOnlyChildRecoveries bool) ApiGetRecoveriesRequest {
	r.returnOnlyChildRecoveries = &returnOnlyChildRecoveries
	return r
}

// TenantIds contains ids of the organizations for which recoveries are to be returned.
func (r ApiGetRecoveriesRequest) TenantIds(tenantIds []string) ApiGetRecoveriesRequest {
	r.tenantIds = &tenantIds
	return r
}

// Specifies if objects of all the organizations under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiGetRecoveriesRequest) IncludeTenants(includeTenants bool) ApiGetRecoveriesRequest {
	r.includeTenants = &includeTenants
	return r
}

// Returns the recoveries which are started after the specific time. This value should be in Unix timestamp epoch in microseconds.
func (r ApiGetRecoveriesRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetRecoveriesRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Returns the recoveries which are started before the specific time. This value should be in Unix timestamp epoch in microseconds.
func (r ApiGetRecoveriesRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetRecoveriesRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Filter by Storage Domain id. Only recoveries writing data to this Storage Domain will be returned.
func (r ApiGetRecoveriesRequest) StorageDomainId(storageDomainId int64) ApiGetRecoveriesRequest {
	r.storageDomainId = &storageDomainId
	return r
}

// Specifies the snapshot&#39;s target type from which recovery has been performed.
func (r ApiGetRecoveriesRequest) SnapshotTargetType(snapshotTargetType []string) ApiGetRecoveriesRequest {
	r.snapshotTargetType = &snapshotTargetType
	return r
}

// Specifies the snapshot&#39;s archival target type from which recovery has been performed. This parameter applies only if &#39;snapshotTargetType&#39; is &#39;Archival&#39;.
func (r ApiGetRecoveriesRequest) ArchivalTargetType(archivalTargetType []string) ApiGetRecoveriesRequest {
	r.archivalTargetType = &archivalTargetType
	return r
}

// Specifies the list of snapshot environment types to filter Recoveries. If empty, Recoveries related to all environments will be returned.
func (r ApiGetRecoveriesRequest) SnapshotEnvironments(snapshotEnvironments []string) ApiGetRecoveriesRequest {
	r.snapshotEnvironments = &snapshotEnvironments
	return r
}

// Specifies the list of run status to filter Recoveries. If empty, Recoveries with all run status will be returned.
func (r ApiGetRecoveriesRequest) Status(status []string) ApiGetRecoveriesRequest {
	r.status = &status
	return r
}

// Specifies the list of recovery actions to filter Recoveries. If empty, Recoveries related to all actions will be returned.
func (r ApiGetRecoveriesRequest) RecoveryActions(recoveryActions []string) ApiGetRecoveriesRequest {
	r.recoveryActions = &recoveryActions
	return r
}

func (r ApiGetRecoveriesRequest) Execute() (*Recoveries, *http.Response, error) {
	return r.ApiService.GetRecoveriesExecute(r)
}

/*
GetRecoveries Lists the Recoveries.

Lists the Recoveries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecoveriesRequest
*/
func (a *RecoveryAPIService) GetRecoveries(ctx context.Context) ApiGetRecoveriesRequest {
	return ApiGetRecoveriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Recoveries
func (a *RecoveryAPIService) GetRecoveriesExecute(r ApiGetRecoveriesRequest) (*Recoveries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Recoveries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.GetRecoveries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "csv")
	}
	if r.returnOnlyChildRecoveries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnOnlyChildRecoveries", r.returnOnlyChildRecoveries, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.storageDomainId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainId", r.storageDomainId, "")
	}
	if r.snapshotTargetType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotTargetType", r.snapshotTargetType, "csv")
	}
	if r.archivalTargetType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archivalTargetType", r.archivalTargetType, "csv")
	}
	if r.snapshotEnvironments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotEnvironments", r.snapshotEnvironments, "csv")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "csv")
	}
	if r.recoveryActions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recoveryActions", r.recoveryActions, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecoveryByIdRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	id string
	includeTenants *bool
}

// Specifies if objects of all the organizations under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiGetRecoveryByIdRequest) IncludeTenants(includeTenants bool) ApiGetRecoveryByIdRequest {
	r.includeTenants = &includeTenants
	return r
}

func (r ApiGetRecoveryByIdRequest) Execute() (*Recovery, *http.Response, error) {
	return r.ApiService.GetRecoveryByIdExecute(r)
}

/*
GetRecoveryById Get Recovery for a given id.

Get Recovery for a given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of a Recovery.
 @return ApiGetRecoveryByIdRequest
*/
func (a *RecoveryAPIService) GetRecoveryById(ctx context.Context, id string) ApiGetRecoveryByIdRequest {
	return ApiGetRecoveryByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Recovery
func (a *RecoveryAPIService) GetRecoveryByIdExecute(r ApiGetRecoveryByIdRequest) (*Recovery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Recovery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.GetRecoveryById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecoveryDebugLogsRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	id string
}

func (r ApiGetRecoveryDebugLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRecoveryDebugLogsExecute(r)
}

/*
GetRecoveryDebugLogs Get the debug logs for a particular recovery operation.

Get the debug logs for a particular recovery operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of a Recovery job.
 @return ApiGetRecoveryDebugLogsRequest
*/
func (a *RecoveryAPIService) GetRecoveryDebugLogs(ctx context.Context, id string) ApiGetRecoveryDebugLogsRequest {
	return ApiGetRecoveryDebugLogsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *RecoveryAPIService) GetRecoveryDebugLogsExecute(r ApiGetRecoveryDebugLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.GetRecoveryDebugLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/{id}/debug-logs"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRecoveryErrorsReportRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	id string
}

func (r ApiGetRecoveryErrorsReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRecoveryErrorsReportExecute(r)
}

/*
GetRecoveryErrorsReport Get the CSV of errors/warnings for a given recovery operation.

Get a CSV error report for given recovery operation. Each row in CSV report contains the File Path, error/warning code and error/warning message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique ID of a Recovery.
 @return ApiGetRecoveryErrorsReportRequest
*/
func (a *RecoveryAPIService) GetRecoveryErrorsReport(ctx context.Context, id string) ApiGetRecoveryErrorsReportRequest {
	return ApiGetRecoveryErrorsReportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *RecoveryAPIService) GetRecoveryErrorsReportExecute(r ApiGetRecoveryErrorsReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.GetRecoveryErrorsReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/{id}/download-messages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTearDownRecoveryByIdRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	id string
}

func (r ApiTearDownRecoveryByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.TearDownRecoveryByIdExecute(r)
}

/*
TearDownRecoveryById Tear down Recovery for a given id.

Tear down Recovery for a given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of a Recovery.
 @return ApiTearDownRecoveryByIdRequest
*/
func (a *RecoveryAPIService) TearDownRecoveryById(ctx context.Context, id string) ApiTearDownRecoveryByIdRequest {
	return ApiTearDownRecoveryByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *RecoveryAPIService) TearDownRecoveryByIdExecute(r ApiTearDownRecoveryByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.TearDownRecoveryById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/{id}/tear-down"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVirtualDiskInformationRequest struct {
	ctx context.Context
	ApiService *RecoveryAPIService
	clusterId *int64
	clusterIncarnationId *int64
	jobId *int64
	objectId *int64
	snapshotId *string
	pointInTimeUsecs *int64
	vaultId *int64
	vaultName *string
	vaultType *string
}

// Specifies the Cohesity Cluster id where the Job was created.
func (r ApiVirtualDiskInformationRequest) ClusterId(clusterId int64) ApiVirtualDiskInformationRequest {
	r.clusterId = &clusterId
	return r
}

// Specifies the incarnation id of the Cohesity Cluster where the Job was created.
func (r ApiVirtualDiskInformationRequest) ClusterIncarnationId(clusterIncarnationId int64) ApiVirtualDiskInformationRequest {
	r.clusterIncarnationId = &clusterIncarnationId
	return r
}

// Specifies the id of the Job that captured the snapshot.
func (r ApiVirtualDiskInformationRequest) JobId(jobId int64) ApiVirtualDiskInformationRequest {
	r.jobId = &jobId
	return r
}

// Specifies the Id of the Protection Source object.
func (r ApiVirtualDiskInformationRequest) ObjectId(objectId int64) ApiVirtualDiskInformationRequest {
	r.objectId = &objectId
	return r
}

// Specifies the snapshot id.
func (r ApiVirtualDiskInformationRequest) SnapshotId(snapshotId string) ApiVirtualDiskInformationRequest {
	r.snapshotId = &snapshotId
	return r
}

// Specifies the Id of the vault where snapshot was taken
func (r ApiVirtualDiskInformationRequest) PointInTimeUsecs(pointInTimeUsecs int64) ApiVirtualDiskInformationRequest {
	r.pointInTimeUsecs = &pointInTimeUsecs
	return r
}

// Specifies the Id of the vault where snapshot was taken
func (r ApiVirtualDiskInformationRequest) VaultId(vaultId int64) ApiVirtualDiskInformationRequest {
	r.vaultId = &vaultId
	return r
}

// Specifies the name of the vault where snapshot was taken
func (r ApiVirtualDiskInformationRequest) VaultName(vaultName string) ApiVirtualDiskInformationRequest {
	r.vaultName = &vaultName
	return r
}

// Specifies the External Target type.
func (r ApiVirtualDiskInformationRequest) VaultType(vaultType string) ApiVirtualDiskInformationRequest {
	r.vaultType = &vaultType
	return r
}

func (r ApiVirtualDiskInformationRequest) Execute() (*VirtualDiskInformationResponseParams, *http.Response, error) {
	return r.ApiService.VirtualDiskInformationExecute(r)
}

/*
VirtualDiskInformation Fetches information of virtual disks

Fetches information of virtual disks of an object such as a VM or a physical server for a given snapshot.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirtualDiskInformationRequest
*/
func (a *RecoveryAPIService) VirtualDiskInformation(ctx context.Context) ApiVirtualDiskInformationRequest {
	return ApiVirtualDiskInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VirtualDiskInformationResponseParams
func (a *RecoveryAPIService) VirtualDiskInformationExecute(r ApiVirtualDiskInformationRequest) (*VirtualDiskInformationResponseParams, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VirtualDiskInformationResponseParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RecoveryAPIService.VirtualDiskInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/recoveries/virtual-disks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clusterId == nil {
		return localVarReturnValue, nil, reportError("clusterId is required and must be specified")
	}
	if r.clusterIncarnationId == nil {
		return localVarReturnValue, nil, reportError("clusterIncarnationId is required and must be specified")
	}
	if r.jobId == nil {
		return localVarReturnValue, nil, reportError("jobId is required and must be specified")
	}
	if r.objectId == nil {
		return localVarReturnValue, nil, reportError("objectId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "clusterId", r.clusterId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "clusterIncarnationId", r.clusterIncarnationId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "jobId", r.jobId, "")
	if r.snapshotId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotId", r.snapshotId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "objectId", r.objectId, "")
	if r.pointInTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pointInTimeUsecs", r.pointInTimeUsecs, "")
	}
	if r.vaultId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vaultId", r.vaultId, "")
	}
	if r.vaultName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vaultName", r.vaultName, "")
	}
	if r.vaultType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vaultType", r.vaultType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
