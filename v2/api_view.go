/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ViewAPIService ViewAPI service
type ViewAPIService service

type ApiAddViewUserQuotaOverridesRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	viewId int64
	body *UserQuotaOverrides
}

// Specifies the parameters to override the default user quota on the view.
func (r ApiAddViewUserQuotaOverridesRequest) Body(body UserQuotaOverrides) ApiAddViewUserQuotaOverridesRequest {
	r.body = &body
	return r
}

func (r ApiAddViewUserQuotaOverridesRequest) Execute() (*UserQuotaOverrides, *http.Response, error) {
	return r.ApiService.AddViewUserQuotaOverridesExecute(r)
}

/*
AddViewUserQuotaOverrides Add User Quota overrides.

Specifies the parameters to override the user quota on the view. User quota on the view should be enabled before setting a user override.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param viewId Specifies the id of a view.
 @return ApiAddViewUserQuotaOverridesRequest
*/
func (a *ViewAPIService) AddViewUserQuotaOverrides(ctx context.Context, viewId int64) ApiAddViewUserQuotaOverridesRequest {
	return ApiAddViewUserQuotaOverridesRequest{
		ApiService: a,
		ctx: ctx,
		viewId: viewId,
	}
}

// Execute executes the request
//  @return UserQuotaOverrides
func (a *ViewAPIService) AddViewUserQuotaOverridesExecute(r ApiAddViewUserQuotaOverridesRequest) (*UserQuotaOverrides, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserQuotaOverrides
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.AddViewUserQuotaOverrides")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{viewId}/user-quotas"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiClearNlmLocksRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	body *ClearNlmLockRequest
}

// Request to clear NLM lock.
func (r ApiClearNlmLocksRequest) Body(body ClearNlmLockRequest) ApiClearNlmLocksRequest {
	r.body = &body
	return r
}

func (r ApiClearNlmLocksRequest) Execute() (*http.Response, error) {
	return r.ApiService.ClearNlmLocksExecute(r)
}

/*
ClearNlmLocks Clear NLM locks.

Clear NLM locks that match the filter criteria specified using parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiClearNlmLocksRequest
*/
func (a *ViewAPIService) ClearNlmLocks(ctx context.Context) ApiClearNlmLocksRequest {
	return ApiClearNlmLocksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ViewAPIService) ClearNlmLocksExecute(r ApiClearNlmLocksRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.ClearNlmLocks")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/nlm-locks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloneViewRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	body *CloneViewParams
}

// Specifies the request to clone the View.
func (r ApiCloneViewRequest) Body(body CloneViewParams) ApiCloneViewRequest {
	r.body = &body
	return r
}

func (r ApiCloneViewRequest) Execute() (*View, *http.Response, error) {
	return r.ApiService.CloneViewExecute(r)
}

/*
CloneView Clone View.

Clone View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the View id to clone.
 @return ApiCloneViewRequest
*/
func (a *ViewAPIService) CloneView(ctx context.Context, id int64) ApiCloneViewRequest {
	return ApiCloneViewRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return View
func (a *ViewAPIService) CloneViewExecute(r ApiCloneViewRequest) (*View, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *View
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.CloneView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloneViewDirectoryRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	body *CloneViewDirectoryParams
}

// Specifies the request to clone View directory.
func (r ApiCloneViewDirectoryRequest) Body(body CloneViewDirectoryParams) ApiCloneViewDirectoryRequest {
	r.body = &body
	return r
}

func (r ApiCloneViewDirectoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloneViewDirectoryExecute(r)
}

/*
CloneViewDirectory Clone View Directory.

Clone View Directory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCloneViewDirectoryRequest
*/
func (a *ViewAPIService) CloneViewDirectory(ctx context.Context) ApiCloneViewDirectoryRequest {
	return ApiCloneViewDirectoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ViewAPIService) CloneViewDirectoryExecute(r ApiCloneViewDirectoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.CloneViewDirectory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/clone-directory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCloseSmbFileOpenRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	body *CloseSmbFileOpenParams
}

// Specifies parameters to close active  SMB file open.
func (r ApiCloseSmbFileOpenRequest) Body(body CloseSmbFileOpenParams) ApiCloseSmbFileOpenRequest {
	r.body = &body
	return r
}

func (r ApiCloseSmbFileOpenRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloseSmbFileOpenExecute(r)
}

/*
CloseSmbFileOpen Close SMB File open.

Close an active SMB file open.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCloseSmbFileOpenRequest
*/
func (a *ViewAPIService) CloseSmbFileOpen(ctx context.Context) ApiCloseSmbFileOpenRequest {
	return ApiCloseSmbFileOpenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ViewAPIService) CloseSmbFileOpenExecute(r ApiCloseSmbFileOpenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.CloseSmbFileOpen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/smb-file-opens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateShareRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	body *Share
}

// Specifies the request to create a Share.
func (r ApiCreateShareRequest) Body(body Share) ApiCreateShareRequest {
	r.body = &body
	return r
}

func (r ApiCreateShareRequest) Execute() (*Share, *http.Response, error) {
	return r.ApiService.CreateShareExecute(r)
}

/*
CreateShare Create a Share.

Create a Share.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateShareRequest
*/
func (a *ViewAPIService) CreateShare(ctx context.Context) ApiCreateShareRequest {
	return ApiCreateShareRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Share
func (a *ViewAPIService) CreateShareExecute(r ApiCreateShareRequest) (*Share, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Share
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.CreateShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateViewRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	body *CreateViewRequest
}

// Request to create a View.
func (r ApiCreateViewRequest) Body(body CreateViewRequest) ApiCreateViewRequest {
	r.body = &body
	return r
}

func (r ApiCreateViewRequest) Execute() (*View, *http.Response, error) {
	return r.ApiService.CreateViewExecute(r)
}

/*
CreateView Create a View

Creates a View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateViewRequest
*/
func (a *ViewAPIService) CreateView(ctx context.Context) ApiCreateViewRequest {
	return ApiCreateViewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return View
func (a *ViewAPIService) CreateViewExecute(r ApiCreateViewRequest) (*View, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *View
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.CreateView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateViewTemplateRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	body *Template
}

// Request to create a view template.
func (r ApiCreateViewTemplateRequest) Body(body Template) ApiCreateViewTemplateRequest {
	r.body = &body
	return r
}

func (r ApiCreateViewTemplateRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.CreateViewTemplateExecute(r)
}

/*
CreateViewTemplate Create a View Template

Creates a View Template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateViewTemplateRequest
*/
func (a *ViewAPIService) CreateViewTemplate(ctx context.Context) ApiCreateViewTemplateRequest {
	return ApiCreateViewTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Template
func (a *ViewAPIService) CreateViewTemplateExecute(r ApiCreateViewTemplateRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.CreateViewTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/view-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteShareRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	name string
}

func (r ApiDeleteShareRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteShareExecute(r)
}

/*
DeleteShare Delete a Share.

Delete a Share.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Specifies the Share name to delete.
 @return ApiDeleteShareRequest
*/
func (a *ViewAPIService) DeleteShare(ctx context.Context, name string) ApiDeleteShareRequest {
	return ApiDeleteShareRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *ViewAPIService) DeleteShareExecute(r ApiDeleteShareRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.DeleteShare")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/shares/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteViewRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
}

func (r ApiDeleteViewRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteViewExecute(r)
}

/*
DeleteView Delete a View

Deletes a View based on given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the View to delete.
 @return ApiDeleteViewRequest
*/
func (a *ViewAPIService) DeleteView(ctx context.Context, id int64) ApiDeleteViewRequest {
	return ApiDeleteViewRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewAPIService) DeleteViewExecute(r ApiDeleteViewRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.DeleteView")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteViewDirectoryQuotaRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	directoryPath *string
	deleteAllDirectoryQuotas *bool
}

// Specifies the directory path to delete. Exactly one of &#39;directoryPath&#39; and &#39;deleteAllDirectoryQuotas&#39; should be provided.
func (r ApiDeleteViewDirectoryQuotaRequest) DirectoryPath(directoryPath string) ApiDeleteViewDirectoryQuotaRequest {
	r.directoryPath = &directoryPath
	return r
}

// Specifies whether to delete all directory quotas for this view. Exactly one of &#39;directoryPath&#39; and &#39;deleteAllDirectoryQuotas&#39; should be provided.
func (r ApiDeleteViewDirectoryQuotaRequest) DeleteAllDirectoryQuotas(deleteAllDirectoryQuotas bool) ApiDeleteViewDirectoryQuotaRequest {
	r.deleteAllDirectoryQuotas = &deleteAllDirectoryQuotas
	return r
}

func (r ApiDeleteViewDirectoryQuotaRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteViewDirectoryQuotaExecute(r)
}

/*
DeleteViewDirectoryQuota Delete directory quota for the View.

Delete directory quota for the View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the View id.
 @return ApiDeleteViewDirectoryQuotaRequest
*/
func (a *ViewAPIService) DeleteViewDirectoryQuota(ctx context.Context, id int64) ApiDeleteViewDirectoryQuotaRequest {
	return ApiDeleteViewDirectoryQuotaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewAPIService) DeleteViewDirectoryQuotaExecute(r ApiDeleteViewDirectoryQuotaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.DeleteViewDirectoryQuota")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}/directory-quotas"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.directoryPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "directoryPath", r.directoryPath, "")
	}
	if r.deleteAllDirectoryQuotas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleteAllDirectoryQuotas", r.deleteAllDirectoryQuotas, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteViewTemplateRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
}

func (r ApiDeleteViewTemplateRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteViewTemplateExecute(r)
}

/*
DeleteViewTemplate Delete a View Template

Deletes a view template based on given template id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the view template to delete.
 @return ApiDeleteViewTemplateRequest
*/
func (a *ViewAPIService) DeleteViewTemplate(ctx context.Context, id int64) ApiDeleteViewTemplateRequest {
	return ApiDeleteViewTemplateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewAPIService) DeleteViewTemplateExecute(r ApiDeleteViewTemplateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.DeleteViewTemplate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/view-template/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteViewUserQuotaOverridesRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	viewId int64
	body *UserQuotaDeleteParams
}

// Specifies parameters to delete user quotas.
func (r ApiDeleteViewUserQuotaOverridesRequest) Body(body UserQuotaDeleteParams) ApiDeleteViewUserQuotaOverridesRequest {
	r.body = &body
	return r
}

func (r ApiDeleteViewUserQuotaOverridesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteViewUserQuotaOverridesExecute(r)
}

/*
DeleteViewUserQuotaOverrides Delete user quota overrides.

Specifies the parameters to delete user quotas on the view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param viewId Specifies the id of a view.
 @return ApiDeleteViewUserQuotaOverridesRequest
*/
func (a *ViewAPIService) DeleteViewUserQuotaOverrides(ctx context.Context, viewId int64) ApiDeleteViewUserQuotaOverridesRequest {
	return ApiDeleteViewUserQuotaOverridesRequest{
		ApiService: a,
		ctx: ctx,
		viewId: viewId,
	}
}

// Execute executes the request
func (a *ViewAPIService) DeleteViewUserQuotaOverridesExecute(r ApiDeleteViewUserQuotaOverridesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.DeleteViewUserQuotaOverrides")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{viewId}/user-quotas"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFileLockStatusRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	path *string
}

// Specifies the file path relative to root of the view.
func (r ApiGetFileLockStatusRequest) Path(path string) ApiGetFileLockStatusRequest {
	r.path = &path
	return r
}

func (r ApiGetFileLockStatusRequest) Execute() (*FileLockStatus, *http.Response, error) {
	return r.ApiService.GetFileLockStatusExecute(r)
}

/*
GetFileLockStatus Get file lock status

Get the lock status of a file in a view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of a view.
 @return ApiGetFileLockStatusRequest
*/
func (a *ViewAPIService) GetFileLockStatus(ctx context.Context, id int64) ApiGetFileLockStatusRequest {
	return ApiGetFileLockStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FileLockStatus
func (a *ViewAPIService) GetFileLockStatusExecute(r ApiGetFileLockStatusRequest) (*FileLockStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileLockStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetFileLockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}/file-lock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNlmLocksRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	filePath *string
	viewName *string
	maxCount *int32
	cookie *string
}

// Specifies the filepath in the view relative to the root filesystem. If this field is specified, viewName field must also be specified.
func (r ApiGetNlmLocksRequest) FilePath(filePath string) ApiGetNlmLocksRequest {
	r.filePath = &filePath
	return r
}

// Specifies the name of the View in which to search. If a view name is not specified, all the views in the Cluster is searched. This field is mandatory if filePath field is specified.
func (r ApiGetNlmLocksRequest) ViewName(viewName string) ApiGetNlmLocksRequest {
	r.viewName = &viewName
	return r
}

// Specifies the maximum number of NLM locks to return in the response. By default, maxCount is set to 1000. At any given instance, maxCount value cannot be set to more than 1000.
func (r ApiGetNlmLocksRequest) MaxCount(maxCount int32) ApiGetNlmLocksRequest {
	r.maxCount = &maxCount
	return r
}

// Specifies the pagination cookie. If this is set, next set of locks just after the previous response are returned. If this is not set, first set of NLM locks are returned.\&quot;
func (r ApiGetNlmLocksRequest) Cookie(cookie string) ApiGetNlmLocksRequest {
	r.cookie = &cookie
	return r
}

func (r ApiGetNlmLocksRequest) Execute() (*GetNlmLocksResult, *http.Response, error) {
	return r.ApiService.GetNlmLocksExecute(r)
}

/*
GetNlmLocks Get NLM locks.

Get the list of NLM locks in the views.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNlmLocksRequest
*/
func (a *ViewAPIService) GetNlmLocks(ctx context.Context) ApiGetNlmLocksRequest {
	return ApiGetNlmLocksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetNlmLocksResult
func (a *ViewAPIService) GetNlmLocksExecute(r ApiGetNlmLocksRequest) (*GetNlmLocksResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNlmLocksResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetNlmLocks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/nlm-locks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filePath", r.filePath, "")
	}
	if r.viewName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewName", r.viewName, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.cookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cookie", r.cookie, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQosPoliciesRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
}

func (r ApiGetQosPoliciesRequest) Execute() (*QosPoliciesResult, *http.Response, error) {
	return r.ApiService.GetQosPoliciesExecute(r)
}

/*
GetQosPolicies Get QoS Policies.

Get the list of QoS policies on the Cohesity cluster.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetQosPoliciesRequest
*/
func (a *ViewAPIService) GetQosPolicies(ctx context.Context) ApiGetQosPoliciesRequest {
	return ApiGetQosPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return QosPoliciesResult
func (a *ViewAPIService) GetQosPoliciesExecute(r ApiGetQosPoliciesRequest) (*QosPoliciesResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QosPoliciesResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetQosPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/qos-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSharesRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	name *string
	matchPartialName *bool
	maxCount *int32
	cookie *string
	tenantIds *[]string
	includeTenants *bool
}

// Specifies the Share name.
func (r ApiGetSharesRequest) Name(name string) ApiGetSharesRequest {
	r.name = &name
	return r
}

// If true, the share name is matched by any partial rather than exactly matched.
func (r ApiGetSharesRequest) MatchPartialName(matchPartialName bool) ApiGetSharesRequest {
	r.matchPartialName = &matchPartialName
	return r
}

// Specifies a limit on the number of Shares returned. If maxCount is not specified, the first 2000 Shares.
func (r ApiGetSharesRequest) MaxCount(maxCount int32) ApiGetSharesRequest {
	r.maxCount = &maxCount
	return r
}

// Specifies the pagination cookie. Expected to be empty in the first call to the API. To get the next set of results, set this value to the pagination cookie value returned in the response of the previous call.
func (r ApiGetSharesRequest) Cookie(cookie string) ApiGetSharesRequest {
	r.cookie = &cookie
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetSharesRequest) TenantIds(tenantIds []string) ApiGetSharesRequest {
	r.tenantIds = &tenantIds
	return r
}

// IncludeTenants specifies if objects of all the tenants under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiGetSharesRequest) IncludeTenants(includeTenants bool) ApiGetSharesRequest {
	r.includeTenants = &includeTenants
	return r
}

func (r ApiGetSharesRequest) Execute() (*Shares, *http.Response, error) {
	return r.ApiService.GetSharesExecute(r)
}

/*
GetShares Get Shares.

If no parameters are specified, all shares on the Cohesity Cluster are returned. Specifying share name/prefix filters the results that are returned. NOTE: If maxCount is set and the number of Shares returned exceeds the maxCount, there are more Share to return. To get the next set of Views, send another request and specify the pagination cookie from the previous response. If maxCount is not specified, the first 2000 Shares.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSharesRequest
*/
func (a *ViewAPIService) GetShares(ctx context.Context) ApiGetSharesRequest {
	return ApiGetSharesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Shares
func (a *ViewAPIService) GetSharesExecute(r ApiGetSharesRequest) (*Shares, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Shares
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.matchPartialName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchPartialName", r.matchPartialName, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.cookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cookie", r.cookie, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewByIdRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
}

func (r ApiGetViewByIdRequest) Execute() (*View, *http.Response, error) {
	return r.ApiService.GetViewByIdExecute(r)
}

/*
GetViewById Get a View by Id

Get a View based on given Id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the View to fetch.
 @return ApiGetViewByIdRequest
*/
func (a *ViewAPIService) GetViewById(ctx context.Context, id int64) ApiGetViewByIdRequest {
	return ApiGetViewByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return View
func (a *ViewAPIService) GetViewByIdExecute(r ApiGetViewByIdRequest) (*View, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *View
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetViewById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewClientsRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	protocols *[]string
	viewIds *[]int64
	nodeIp *string
	maxCount *int32
}

// Specifies a list of protocols to filter the clients.
func (r ApiGetViewClientsRequest) Protocols(protocols []string) ApiGetViewClientsRequest {
	r.protocols = &protocols
	return r
}

// Specifies a list of View ids. Only clients connected to these Views will be returned.
func (r ApiGetViewClientsRequest) ViewIds(viewIds []int64) ApiGetViewClientsRequest {
	r.viewIds = &viewIds
	return r
}

// Specifies a node ip. Only clients connected to this node will be returned.
func (r ApiGetViewClientsRequest) NodeIp(nodeIp string) ApiGetViewClientsRequest {
	r.nodeIp = &nodeIp
	return r
}

// Specifies the maximum number of connections to return for SMB and NFS protocols respectively.
func (r ApiGetViewClientsRequest) MaxCount(maxCount int32) ApiGetViewClientsRequest {
	r.maxCount = &maxCount
	return r
}

func (r ApiGetViewClientsRequest) Execute() (*ViewClients, *http.Response, error) {
	return r.ApiService.GetViewClientsExecute(r)
}

/*
GetViewClients Get View Clients.

Get View Clients.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetViewClientsRequest
*/
func (a *ViewAPIService) GetViewClients(ctx context.Context) ApiGetViewClientsRequest {
	return ApiGetViewClientsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewClients
func (a *ViewAPIService) GetViewClientsExecute(r ApiGetViewClientsRequest) (*ViewClients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewClients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetViewClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/view-clients"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.protocols != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocols", r.protocols, "csv")
	}
	if r.viewIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewIds", r.viewIds, "csv")
	}
	if r.nodeIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeIp", r.nodeIp, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewClientsSummaryRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	viewIds *[]int64
}

// Specifies a list of View ids. Only clients connected to these Views will be included in the summary.
func (r ApiGetViewClientsSummaryRequest) ViewIds(viewIds []int64) ApiGetViewClientsSummaryRequest {
	r.viewIds = &viewIds
	return r
}

func (r ApiGetViewClientsSummaryRequest) Execute() (*ViewClientsSummary, *http.Response, error) {
	return r.ApiService.GetViewClientsSummaryExecute(r)
}

/*
GetViewClientsSummary Get View Clients Summary.

Get View Clients Summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetViewClientsSummaryRequest
*/
func (a *ViewAPIService) GetViewClientsSummary(ctx context.Context) ApiGetViewClientsSummaryRequest {
	return ApiGetViewClientsSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewClientsSummary
func (a *ViewAPIService) GetViewClientsSummaryExecute(r ApiGetViewClientsSummaryRequest) (*ViewClientsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewClientsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetViewClientsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/view-clients/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewIds", r.viewIds, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewDirectoryQuotasRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	maxCount *int64
	cookie *int64
}

// Specifies a limit on the number of quotas returned.
func (r ApiGetViewDirectoryQuotasRequest) MaxCount(maxCount int64) ApiGetViewDirectoryQuotasRequest {
	r.maxCount = &maxCount
	return r
}

// Specifies the cookie.
func (r ApiGetViewDirectoryQuotasRequest) Cookie(cookie int64) ApiGetViewDirectoryQuotasRequest {
	r.cookie = &cookie
	return r
}

func (r ApiGetViewDirectoryQuotasRequest) Execute() (*ViewDirectoryQuotas, *http.Response, error) {
	return r.ApiService.GetViewDirectoryQuotasExecute(r)
}

/*
GetViewDirectoryQuotas Get directory quotas for the View.

Get directory quotas for the View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the View id.
 @return ApiGetViewDirectoryQuotasRequest
*/
func (a *ViewAPIService) GetViewDirectoryQuotas(ctx context.Context, id int64) ApiGetViewDirectoryQuotasRequest {
	return ApiGetViewDirectoryQuotasRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ViewDirectoryQuotas
func (a *ViewAPIService) GetViewDirectoryQuotasExecute(r ApiGetViewDirectoryQuotasRequest) (*ViewDirectoryQuotas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewDirectoryQuotas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetViewDirectoryQuotas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}/directory-quotas"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.cookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cookie", r.cookie, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewUserQuotasRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	viewId int64
	includeUsage *bool
	includeUserWithQuotaOverridesOnly *bool
	excludeUsersWithinAlertThreshold *bool
	summaryOnly *bool
	outputFormat *string
	topQuotas *int64
	maxCount *int64
	cookie *string
	unixUid *int32
	sid *string
}

// If set to true, the logical usage info is included only for users with quota overrides. By default, it is set to false
func (r ApiGetViewUserQuotasRequest) IncludeUsage(includeUsage bool) ApiGetViewUserQuotasRequest {
	r.includeUsage = &includeUsage
	return r
}

// If set to true, the result will only contain user with user quota override enabled. By default, this field is set to false, and it&#39;s only in effect when &#39;SummaryOnly&#39; is set to false.
func (r ApiGetViewUserQuotasRequest) IncludeUserWithQuotaOverridesOnly(includeUserWithQuotaOverridesOnly bool) ApiGetViewUserQuotasRequest {
	r.includeUserWithQuotaOverridesOnly = &includeUserWithQuotaOverridesOnly
	return r
}

// This field can be set only when includeUsage is set to true. By default, all the users with logical usage &gt; 0 will be returned in the result. If this field is set to true, only the list of users who has exceeded the alert threshold will be returned.
func (r ApiGetViewUserQuotasRequest) ExcludeUsersWithinAlertThreshold(excludeUsersWithinAlertThreshold bool) ApiGetViewUserQuotasRequest {
	r.excludeUsersWithinAlertThreshold = &excludeUsersWithinAlertThreshold
	return r
}

// Specifies a flag to just return a summary. If set to true, it returns the summary of users for a view. By default, it is set to false.
func (r ApiGetViewUserQuotasRequest) SummaryOnly(summaryOnly bool) ApiGetViewUserQuotasRequest {
	r.summaryOnly = &summaryOnly
	return r
}

// OutputFormat is the Output format for the output. If it is not specified, default is json.
func (r ApiGetViewUserQuotasRequest) OutputFormat(outputFormat string) ApiGetViewUserQuotasRequest {
	r.outputFormat = &outputFormat
	return r
}

// TopQuotas is the quotas sorted by quota usage in descending order. This parameter defines number of results to be returned. No pagination cookie is returned if this parameter is set.
func (r ApiGetViewUserQuotasRequest) TopQuotas(topQuotas int64) ApiGetViewUserQuotasRequest {
	r.topQuotas = &topQuotas
	return r
}

// Specifies a limit on the number of quotas returned. If maxCount is not set, response will have a maximum of 100 results. This parameter will be ignored if &#39;topQuotas&#39; is set.
func (r ApiGetViewUserQuotasRequest) MaxCount(maxCount int64) ApiGetViewUserQuotasRequest {
	r.maxCount = &maxCount
	return r
}

// Specifies the cookie. If there are more results than maxCount, response will include a cookie with has to be set as part of the next GET request.
func (r ApiGetViewUserQuotasRequest) Cookie(cookie string) ApiGetViewUserQuotasRequest {
	r.cookie = &cookie
	return r
}

// Specifies the user identifier of an Unix user. If a valid unix-id to SID mappings are available (i.e., when mixed mode is enabled) the server will perform the necessary id mapping and return the correct usage irrespective of whether the unix id / SID is provided.
func (r ApiGetViewUserQuotasRequest) UnixUid(unixUid int32) ApiGetViewUserQuotasRequest {
	r.unixUid = &unixUid
	return r
}

// Specifies the user identifier of a SMB user. If a valid unix-id to SID mappings are available (i.e., when mixed mode is enabled) the server will perform the necessary id mapping and return the correct usage irrespective of whether the unix id / SID is provided.
func (r ApiGetViewUserQuotasRequest) Sid(sid string) ApiGetViewUserQuotasRequest {
	r.sid = &sid
	return r
}

func (r ApiGetViewUserQuotasRequest) Execute() (*ViewUserQuotas, *http.Response, error) {
	return r.ApiService.GetViewUserQuotasExecute(r)
}

/*
GetViewUserQuotas Get View user quotas.

Get user quotas for the View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param viewId Specifies the View id.
 @return ApiGetViewUserQuotasRequest
*/
func (a *ViewAPIService) GetViewUserQuotas(ctx context.Context, viewId int64) ApiGetViewUserQuotasRequest {
	return ApiGetViewUserQuotasRequest{
		ApiService: a,
		ctx: ctx,
		viewId: viewId,
	}
}

// Execute executes the request
//  @return ViewUserQuotas
func (a *ViewAPIService) GetViewUserQuotasExecute(r ApiGetViewUserQuotasRequest) (*ViewUserQuotas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewUserQuotas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetViewUserQuotas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{viewId}/user-quotas"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsage", r.includeUsage, "")
	}
	if r.includeUserWithQuotaOverridesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUserWithQuotaOverridesOnly", r.includeUserWithQuotaOverridesOnly, "")
	}
	if r.excludeUsersWithinAlertThreshold != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeUsersWithinAlertThreshold", r.excludeUsersWithinAlertThreshold, "")
	}
	if r.summaryOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryOnly", r.summaryOnly, "")
	}
	if r.outputFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputFormat", r.outputFormat, "")
	}
	if r.topQuotas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topQuotas", r.topQuotas, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.cookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cookie", r.cookie, "")
	}
	if r.unixUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unixUid", r.unixUid, "")
	}
	if r.sid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sid", r.sid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewsRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	viewNames *[]string
	viewIds *[]int64
	storageDomainIds *[]int64
	storageDomainNames *[]string
	protocolAccesses *[]string
	matchPartialNames *bool
	maxCount *int32
	includeInternalViews *bool
	includeProtectionGroups *bool
	maxViewId *int64
	includeInactive *bool
	protectionGroupIds *[]int64
	viewProtectionGroupIds *[]string
	viewCountOnly *bool
	summaryOnly *bool
	sortByLogicalUsage *bool
	internalAccessSids *[]string
	matchAliasNames *bool
	tenantIds *[]string
	includeTenants *bool
	includeStats *bool
	includeFileCountBySize *bool
	includeViewsWithAntivirusEnabledOnly *bool
	includeViewsWithDataLockEnabledOnly *bool
	filerAuditLogEnabled *bool
	categories *[]string
	viewProtectionTypes *[]string
	lastRunAnyStatuses *[]string
	lastRunLocalBackupStatuses *[]string
	lastRunReplicationStatuses *[]string
	lastRunArchivalStatuses *[]string
	isProtected *bool
	qosPrincipalIds *[]int64
	qosPolicies *[]string
	useCachedData *bool
	includeDeletedProtectionGroups *bool
	returnAllViews *bool
	includeS3MigrationOnly *bool
	s3MigrationState *string
}

// Filter by a list of View names.
func (r ApiGetViewsRequest) ViewNames(viewNames []string) ApiGetViewsRequest {
	r.viewNames = &viewNames
	return r
}

// Filter by a list of View ids.
func (r ApiGetViewsRequest) ViewIds(viewIds []int64) ApiGetViewsRequest {
	r.viewIds = &viewIds
	return r
}

// Filter by a list of Storage Domains (View Boxes) specified by id.
func (r ApiGetViewsRequest) StorageDomainIds(storageDomainIds []int64) ApiGetViewsRequest {
	r.storageDomainIds = &storageDomainIds
	return r
}

// Filter by a list of View Box names.
func (r ApiGetViewsRequest) StorageDomainNames(storageDomainNames []string) ApiGetViewsRequest {
	r.storageDomainNames = &storageDomainNames
	return r
}

// Filter by a list of protocol accesses. Only views with protocol accesses in these specified accesses list will be returned.
func (r ApiGetViewsRequest) ProtocolAccesses(protocolAccesses []string) ApiGetViewsRequest {
	r.protocolAccesses = &protocolAccesses
	return r
}

// If true, the names in viewNames are matched by any partial rather than exactly matched.
func (r ApiGetViewsRequest) MatchPartialNames(matchPartialNames bool) ApiGetViewsRequest {
	r.matchPartialNames = &matchPartialNames
	return r
}

// Specifies a limit on the number of Views returned.
func (r ApiGetViewsRequest) MaxCount(maxCount int32) ApiGetViewsRequest {
	r.maxCount = &maxCount
	return r
}

// Specifies if internal Views created by the Cohesity Cluster are also returned. In addition, regular Views are returned.
func (r ApiGetViewsRequest) IncludeInternalViews(includeInternalViews bool) ApiGetViewsRequest {
	r.includeInternalViews = &includeInternalViews
	return r
}

// Specifies if Protection Groups information needs to be returned along with view metadata. By default, if not set or set to true, Group information is returned.
func (r ApiGetViewsRequest) IncludeProtectionGroups(includeProtectionGroups bool) ApiGetViewsRequest {
	r.includeProtectionGroups = &includeProtectionGroups
	return r
}

// If the number of Views to return exceeds the maxCount specified in the original request, specify the id of the last View from the viewList in the previous response to get the next set of Views.
func (r ApiGetViewsRequest) MaxViewId(maxViewId int64) ApiGetViewsRequest {
	r.maxViewId = &maxViewId
	return r
}

// Specifies if inactive Views on this Remote Cluster (which have Snapshots copied by replication) should also be returned. Inactive Views are not counted towards the maxCount. By default, this field is set to false.
func (r ApiGetViewsRequest) IncludeInactive(includeInactive bool) ApiGetViewsRequest {
	r.includeInactive = &includeInactive
	return r
}

// This field will be deprecated. Filter by Protection Group ids. Return Views that are being protected by listed Groups, which are specified by ids. If both protectionGroupIds and viewProtectionGroupIds are specified, only viewProtectionGroupIds will be used.
func (r ApiGetViewsRequest) ProtectionGroupIds(protectionGroupIds []int64) ApiGetViewsRequest {
	r.protectionGroupIds = &protectionGroupIds
	return r
}

// Filter by Protection Group ids. Return Views that are being protected by listed Groups, which are specified by ids.
func (r ApiGetViewsRequest) ViewProtectionGroupIds(viewProtectionGroupIds []string) ApiGetViewsRequest {
	r.viewProtectionGroupIds = &viewProtectionGroupIds
	return r
}

// Whether to get just the total number of views with the given input filters. If the flag is true, we ignore the parameter &#39;maxViews&#39; for the count. Also, if flag is true, list of views will not be returned.
func (r ApiGetViewsRequest) ViewCountOnly(viewCountOnly bool) ApiGetViewsRequest {
	r.viewCountOnly = &viewCountOnly
	return r
}

// Whether to get only view summary including &#39;name&#39;, &#39;viewId&#39;, &#39;storageDomainName&#39;, &#39;storageDomainId&#39; and &#39;tenantId&#39;.
func (r ApiGetViewsRequest) SummaryOnly(summaryOnly bool) ApiGetViewsRequest {
	r.summaryOnly = &summaryOnly
	return r
}

// If set to true, the list is sorted descending by logical usage.
func (r ApiGetViewsRequest) SortByLogicalUsage(sortByLogicalUsage bool) ApiGetViewsRequest {
	r.sortByLogicalUsage = &sortByLogicalUsage
	return r
}

// Sids of restricted principals who can access the view. This is an internal field and therefore does not have json tag.
func (r ApiGetViewsRequest) InternalAccessSids(internalAccessSids []string) ApiGetViewsRequest {
	r.internalAccessSids = &internalAccessSids
	return r
}

// If true, view aliases are also matched with the names in viewNames.
func (r ApiGetViewsRequest) MatchAliasNames(matchAliasNames bool) ApiGetViewsRequest {
	r.matchAliasNames = &matchAliasNames
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetViewsRequest) TenantIds(tenantIds []string) ApiGetViewsRequest {
	r.tenantIds = &tenantIds
	return r
}

// IncludeTenants specifies if objects of all the tenants under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiGetViewsRequest) IncludeTenants(includeTenants bool) ApiGetViewsRequest {
	r.includeTenants = &includeTenants
	return r
}

// If set to true, stats of views will be returned. By default this parameter is set to false.
func (r ApiGetViewsRequest) IncludeStats(includeStats bool) ApiGetViewsRequest {
	r.includeStats = &includeStats
	return r
}

// Whether to include View file count by size.
func (r ApiGetViewsRequest) IncludeFileCountBySize(includeFileCountBySize bool) ApiGetViewsRequest {
	r.includeFileCountBySize = &includeFileCountBySize
	return r
}

// If set to true, the list will contain only the views for which antivirus scan is enabled.
func (r ApiGetViewsRequest) IncludeViewsWithAntivirusEnabledOnly(includeViewsWithAntivirusEnabledOnly bool) ApiGetViewsRequest {
	r.includeViewsWithAntivirusEnabledOnly = &includeViewsWithAntivirusEnabledOnly
	return r
}

// If set to true, the list will contain only the views for which either file level data lock is enabled or view level data lock is enabled.
func (r ApiGetViewsRequest) IncludeViewsWithDataLockEnabledOnly(includeViewsWithDataLockEnabledOnly bool) ApiGetViewsRequest {
	r.includeViewsWithDataLockEnabledOnly = &includeViewsWithDataLockEnabledOnly
	return r
}

// If set to true, only views with filer audit log enabled will be returned. If set to false, only views with filer audit log disabled will be returned.
func (r ApiGetViewsRequest) FilerAuditLogEnabled(filerAuditLogEnabled bool) ApiGetViewsRequest {
	r.filerAuditLogEnabled = &filerAuditLogEnabled
	return r
}

// Filter by a list of View categories.
func (r ApiGetViewsRequest) Categories(categories []string) ApiGetViewsRequest {
	r.categories = &categories
	return r
}

// Filter by a list of View protection types. Supported types: [Local Archival ReplicationOut ReplicationIn UnProtected]. UnProtected is mutually exclusive from remaining types.
func (r ApiGetViewsRequest) ViewProtectionTypes(viewProtectionTypes []string) ApiGetViewsRequest {
	r.viewProtectionTypes = &viewProtectionTypes
	return r
}

// Filter by last any run status of the view.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetViewsRequest) LastRunAnyStatuses(lastRunAnyStatuses []string) ApiGetViewsRequest {
	r.lastRunAnyStatuses = &lastRunAnyStatuses
	return r
}

// Filter by last local backup run status of the view.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetViewsRequest) LastRunLocalBackupStatuses(lastRunLocalBackupStatuses []string) ApiGetViewsRequest {
	r.lastRunLocalBackupStatuses = &lastRunLocalBackupStatuses
	return r
}

// Filter by last remote replication run status of the view.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetViewsRequest) LastRunReplicationStatuses(lastRunReplicationStatuses []string) ApiGetViewsRequest {
	r.lastRunReplicationStatuses = &lastRunReplicationStatuses
	return r
}

// Filter by last cloud archival run status of the view.&lt;br&gt; &#39;Running&#39; indicates that the run is still running.&lt;br&gt; &#39;Canceled&#39; indicates that the run has been canceled.&lt;br&gt; &#39;Canceling&#39; indicates that the run is in the process of being canceled.&lt;br&gt; &#39;Failed&#39; indicates that the run has failed.&lt;br&gt; &#39;Missed&#39; indicates that the run was unable to take place at the scheduled time because the previous run was still happening.&lt;br&gt; &#39;Succeeded&#39; indicates that the run has finished successfully.&lt;br&gt; &#39;SucceededWithWarning&#39; indicates that the run finished successfully, but there were some warning messages.&lt;br&gt; &#39;Skipped&#39; indicates that the run was skipped.
func (r ApiGetViewsRequest) LastRunArchivalStatuses(lastRunArchivalStatuses []string) ApiGetViewsRequest {
	r.lastRunArchivalStatuses = &lastRunArchivalStatuses
	return r
}

// Specifies the protection status of Views. If set to true, only protected Views will be returned. If set to false, only unprotected Views will be returned.
func (r ApiGetViewsRequest) IsProtected(isProtected bool) ApiGetViewsRequest {
	r.isProtected = &isProtected
	return r
}

// qosPrincipalIds contains ids of the QoS principal for which views are to be returned. This field is deprecated.
func (r ApiGetViewsRequest) QosPrincipalIds(qosPrincipalIds []int64) ApiGetViewsRequest {
	r.qosPrincipalIds = &qosPrincipalIds
	return r
}

// Specifies a filter for Views based on the qosPolicies. This param will be prioritized if qosPrincipalIds is also specified.
func (r ApiGetViewsRequest) QosPolicies(qosPolicies []string) ApiGetViewsRequest {
	r.qosPolicies = &qosPolicies
	return r
}

// Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetViewsRequest) UseCachedData(useCachedData bool) ApiGetViewsRequest {
	r.useCachedData = &useCachedData
	return r
}

// Specifies if deleted Protection Groups information needs to be returned along with view metadata. By default, deleted Protection Groups are not returned. This is only applied if used along with any view protection related parameter.
func (r ApiGetViewsRequest) IncludeDeletedProtectionGroups(includeDeletedProtectionGroups bool) ApiGetViewsRequest {
	r.includeDeletedProtectionGroups = &includeDeletedProtectionGroups
	return r
}

// Specifies if all the Views should be returned as part of the response.
func (r ApiGetViewsRequest) ReturnAllViews(returnAllViews bool) ApiGetViewsRequest {
	r.returnAllViews = &returnAllViews
	return r
}

// Specifies whether to return only views which have a s3 migration state.
func (r ApiGetViewsRequest) IncludeS3MigrationOnly(includeS3MigrationOnly bool) ApiGetViewsRequest {
	r.includeS3MigrationOnly = &includeS3MigrationOnly
	return r
}

// Filter the list of Views by S3 Migration Statuses. Supported filter values are [Enabled, UnderMigration, Paused, Completed, Eligible].\&quot; If &#x60;s3MigrationState&#x60; is specified then &#x60;includeS3MigrationOnly&#x60; param should also be set to true.
func (r ApiGetViewsRequest) S3MigrationState(s3MigrationState string) ApiGetViewsRequest {
	r.s3MigrationState = &s3MigrationState
	return r
}

func (r ApiGetViewsRequest) Execute() (*GetViewsResult, *http.Response, error) {
	return r.ApiService.GetViewsExecute(r)
}

/*
GetViews List Views

If no parameters are specified, all Views on the Cohesity Cluster are returned.
Specifying parameters filters the results that are returned.
NOTE: If maxCount is set and the number of Views returned exceeds the maxCount,
there are more Views to return.
To get the next set of Views, send another request and specify the id of the
last View returned in viewList from the previous response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetViewsRequest
*/
func (a *ViewAPIService) GetViews(ctx context.Context) ApiGetViewsRequest {
	return ApiGetViewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetViewsResult
func (a *ViewAPIService) GetViewsExecute(r ApiGetViewsRequest) (*GetViewsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetViewsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewNames", r.viewNames, "csv")
	}
	if r.viewIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewIds", r.viewIds, "csv")
	}
	if r.storageDomainIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainIds", r.storageDomainIds, "csv")
	}
	if r.storageDomainNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainNames", r.storageDomainNames, "csv")
	}
	if r.protocolAccesses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocolAccesses", r.protocolAccesses, "csv")
	}
	if r.matchPartialNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchPartialNames", r.matchPartialNames, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.includeInternalViews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInternalViews", r.includeInternalViews, "")
	}
	if r.includeProtectionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeProtectionGroups", r.includeProtectionGroups, "")
	}
	if r.maxViewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxViewId", r.maxViewId, "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInactive", r.includeInactive, "")
	}
	if r.protectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectionGroupIds", r.protectionGroupIds, "csv")
	}
	if r.viewProtectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewProtectionGroupIds", r.viewProtectionGroupIds, "csv")
	}
	if r.viewCountOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewCountOnly", r.viewCountOnly, "")
	}
	if r.summaryOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summaryOnly", r.summaryOnly, "")
	}
	if r.sortByLogicalUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortByLogicalUsage", r.sortByLogicalUsage, "")
	}
	if r.internalAccessSids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "internalAccessSids", r.internalAccessSids, "csv")
	}
	if r.matchAliasNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "matchAliasNames", r.matchAliasNames, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeStats", r.includeStats, "")
	}
	if r.includeFileCountBySize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFileCountBySize", r.includeFileCountBySize, "")
	}
	if r.includeViewsWithAntivirusEnabledOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeViewsWithAntivirusEnabledOnly", r.includeViewsWithAntivirusEnabledOnly, "")
	}
	if r.includeViewsWithDataLockEnabledOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeViewsWithDataLockEnabledOnly", r.includeViewsWithDataLockEnabledOnly, "")
	}
	if r.filerAuditLogEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filerAuditLogEnabled", r.filerAuditLogEnabled, "")
	}
	if r.categories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categories", r.categories, "csv")
	}
	if r.viewProtectionTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewProtectionTypes", r.viewProtectionTypes, "csv")
	}
	if r.lastRunAnyStatuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunAnyStatuses", r.lastRunAnyStatuses, "csv")
	}
	if r.lastRunLocalBackupStatuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunLocalBackupStatuses", r.lastRunLocalBackupStatuses, "csv")
	}
	if r.lastRunReplicationStatuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunReplicationStatuses", r.lastRunReplicationStatuses, "csv")
	}
	if r.lastRunArchivalStatuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunArchivalStatuses", r.lastRunArchivalStatuses, "csv")
	}
	if r.isProtected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isProtected", r.isProtected, "")
	}
	if r.qosPrincipalIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qosPrincipalIds", r.qosPrincipalIds, "csv")
	}
	if r.qosPolicies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qosPolicies", r.qosPolicies, "csv")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	if r.includeDeletedProtectionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeletedProtectionGroups", r.includeDeletedProtectionGroups, "")
	}
	if r.returnAllViews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "returnAllViews", r.returnAllViews, "")
	}
	if r.includeS3MigrationOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeS3MigrationOnly", r.includeS3MigrationOnly, "")
	}
	if r.s3MigrationState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "s3MigrationState", r.s3MigrationState, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewsSummaryRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	msecsBeforeCurrentTimeToCompare *int64
	useCachedData *bool
	includeInternalViews *bool
	tenantIds *[]string
	includeTenants *bool
	includeDeletedProtectionGroups *bool
}

// Specifies the time in msecs before current time to compare with.
func (r ApiGetViewsSummaryRequest) MsecsBeforeCurrentTimeToCompare(msecsBeforeCurrentTimeToCompare int64) ApiGetViewsSummaryRequest {
	r.msecsBeforeCurrentTimeToCompare = &msecsBeforeCurrentTimeToCompare
	return r
}

// Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiGetViewsSummaryRequest) UseCachedData(useCachedData bool) ApiGetViewsSummaryRequest {
	r.useCachedData = &useCachedData
	return r
}

// Specifies if internal Views created by the Cohesity Cluster are also returned. In addition, regular Views are returned.
func (r ApiGetViewsSummaryRequest) IncludeInternalViews(includeInternalViews bool) ApiGetViewsSummaryRequest {
	r.includeInternalViews = &includeInternalViews
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiGetViewsSummaryRequest) TenantIds(tenantIds []string) ApiGetViewsSummaryRequest {
	r.tenantIds = &tenantIds
	return r
}

// IncludeTenants specifies if objects of all the tenants under the hierarchy of the logged in user&#39;s organization should be returned.
func (r ApiGetViewsSummaryRequest) IncludeTenants(includeTenants bool) ApiGetViewsSummaryRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies if deleted Protection Groups information needs to be returned along with view metadata. By default, deleted Protection Groups are not returned. This is only applied if used along with any view protection related parameter.
func (r ApiGetViewsSummaryRequest) IncludeDeletedProtectionGroups(includeDeletedProtectionGroups bool) ApiGetViewsSummaryRequest {
	r.includeDeletedProtectionGroups = &includeDeletedProtectionGroups
	return r
}

func (r ApiGetViewsSummaryRequest) Execute() (*ViewsSummary, *http.Response, error) {
	return r.ApiService.GetViewsSummaryExecute(r)
}

/*
GetViewsSummary Get Views summary.

Get Views summary.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetViewsSummaryRequest
*/
func (a *ViewAPIService) GetViewsSummary(ctx context.Context) ApiGetViewsSummaryRequest {
	return ApiGetViewsSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ViewsSummary
func (a *ViewAPIService) GetViewsSummaryExecute(r ApiGetViewsSummaryRequest) (*ViewsSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.GetViewsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views-summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.msecsBeforeCurrentTimeToCompare != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "msecsBeforeCurrentTimeToCompare", r.msecsBeforeCurrentTimeToCompare, "")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	if r.includeInternalViews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInternalViews", r.includeInternalViews, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.includeDeletedProtectionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeletedProtectionGroups", r.includeDeletedProtectionGroups, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSmbFileOpensRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	filePath *string
	viewName *string
	maxCount *int32
	cookie *string
}

// Specifies the filepath in the Cohesity View relative to the root filesystem. If this field is specified, viewName field must also be specified.
func (r ApiListSmbFileOpensRequest) FilePath(filePath string) ApiListSmbFileOpensRequest {
	r.filePath = &filePath
	return r
}

// Specifies the name of the Cohesity View in which to search. If a view name is not specified, all the views in the Cluster are searched. This field is mandatory if filePath field is specified.
func (r ApiListSmbFileOpensRequest) ViewName(viewName string) ApiListSmbFileOpensRequest {
	r.viewName = &viewName
	return r
}

// Specifies the maximum number of active file opens to return in the response. This field cannot be set above 1000. If this is not set, maximum of 1000 entries are returned.
func (r ApiListSmbFileOpensRequest) MaxCount(maxCount int32) ApiListSmbFileOpensRequest {
	r.maxCount = &maxCount
	return r
}

// Specifies the Pagination Cookie returned in the previous response.
func (r ApiListSmbFileOpensRequest) Cookie(cookie string) ApiListSmbFileOpensRequest {
	r.cookie = &cookie
	return r
}

func (r ApiListSmbFileOpensRequest) Execute() (*SmbFileOpens, *http.Response, error) {
	return r.ApiService.ListSmbFileOpensExecute(r)
}

/*
ListSmbFileOpens Get SMB File opens.

Get SMB active file opens on a Cohesity View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSmbFileOpensRequest
*/
func (a *ViewAPIService) ListSmbFileOpens(ctx context.Context) ApiListSmbFileOpensRequest {
	return ApiListSmbFileOpensRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SmbFileOpens
func (a *ViewAPIService) ListSmbFileOpensExecute(r ApiListSmbFileOpensRequest) (*SmbFileOpens, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SmbFileOpens
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.ListSmbFileOpens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/smb-file-opens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filePath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filePath", r.filePath, "")
	}
	if r.viewName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewName", r.viewName, "")
	}
	if r.maxCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxCount", r.maxCount, "")
	}
	if r.cookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cookie", r.cookie, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockFileRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	body *LockFileParams
}

// Specifies the request params to lock a file
func (r ApiLockFileRequest) Body(body LockFileParams) ApiLockFileRequest {
	r.body = &body
	return r
}

func (r ApiLockFileRequest) Execute() (*FileLockStatus, *http.Response, error) {
	return r.ApiService.LockFileExecute(r)
}

/*
LockFile Create a file-lock

Locks a file in a view and returns the lock status of the file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the id of a view.
 @return ApiLockFileRequest
*/
func (a *ViewAPIService) LockFile(ctx context.Context, id int64) ApiLockFileRequest {
	return ApiLockFileRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return FileLockStatus
func (a *ViewAPIService) LockFileExecute(r ApiLockFileRequest) (*FileLockStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileLockStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.LockFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}/file-lock"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMigrateS3ViewsRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	body *MigrateS3Views
}

// Specifies the request body to Migrate S3 Views.
func (r ApiMigrateS3ViewsRequest) Body(body MigrateS3Views) ApiMigrateS3ViewsRequest {
	r.body = &body
	return r
}

func (r ApiMigrateS3ViewsRequest) Execute() (*MultipleViewsUpdateSuccessFailureIds, *http.Response, error) {
	return r.ApiService.MigrateS3ViewsExecute(r)
}

/*
MigrateS3Views Migrate S3 Views.

Migrate S3 Views from S3 1.0 to 2.0.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMigrateS3ViewsRequest
*/
func (a *ViewAPIService) MigrateS3Views(ctx context.Context) ApiMigrateS3ViewsRequest {
	return ApiMigrateS3ViewsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultipleViewsUpdateSuccessFailureIds
func (a *ViewAPIService) MigrateS3ViewsExecute(r ApiMigrateS3ViewsRequest) (*MultipleViewsUpdateSuccessFailureIds, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultipleViewsUpdateSuccessFailureIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.MigrateS3Views")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/migrate-s3-views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOverwriteViewRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	body *OverwriteViewParams
}

// Specifies the request to overwrite the View.
func (r ApiOverwriteViewRequest) Body(body OverwriteViewParams) ApiOverwriteViewRequest {
	r.body = &body
	return r
}

func (r ApiOverwriteViewRequest) Execute() (*http.Response, error) {
	return r.ApiService.OverwriteViewExecute(r)
}

/*
OverwriteView Overwrite View.

Overwrite View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the View id to be overwritten.
 @return ApiOverwriteViewRequest
*/
func (a *ViewAPIService) OverwriteView(ctx context.Context, id int64) ApiOverwriteViewRequest {
	return ApiOverwriteViewRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ViewAPIService) OverwriteViewExecute(r ApiOverwriteViewRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.OverwriteView")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}/overwrite"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReadViewTemplateByIdRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
}

func (r ApiReadViewTemplateByIdRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.ReadViewTemplateByIdExecute(r)
}

/*
ReadViewTemplateById Read a View Template by Id

Reads a view template based on given template id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the view template.
 @return ApiReadViewTemplateByIdRequest
*/
func (a *ViewAPIService) ReadViewTemplateById(ctx context.Context, id int64) ApiReadViewTemplateByIdRequest {
	return ApiReadViewTemplateByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Template
func (a *ViewAPIService) ReadViewTemplateByIdExecute(r ApiReadViewTemplateByIdRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.ReadViewTemplateById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/view-template/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadViewTemplatesRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
}

func (r ApiReadViewTemplatesRequest) Execute() (*GetViewTemplatesResult, *http.Response, error) {
	return r.ApiService.ReadViewTemplatesExecute(r)
}

/*
ReadViewTemplates List View Templates

All view templates on the Cohesity Cluster are returned.
Specifying parameters filters the results that are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadViewTemplatesRequest
*/
func (a *ViewAPIService) ReadViewTemplates(ctx context.Context) ApiReadViewTemplatesRequest {
	return ApiReadViewTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetViewTemplatesResult
func (a *ViewAPIService) ReadViewTemplatesExecute(r ApiReadViewTemplatesRequest) (*GetViewTemplatesResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetViewTemplatesResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.ReadViewTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/view-template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateShareRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	name string
	body *UpdateShareParam
}

// Specifies the request to update a Share.
func (r ApiUpdateShareRequest) Body(body UpdateShareParam) ApiUpdateShareRequest {
	r.body = &body
	return r
}

func (r ApiUpdateShareRequest) Execute() (*Share, *http.Response, error) {
	return r.ApiService.UpdateShareExecute(r)
}

/*
UpdateShare Update a Share.

Update a Share.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Specifies the Share name to update.
 @return ApiUpdateShareRequest
*/
func (a *ViewAPIService) UpdateShare(ctx context.Context, name string) ApiUpdateShareRequest {
	return ApiUpdateShareRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Share
func (a *ViewAPIService) UpdateShareExecute(r ApiUpdateShareRequest) (*Share, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Share
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.UpdateShare")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/shares/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateViewRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	body *View
}

// Request to update a view.
func (r ApiUpdateViewRequest) Body(body View) ApiUpdateViewRequest {
	r.body = &body
	return r
}

func (r ApiUpdateViewRequest) Execute() (*View, *http.Response, error) {
	return r.ApiService.UpdateViewExecute(r)
}

/*
UpdateView Update a View

Updates a View based on given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the View to update.
 @return ApiUpdateViewRequest
*/
func (a *ViewAPIService) UpdateView(ctx context.Context, id int64) ApiUpdateViewRequest {
	return ApiUpdateViewRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return View
func (a *ViewAPIService) UpdateViewExecute(r ApiUpdateViewRequest) (*View, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *View
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.UpdateView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateViewDirectoryQuotaRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	body *ViewDirectoryQuota
}

// Specifies the request to update directory quota.
func (r ApiUpdateViewDirectoryQuotaRequest) Body(body ViewDirectoryQuota) ApiUpdateViewDirectoryQuotaRequest {
	r.body = &body
	return r
}

func (r ApiUpdateViewDirectoryQuotaRequest) Execute() (*ViewDirectoryQuota, *http.Response, error) {
	return r.ApiService.UpdateViewDirectoryQuotaExecute(r)
}

/*
UpdateViewDirectoryQuota Update directory quota for the View.

Update directory quota for the View.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies the View id.
 @return ApiUpdateViewDirectoryQuotaRequest
*/
func (a *ViewAPIService) UpdateViewDirectoryQuota(ctx context.Context, id int64) ApiUpdateViewDirectoryQuotaRequest {
	return ApiUpdateViewDirectoryQuotaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ViewDirectoryQuota
func (a *ViewAPIService) UpdateViewDirectoryQuotaExecute(r ApiUpdateViewDirectoryQuotaRequest) (*ViewDirectoryQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewDirectoryQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.UpdateViewDirectoryQuota")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{id}/directory-quotas"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateViewTemplateRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	id int64
	body *Template
}

// Request to update a view template.
func (r ApiUpdateViewTemplateRequest) Body(body Template) ApiUpdateViewTemplateRequest {
	r.body = &body
	return r
}

func (r ApiUpdateViewTemplateRequest) Execute() (*Template, *http.Response, error) {
	return r.ApiService.UpdateViewTemplateExecute(r)
}

/*
UpdateViewTemplate Update a View Template

Updates a View Template.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Specifies a unique id of the view template.
 @return ApiUpdateViewTemplateRequest
*/
func (a *ViewAPIService) UpdateViewTemplate(ctx context.Context, id int64) ApiUpdateViewTemplateRequest {
	return ApiUpdateViewTemplateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Template
func (a *ViewAPIService) UpdateViewTemplateExecute(r ApiUpdateViewTemplateRequest) (*Template, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Template
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.UpdateViewTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/view-template/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateViewUserQuotaOverrideRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	viewId int64
	userId string
	body *QuotaPolicy
}

// Specifies the user quota policy of the user.
func (r ApiUpdateViewUserQuotaOverrideRequest) Body(body QuotaPolicy) ApiUpdateViewUserQuotaOverrideRequest {
	r.body = &body
	return r
}

func (r ApiUpdateViewUserQuotaOverrideRequest) Execute() (*UserQuota, *http.Response, error) {
	return r.ApiService.UpdateViewUserQuotaOverrideExecute(r)
}

/*
UpdateViewUserQuotaOverride Update user quota override.

Update user quota. To use this API, User quota settings should be enabled on the View and there should be a user quota override added for this user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param viewId Specifies the View id.
 @param userId Specifies the unixUid or sid or an user.
 @return ApiUpdateViewUserQuotaOverrideRequest
*/
func (a *ViewAPIService) UpdateViewUserQuotaOverride(ctx context.Context, viewId int64, userId string) ApiUpdateViewUserQuotaOverrideRequest {
	return ApiUpdateViewUserQuotaOverrideRequest{
		ApiService: a,
		ctx: ctx,
		viewId: viewId,
		userId: userId,
	}
}

// Execute executes the request
//  @return UserQuota
func (a *ViewAPIService) UpdateViewUserQuotaOverrideExecute(r ApiUpdateViewUserQuotaOverrideRequest) (*UserQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.UpdateViewUserQuotaOverride")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{viewId}/user-quotas/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateViewUserQuotaSettingsRequest struct {
	ctx context.Context
	ApiService *ViewAPIService
	viewId int64
	body *ViewUserQuotaSettings
}

// Specifies the parameters to enable/disable or update the default quota config on the view.
func (r ApiUpdateViewUserQuotaSettingsRequest) Body(body ViewUserQuotaSettings) ApiUpdateViewUserQuotaSettingsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateViewUserQuotaSettingsRequest) Execute() (*ViewUserQuotas, *http.Response, error) {
	return r.ApiService.UpdateViewUserQuotaSettingsExecute(r)
}

/*
UpdateViewUserQuotaSettings Update View user quota settings.

Specifies parameters to update View user quota settings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param viewId Specifies the View id.
 @return ApiUpdateViewUserQuotaSettingsRequest
*/
func (a *ViewAPIService) UpdateViewUserQuotaSettings(ctx context.Context, viewId int64) ApiUpdateViewUserQuotaSettingsRequest {
	return ApiUpdateViewUserQuotaSettingsRequest{
		ApiService: a,
		ctx: ctx,
		viewId: viewId,
	}
}

// Execute executes the request
//  @return ViewUserQuotas
func (a *ViewAPIService) UpdateViewUserQuotaSettingsExecute(r ApiUpdateViewUserQuotaSettingsRequest) (*ViewUserQuotas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ViewUserQuotas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ViewAPIService.UpdateViewUserQuotaSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/file-services/views/{viewId}/user-quotas"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
