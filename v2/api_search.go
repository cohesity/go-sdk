/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// SearchAPIService SearchAPI service
type SearchAPIService service

type ApiSearchIndexedObjectsRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	body *SearchIndexedObjectsRequest
}

// Specifies the parameters to search for indexed objects.
func (r ApiSearchIndexedObjectsRequest) Body(body SearchIndexedObjectsRequest) ApiSearchIndexedObjectsRequest {
	r.body = &body
	return r
}

func (r ApiSearchIndexedObjectsRequest) Execute() (*SearchIndexedObjectsResponseBody, *http.Response, error) {
	return r.ApiService.SearchIndexedObjectsExecute(r)
}

/*
SearchIndexedObjects List indexed objects.

List all the indexed objects like files and folders, emails, mailboxes etc., that match the specified search and filter criteria from protected objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchIndexedObjectsRequest
*/
func (a *SearchAPIService) SearchIndexedObjects(ctx context.Context) ApiSearchIndexedObjectsRequest {
	return ApiSearchIndexedObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchIndexedObjectsResponseBody
func (a *SearchAPIService) SearchIndexedObjectsExecute(r ApiSearchIndexedObjectsRequest) (*SearchIndexedObjectsResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchIndexedObjectsResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.SearchIndexedObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/search/indexed-objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchObjectsRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	requestInitiatorType *string
	searchString *string
	environments *[]string
	protectionTypes *[]string
	tenantIds *[]string
	includeTenants *bool
	protectionGroupIds *[]string
	objectIds *[]int64
	osTypes *[]string
	o365ObjectTypes *[]string
	azureObjectTypes *[]string
	awsObjectTypes *[]string
	azureUuids *[]string
	sourceIds *[]int64
	sourceUuids *[]string
	isProtected *bool
	isDeleted *bool
	lastRunStatusList *[]string
	regionIds *[]string
	clusterIdentifiers *[]string
	storageDomainIds *[]string
	includeDeletedObjects *bool
	paginationCookie *string
	count *int32
	mustHaveTagIds *[]string
	mightHaveTagIds *[]string
	mustHaveSnapshotTagIds *[]string
	mightHaveSnapshotTagIds *[]string
	tagSearchName *string
	tagNames *[]string
	anomalyTags *[]string
	dataClassificationTags *[]string
	threatTags *[]string
	tagNamesExcluded *[]string
	tagTypes *[]string
	tagCategories *[]string
	tagSubCategories *[]string
	includeHeliosTagInfoForObjects *bool
	externalFilters *[]string
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiSearchObjectsRequest) RequestInitiatorType(requestInitiatorType string) ApiSearchObjectsRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Specifies the search string to filter the objects. This search string will be applicable for objectnames. User can specify a wildcard character &#39;*&#39; as a suffix to a string where all object names are matched with the prefix string. For example, if vm1 and vm2 are the names of objects, user can specify vm* to list the objects. If not specified, then all the objects will be returned which will match other filtering criteria.
func (r ApiSearchObjectsRequest) SearchString(searchString string) ApiSearchObjectsRequest {
	r.searchString = &searchString
	return r
}

// Specifies the environment type to filter objects.
func (r ApiSearchObjectsRequest) Environments(environments []string) ApiSearchObjectsRequest {
	r.environments = &environments
	return r
}

// Specifies the protection type to filter objects.
func (r ApiSearchObjectsRequest) ProtectionTypes(protectionTypes []string) ApiSearchObjectsRequest {
	r.protectionTypes = &protectionTypes
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiSearchObjectsRequest) TenantIds(tenantIds []string) ApiSearchObjectsRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
func (r ApiSearchObjectsRequest) IncludeTenants(includeTenants bool) ApiSearchObjectsRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies a list of Protection Group ids to filter the objects. If specified, the objects protected by specified Protection Group ids will be returned.
func (r ApiSearchObjectsRequest) ProtectionGroupIds(protectionGroupIds []string) ApiSearchObjectsRequest {
	r.protectionGroupIds = &protectionGroupIds
	return r
}

// Specifies a list of Object ids to filter.
func (r ApiSearchObjectsRequest) ObjectIds(objectIds []int64) ApiSearchObjectsRequest {
	r.objectIds = &objectIds
	return r
}

// Specifies the operating system types to filter objects on.
func (r ApiSearchObjectsRequest) OsTypes(osTypes []string) ApiSearchObjectsRequest {
	r.osTypes = &osTypes
	return r
}

// Specifies the object types to filter objects on. Only applicable if the environment is o365.
func (r ApiSearchObjectsRequest) O365ObjectTypes(o365ObjectTypes []string) ApiSearchObjectsRequest {
	r.o365ObjectTypes = &o365ObjectTypes
	return r
}

// Specifies the object types to filter objects on. Only applicable if the environment is Azure.
func (r ApiSearchObjectsRequest) AzureObjectTypes(azureObjectTypes []string) ApiSearchObjectsRequest {
	r.azureObjectTypes = &azureObjectTypes
	return r
}

// Specifies the object types to filter objects on. Only applicable if the environment is AWS.
func (r ApiSearchObjectsRequest) AwsObjectTypes(awsObjectTypes []string) ApiSearchObjectsRequest {
	r.awsObjectTypes = &awsObjectTypes
	return r
}

// Specifies the Azure UUID for the Microsoft365 objects. If specified, the objects with the matching Azure UUIDs will be returned.
func (r ApiSearchObjectsRequest) AzureUuids(azureUuids []string) ApiSearchObjectsRequest {
	r.azureUuids = &azureUuids
	return r
}

// Specifies a list of Protection Source object ids to filter the objects. If specified, the object which are present in those Sources will be returned.
func (r ApiSearchObjectsRequest) SourceIds(sourceIds []int64) ApiSearchObjectsRequest {
	r.sourceIds = &sourceIds
	return r
}

// Specifies a list of Protection Source object uuids to filter the objects. If specified, the object which are present in those Sources will be returned.
func (r ApiSearchObjectsRequest) SourceUuids(sourceUuids []string) ApiSearchObjectsRequest {
	r.sourceUuids = &sourceUuids
	return r
}

// Specifies the protection status of objects. If set to true, only protected objects will be returned. If set to false, only unprotected objects will be returned. If not specified, all objects will be returned.
func (r ApiSearchObjectsRequest) IsProtected(isProtected bool) ApiSearchObjectsRequest {
	r.isProtected = &isProtected
	return r
}

// If set to true, then objects which are deleted on atleast one cluster will be returned. If not set or set to false then objects which are registered on atleast one cluster are returned.
func (r ApiSearchObjectsRequest) IsDeleted(isDeleted bool) ApiSearchObjectsRequest {
	r.isDeleted = &isDeleted
	return r
}

// Specifies a list of status of the object&#39;s last protection run. Only objects with last run status of these will be returned.
func (r ApiSearchObjectsRequest) LastRunStatusList(lastRunStatusList []string) ApiSearchObjectsRequest {
	r.lastRunStatusList = &lastRunStatusList
	return r
}

// Specifies a list of region ids. Only records from clusters having these region ids will be returned.
func (r ApiSearchObjectsRequest) RegionIds(regionIds []string) ApiSearchObjectsRequest {
	r.regionIds = &regionIds
	return r
}

// Specifies the list of cluster identifiers. Format is clusterId:clusterIncarnationId. Only records from clusters having these identifiers will be returned.
func (r ApiSearchObjectsRequest) ClusterIdentifiers(clusterIdentifiers []string) ApiSearchObjectsRequest {
	r.clusterIdentifiers = &clusterIdentifiers
	return r
}

// Specifies the list of storage domain ids. Format is clusterId:clusterIncarnationId:storageDomainId. Only objects having protection in these storage domains will be returned.
func (r ApiSearchObjectsRequest) StorageDomainIds(storageDomainIds []string) ApiSearchObjectsRequest {
	r.storageDomainIds = &storageDomainIds
	return r
}

// Specifies whether to include deleted objects in response. These objects can&#39;t be protected but can be recovered. This field is deprecated.
func (r ApiSearchObjectsRequest) IncludeDeletedObjects(includeDeletedObjects bool) ApiSearchObjectsRequest {
	r.includeDeletedObjects = &includeDeletedObjects
	return r
}

// Specifies the pagination cookie with which subsequent parts of the response can be fetched.
func (r ApiSearchObjectsRequest) PaginationCookie(paginationCookie string) ApiSearchObjectsRequest {
	r.paginationCookie = &paginationCookie
	return r
}

// Specifies the number of objects to be fetched for the specified pagination cookie.
func (r ApiSearchObjectsRequest) Count(count int32) ApiSearchObjectsRequest {
	r.count = &count
	return r
}

// Specifies tags which must be all present in the document.
func (r ApiSearchObjectsRequest) MustHaveTagIds(mustHaveTagIds []string) ApiSearchObjectsRequest {
	r.mustHaveTagIds = &mustHaveTagIds
	return r
}

// Specifies list of tags, one or more of which might be present in the document. These are OR&#39;ed together and the resulting criteria AND&#39;ed with the rest of the query.
func (r ApiSearchObjectsRequest) MightHaveTagIds(mightHaveTagIds []string) ApiSearchObjectsRequest {
	r.mightHaveTagIds = &mightHaveTagIds
	return r
}

// Specifies snapshot tags which must be all present in the document.
func (r ApiSearchObjectsRequest) MustHaveSnapshotTagIds(mustHaveSnapshotTagIds []string) ApiSearchObjectsRequest {
	r.mustHaveSnapshotTagIds = &mustHaveSnapshotTagIds
	return r
}

// Specifies list of snapshot tags, one or more of which might be present in the document. These are OR&#39;ed together and the resulting criteria AND&#39;ed with the rest of the query.
func (r ApiSearchObjectsRequest) MightHaveSnapshotTagIds(mightHaveSnapshotTagIds []string) ApiSearchObjectsRequest {
	r.mightHaveSnapshotTagIds = &mightHaveSnapshotTagIds
	return r
}

// Specifies the tag name to filter the tagged objects and snapshots. User can specify a wildcard character &#39;*&#39; as a suffix to a string where all object&#39;s tag names are matched with the prefix string.
func (r ApiSearchObjectsRequest) TagSearchName(tagSearchName string) ApiSearchObjectsRequest {
	r.tagSearchName = &tagSearchName
	return r
}

// Specifies the tag names to filter the tagged objects and snapshots only for non system tags
func (r ApiSearchObjectsRequest) TagNames(tagNames []string) ApiSearchObjectsRequest {
	r.tagNames = &tagNames
	return r
}

// Specifies the Anomaly&#39;s tag names to filter the tagged snapshots
func (r ApiSearchObjectsRequest) AnomalyTags(anomalyTags []string) ApiSearchObjectsRequest {
	r.anomalyTags = &anomalyTags
	return r
}

// Specifies the Data classification&#39;s tag names to filter the tagged snapshots
func (r ApiSearchObjectsRequest) DataClassificationTags(dataClassificationTags []string) ApiSearchObjectsRequest {
	r.dataClassificationTags = &dataClassificationTags
	return r
}

// Specifies the threat tag&#39;s names to filter the tagged snapshots
func (r ApiSearchObjectsRequest) ThreatTags(threatTags []string) ApiSearchObjectsRequest {
	r.threatTags = &threatTags
	return r
}

// Specifies the tag names to not include in the tagged snapshots response
func (r ApiSearchObjectsRequest) TagNamesExcluded(tagNamesExcluded []string) ApiSearchObjectsRequest {
	r.tagNamesExcluded = &tagNamesExcluded
	return r
}

// Specifies the tag type to filter the objects and snapshots.
func (r ApiSearchObjectsRequest) TagTypes(tagTypes []string) ApiSearchObjectsRequest {
	r.tagTypes = &tagTypes
	return r
}

// Specifies the tag category to filter the objects and snapshots.
func (r ApiSearchObjectsRequest) TagCategories(tagCategories []string) ApiSearchObjectsRequest {
	r.tagCategories = &tagCategories
	return r
}

// Specifies the tag subcategory to filter the objects and snapshots
func (r ApiSearchObjectsRequest) TagSubCategories(tagSubCategories []string) ApiSearchObjectsRequest {
	r.tagSubCategories = &tagSubCategories
	return r
}

// Specifies whether to include helios tags information for objects in response. Default value is false
func (r ApiSearchObjectsRequest) IncludeHeliosTagInfoForObjects(includeHeliosTagInfoForObjects bool) ApiSearchObjectsRequest {
	r.includeHeliosTagInfoForObjects = &includeHeliosTagInfoForObjects
	return r
}

// Specifies the key-value pairs to filtering the results for the search. Each filter is of the form &#39;key:value&#39;. The filter &#39;externalFilters:k1:v1&amp;externalFilters:k2:v2&amp;externalFilters:k2:v3&#39; returns the documents where each document will match the query (k1&#x3D;v1) AND (k2&#x3D;v2 OR k2 &#x3D; v3). Allowed keys: - vmBiosUuid - graphUuid - arn - instanceId - bucketName - azureId
func (r ApiSearchObjectsRequest) ExternalFilters(externalFilters []string) ApiSearchObjectsRequest {
	r.externalFilters = &externalFilters
	return r
}

func (r ApiSearchObjectsRequest) Execute() (*ObjectsSearchResponseBody, *http.Response, error) {
	return r.ApiService.SearchObjectsExecute(r)
}

/*
SearchObjects List Objects.

List objects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchObjectsRequest
*/
func (a *SearchAPIService) SearchObjects(ctx context.Context) ApiSearchObjectsRequest {
	return ApiSearchObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectsSearchResponseBody
func (a *SearchAPIService) SearchObjectsExecute(r ApiSearchObjectsRequest) (*ObjectsSearchResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectsSearchResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.SearchObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/search/objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchString", r.searchString, "")
	}
	if r.environments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environments", r.environments, "csv")
	}
	if r.protectionTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectionTypes", r.protectionTypes, "csv")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.protectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectionGroupIds", r.protectionGroupIds, "csv")
	}
	if r.objectIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectIds", r.objectIds, "csv")
	}
	if r.osTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "osTypes", r.osTypes, "csv")
	}
	if r.o365ObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "o365ObjectTypes", r.o365ObjectTypes, "csv")
	}
	if r.azureObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "azureObjectTypes", r.azureObjectTypes, "csv")
	}
	if r.awsObjectTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "awsObjectTypes", r.awsObjectTypes, "csv")
	}
	if r.azureUuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "azureUuids", r.azureUuids, "csv")
	}
	if r.sourceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", r.sourceIds, "csv")
	}
	if r.sourceUuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceUuids", r.sourceUuids, "csv")
	}
	if r.isProtected != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isProtected", r.isProtected, "")
	}
	if r.isDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDeleted", r.isDeleted, "")
	}
	if r.lastRunStatusList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRunStatusList", r.lastRunStatusList, "csv")
	}
	if r.regionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionIds", r.regionIds, "csv")
	}
	if r.clusterIdentifiers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusterIdentifiers", r.clusterIdentifiers, "csv")
	}
	if r.storageDomainIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainIds", r.storageDomainIds, "csv")
	}
	if r.includeDeletedObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeletedObjects", r.includeDeletedObjects, "")
	}
	if r.paginationCookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginationCookie", r.paginationCookie, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.mustHaveTagIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mustHaveTagIds", r.mustHaveTagIds, "csv")
	}
	if r.mightHaveTagIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mightHaveTagIds", r.mightHaveTagIds, "csv")
	}
	if r.mustHaveSnapshotTagIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mustHaveSnapshotTagIds", r.mustHaveSnapshotTagIds, "csv")
	}
	if r.mightHaveSnapshotTagIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mightHaveSnapshotTagIds", r.mightHaveSnapshotTagIds, "csv")
	}
	if r.tagSearchName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tagSearchName", r.tagSearchName, "")
	}
	if r.tagNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tagNames", r.tagNames, "csv")
	}
	if r.anomalyTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "anomalyTags", r.anomalyTags, "csv")
	}
	if r.dataClassificationTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataClassificationTags", r.dataClassificationTags, "csv")
	}
	if r.threatTags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threatTags", r.threatTags, "csv")
	}
	if r.tagNamesExcluded != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tagNamesExcluded", r.tagNamesExcluded, "csv")
	}
	if r.tagTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tagTypes", r.tagTypes, "csv")
	}
	if r.tagCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tagCategories", r.tagCategories, "csv")
	}
	if r.tagSubCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tagSubCategories", r.tagSubCategories, "csv")
	}
	if r.includeHeliosTagInfoForObjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHeliosTagInfoForObjects", r.includeHeliosTagInfoForObjects, "")
	}
	if r.externalFilters != nil {
		t := *r.externalFilters
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "externalFilters", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "externalFilters", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchProtectedObjectsRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	requestInitiatorType *string
	searchString *string
	environments *[]string
	snapshotActions *[]string
	objectActionKey *string
	tenantIds *[]string
	includeTenants *bool
	protectionGroupIds *[]string
	objectIds *[]int64
	storageDomainIds *[]int64
	subResultSize *int32
	filterSnapshotFromUsecs *int64
	filterSnapshotToUsecs *int64
	osTypes *[]string
	sourceIds *[]int64
	runInstanceIds *[]int64
	cdpProtectedOnly *bool
	regionIds *[]string
	useCachedData *bool
}

// Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
func (r ApiSearchProtectedObjectsRequest) RequestInitiatorType(requestInitiatorType string) ApiSearchProtectedObjectsRequest {
	r.requestInitiatorType = &requestInitiatorType
	return r
}

// Specifies the search string to filter the objects. This search string will be applicable for objectnames and Protection Group names. User can specify a wildcard character &#39;*&#39; as a suffix to a string where all object and their Protection Group names are matched with the prefix string. For example, if vm1 and vm2 are the names of objects, user can specify vm* to list the objects. If not specified, then all the objects with Protection Groups will be returned which will match other filtering criteria.
func (r ApiSearchProtectedObjectsRequest) SearchString(searchString string) ApiSearchProtectedObjectsRequest {
	r.searchString = &searchString
	return r
}

// Specifies the environment type to filter objects.
func (r ApiSearchProtectedObjectsRequest) Environments(environments []string) ApiSearchProtectedObjectsRequest {
	r.environments = &environments
	return r
}

// Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.
func (r ApiSearchProtectedObjectsRequest) SnapshotActions(snapshotActions []string) ApiSearchProtectedObjectsRequest {
	r.snapshotActions = &snapshotActions
	return r
}

// Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, latest snapshot info matching the objectActionKey is for corresponding object.
func (r ApiSearchProtectedObjectsRequest) ObjectActionKey(objectActionKey string) ApiSearchProtectedObjectsRequest {
	r.objectActionKey = &objectActionKey
	return r
}

// TenantIds contains ids of the tenants for which objects are to be returned.
func (r ApiSearchProtectedObjectsRequest) TenantIds(tenantIds []string) ApiSearchProtectedObjectsRequest {
	r.tenantIds = &tenantIds
	return r
}

// If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
func (r ApiSearchProtectedObjectsRequest) IncludeTenants(includeTenants bool) ApiSearchProtectedObjectsRequest {
	r.includeTenants = &includeTenants
	return r
}

// Specifies a list of Protection Group ids to filter the objects. If specified, the objects protected by specified Protection Group ids will be returned.
func (r ApiSearchProtectedObjectsRequest) ProtectionGroupIds(protectionGroupIds []string) ApiSearchProtectedObjectsRequest {
	r.protectionGroupIds = &protectionGroupIds
	return r
}

// Specifies a list of Object ids to filter.
func (r ApiSearchProtectedObjectsRequest) ObjectIds(objectIds []int64) ApiSearchProtectedObjectsRequest {
	r.objectIds = &objectIds
	return r
}

// Specifies the Storage Domain ids to filter objects for which Protection Groups are writing data to Cohesity Views on the specified Storage Domains.
func (r ApiSearchProtectedObjectsRequest) StorageDomainIds(storageDomainIds []int64) ApiSearchProtectedObjectsRequest {
	r.storageDomainIds = &storageDomainIds
	return r
}

// Specifies the size of objects to be fetched for a single subresult.
func (r ApiSearchProtectedObjectsRequest) SubResultSize(subResultSize int32) ApiSearchProtectedObjectsRequest {
	r.subResultSize = &subResultSize
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter the objects if the Object has a successful snapshot after this value.
func (r ApiSearchProtectedObjectsRequest) FilterSnapshotFromUsecs(filterSnapshotFromUsecs int64) ApiSearchProtectedObjectsRequest {
	r.filterSnapshotFromUsecs = &filterSnapshotFromUsecs
	return r
}

// Specifies the timestamp in Unix time epoch in microseconds to filter the objects if the Object has a successful snapshot before this value.
func (r ApiSearchProtectedObjectsRequest) FilterSnapshotToUsecs(filterSnapshotToUsecs int64) ApiSearchProtectedObjectsRequest {
	r.filterSnapshotToUsecs = &filterSnapshotToUsecs
	return r
}

// Specifies the operating system types to filter objects on.
func (r ApiSearchProtectedObjectsRequest) OsTypes(osTypes []string) ApiSearchProtectedObjectsRequest {
	r.osTypes = &osTypes
	return r
}

// Specifies a list of Protection Source object ids to filter the objects. If specified, the object which are present in those Sources will be returned.
func (r ApiSearchProtectedObjectsRequest) SourceIds(sourceIds []int64) ApiSearchProtectedObjectsRequest {
	r.sourceIds = &sourceIds
	return r
}

// Specifies a list of run instance ids. If specified only objects belonging to the provided run id will be retunrned.
func (r ApiSearchProtectedObjectsRequest) RunInstanceIds(runInstanceIds []int64) ApiSearchProtectedObjectsRequest {
	r.runInstanceIds = &runInstanceIds
	return r
}

// Specifies whether to only return the CDP protected objects.
func (r ApiSearchProtectedObjectsRequest) CdpProtectedOnly(cdpProtectedOnly bool) ApiSearchProtectedObjectsRequest {
	r.cdpProtectedOnly = &cdpProtectedOnly
	return r
}

// Specifies a list of region ids. Only records from clusters having these region ids will be returned.
func (r ApiSearchProtectedObjectsRequest) RegionIds(regionIds []string) ApiSearchProtectedObjectsRequest {
	r.regionIds = &regionIds
	return r
}

// Specifies whether we can serve the GET request to the read replica cache cache. There is a lag of 15 seconds between the read replica and primary data source.
func (r ApiSearchProtectedObjectsRequest) UseCachedData(useCachedData bool) ApiSearchProtectedObjectsRequest {
	r.useCachedData = &useCachedData
	return r
}

func (r ApiSearchProtectedObjectsRequest) Execute() (*ProtectedObjectsSearchResponseBody, *http.Response, error) {
	return r.ApiService.SearchProtectedObjectsExecute(r)
}

/*
SearchProtectedObjects List Protected Objects.

List protected objects and corresponding detail information from registered sources filtered by specified query parameters. If no search pattern or filter parameters are specified, all protected objects currently found are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchProtectedObjectsRequest
*/
func (a *SearchAPIService) SearchProtectedObjects(ctx context.Context) ApiSearchProtectedObjectsRequest {
	return ApiSearchProtectedObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProtectedObjectsSearchResponseBody
func (a *SearchAPIService) SearchProtectedObjectsExecute(r ApiSearchProtectedObjectsRequest) (*ProtectedObjectsSearchResponseBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProtectedObjectsSearchResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.SearchProtectedObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-protect/search/protected-objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchString", r.searchString, "")
	}
	if r.environments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "environments", r.environments, "csv")
	}
	if r.snapshotActions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotActions", r.snapshotActions, "csv")
	}
	if r.objectActionKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectActionKey", r.objectActionKey, "")
	}
	if r.tenantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tenantIds", r.tenantIds, "csv")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.protectionGroupIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protectionGroupIds", r.protectionGroupIds, "csv")
	}
	if r.objectIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objectIds", r.objectIds, "csv")
	}
	if r.storageDomainIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "storageDomainIds", r.storageDomainIds, "csv")
	}
	if r.subResultSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subResultSize", r.subResultSize, "")
	}
	if r.filterSnapshotFromUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterSnapshotFromUsecs", r.filterSnapshotFromUsecs, "")
	}
	if r.filterSnapshotToUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filterSnapshotToUsecs", r.filterSnapshotToUsecs, "")
	}
	if r.osTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "osTypes", r.osTypes, "csv")
	}
	if r.sourceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sourceIds", r.sourceIds, "csv")
	}
	if r.runInstanceIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runInstanceIds", r.runInstanceIds, "csv")
	}
	if r.cdpProtectedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cdpProtectedOnly", r.cdpProtectedOnly, "")
	}
	if r.regionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "regionIds", r.regionIds, "csv")
	}
	if r.useCachedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "useCachedData", r.useCachedData, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.requestInitiatorType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "requestInitiatorType", r.requestInitiatorType, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
