/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"encoding/json"
)

// checks if the FileLockStatus type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &FileLockStatus{}

// FileLockStatus Specified the information about the lock status of a file.
type FileLockStatus struct {
	// Specifies a expiry timestamp in milliseconds until the file is locked.
	ExpiryTimestampMsecs NullableInt64 `json:"expiryTimestampMsecs,omitempty"`
	// Specifies a override timestamp in milliseconds when an expired file is kept on hold.
	HoldTimestampMsecs NullableInt64 `json:"holdTimestampMsecs,omitempty"`
	// Specifies the timestamp at which the file was locked.
	LockTimestampMsecs NullableInt64 `json:"lockTimestampMsecs,omitempty"`
	// Specifies the mode of the file lock. A lock mode of a file in a view can be in one of the following: Compliance: Default mode of datalock, in this mode,   Data Security Admin cannot modify/delete this view when datalock   is in effect. Data Security Admin can delete this view   when datalock is expired. Enterprise: In this mode, Data Security Admin can change view name or   delete view when datalock is in effect. Datalock in this mode can   be upgraded to 'Compliance' mode.
	Mode NullableString `json:"mode,omitempty"`
	// Specifies the lock state of the file. A lock state of a file in a view can be in one of the following: Unconfigured: File does not belong to data lock enabled view. Unlocked: A file created in a file lock enabled view. It will remain in   this state until auto-lock timer expires or user manually locks the file. Locked: A locked file has a set retention period that prevents users from   modifying the file data or extending, deleting, or renaming the file.   A locked file remain in this state untill retention period expires. Expired: When retention period ends, the file transition from the locked   state to the expired state. User can not modify or rename a file in expired   state, but can delete a file. Hold: Expired file is kept in hold for administrator specified retention   periods and deny any mutable or remove operation on locked files until a   specific date.
	State NullableString `json:"state,omitempty"`
}

// NewFileLockStatus instantiates a new FileLockStatus object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewFileLockStatus() *FileLockStatus {
	this := FileLockStatus{}
	return &this
}

// NewFileLockStatusWithDefaults instantiates a new FileLockStatus object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewFileLockStatusWithDefaults() *FileLockStatus {
	this := FileLockStatus{}
	return &this
}

// GetExpiryTimestampMsecs returns the ExpiryTimestampMsecs field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *FileLockStatus) GetExpiryTimestampMsecs() int64 {
	if o == nil || IsNil(o.ExpiryTimestampMsecs.Get()) {
		var ret int64
		return ret
	}
	return *o.ExpiryTimestampMsecs.Get()
}

// GetExpiryTimestampMsecsOk returns a tuple with the ExpiryTimestampMsecs field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *FileLockStatus) GetExpiryTimestampMsecsOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return o.ExpiryTimestampMsecs.Get(), o.ExpiryTimestampMsecs.IsSet()
}

// HasExpiryTimestampMsecs returns a boolean if a field has been set.
func (o *FileLockStatus) HasExpiryTimestampMsecs() bool {
	if o != nil && o.ExpiryTimestampMsecs.IsSet() {
		return true
	}

	return false
}

// SetExpiryTimestampMsecs gets a reference to the given NullableInt64 and assigns it to the ExpiryTimestampMsecs field.
func (o *FileLockStatus) SetExpiryTimestampMsecs(v int64) {
	o.ExpiryTimestampMsecs.Set(&v)
}
// SetExpiryTimestampMsecsNil sets the value for ExpiryTimestampMsecs to be an explicit nil
func (o *FileLockStatus) SetExpiryTimestampMsecsNil() {
	o.ExpiryTimestampMsecs.Set(nil)
}

// UnsetExpiryTimestampMsecs ensures that no value is present for ExpiryTimestampMsecs, not even an explicit nil
func (o *FileLockStatus) UnsetExpiryTimestampMsecs() {
	o.ExpiryTimestampMsecs.Unset()
}

// GetHoldTimestampMsecs returns the HoldTimestampMsecs field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *FileLockStatus) GetHoldTimestampMsecs() int64 {
	if o == nil || IsNil(o.HoldTimestampMsecs.Get()) {
		var ret int64
		return ret
	}
	return *o.HoldTimestampMsecs.Get()
}

// GetHoldTimestampMsecsOk returns a tuple with the HoldTimestampMsecs field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *FileLockStatus) GetHoldTimestampMsecsOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return o.HoldTimestampMsecs.Get(), o.HoldTimestampMsecs.IsSet()
}

// HasHoldTimestampMsecs returns a boolean if a field has been set.
func (o *FileLockStatus) HasHoldTimestampMsecs() bool {
	if o != nil && o.HoldTimestampMsecs.IsSet() {
		return true
	}

	return false
}

// SetHoldTimestampMsecs gets a reference to the given NullableInt64 and assigns it to the HoldTimestampMsecs field.
func (o *FileLockStatus) SetHoldTimestampMsecs(v int64) {
	o.HoldTimestampMsecs.Set(&v)
}
// SetHoldTimestampMsecsNil sets the value for HoldTimestampMsecs to be an explicit nil
func (o *FileLockStatus) SetHoldTimestampMsecsNil() {
	o.HoldTimestampMsecs.Set(nil)
}

// UnsetHoldTimestampMsecs ensures that no value is present for HoldTimestampMsecs, not even an explicit nil
func (o *FileLockStatus) UnsetHoldTimestampMsecs() {
	o.HoldTimestampMsecs.Unset()
}

// GetLockTimestampMsecs returns the LockTimestampMsecs field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *FileLockStatus) GetLockTimestampMsecs() int64 {
	if o == nil || IsNil(o.LockTimestampMsecs.Get()) {
		var ret int64
		return ret
	}
	return *o.LockTimestampMsecs.Get()
}

// GetLockTimestampMsecsOk returns a tuple with the LockTimestampMsecs field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *FileLockStatus) GetLockTimestampMsecsOk() (*int64, bool) {
	if o == nil {
		return nil, false
	}
	return o.LockTimestampMsecs.Get(), o.LockTimestampMsecs.IsSet()
}

// HasLockTimestampMsecs returns a boolean if a field has been set.
func (o *FileLockStatus) HasLockTimestampMsecs() bool {
	if o != nil && o.LockTimestampMsecs.IsSet() {
		return true
	}

	return false
}

// SetLockTimestampMsecs gets a reference to the given NullableInt64 and assigns it to the LockTimestampMsecs field.
func (o *FileLockStatus) SetLockTimestampMsecs(v int64) {
	o.LockTimestampMsecs.Set(&v)
}
// SetLockTimestampMsecsNil sets the value for LockTimestampMsecs to be an explicit nil
func (o *FileLockStatus) SetLockTimestampMsecsNil() {
	o.LockTimestampMsecs.Set(nil)
}

// UnsetLockTimestampMsecs ensures that no value is present for LockTimestampMsecs, not even an explicit nil
func (o *FileLockStatus) UnsetLockTimestampMsecs() {
	o.LockTimestampMsecs.Unset()
}

// GetMode returns the Mode field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *FileLockStatus) GetMode() string {
	if o == nil || IsNil(o.Mode.Get()) {
		var ret string
		return ret
	}
	return *o.Mode.Get()
}

// GetModeOk returns a tuple with the Mode field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *FileLockStatus) GetModeOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Mode.Get(), o.Mode.IsSet()
}

// HasMode returns a boolean if a field has been set.
func (o *FileLockStatus) HasMode() bool {
	if o != nil && o.Mode.IsSet() {
		return true
	}

	return false
}

// SetMode gets a reference to the given NullableString and assigns it to the Mode field.
func (o *FileLockStatus) SetMode(v string) {
	o.Mode.Set(&v)
}
// SetModeNil sets the value for Mode to be an explicit nil
func (o *FileLockStatus) SetModeNil() {
	o.Mode.Set(nil)
}

// UnsetMode ensures that no value is present for Mode, not even an explicit nil
func (o *FileLockStatus) UnsetMode() {
	o.Mode.Unset()
}

// GetState returns the State field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *FileLockStatus) GetState() string {
	if o == nil || IsNil(o.State.Get()) {
		var ret string
		return ret
	}
	return *o.State.Get()
}

// GetStateOk returns a tuple with the State field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *FileLockStatus) GetStateOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.State.Get(), o.State.IsSet()
}

// HasState returns a boolean if a field has been set.
func (o *FileLockStatus) HasState() bool {
	if o != nil && o.State.IsSet() {
		return true
	}

	return false
}

// SetState gets a reference to the given NullableString and assigns it to the State field.
func (o *FileLockStatus) SetState(v string) {
	o.State.Set(&v)
}
// SetStateNil sets the value for State to be an explicit nil
func (o *FileLockStatus) SetStateNil() {
	o.State.Set(nil)
}

// UnsetState ensures that no value is present for State, not even an explicit nil
func (o *FileLockStatus) UnsetState() {
	o.State.Unset()
}

func (o FileLockStatus) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o FileLockStatus) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if o.ExpiryTimestampMsecs.IsSet() {
		toSerialize["expiryTimestampMsecs"] = o.ExpiryTimestampMsecs.Get()
	}
	if o.HoldTimestampMsecs.IsSet() {
		toSerialize["holdTimestampMsecs"] = o.HoldTimestampMsecs.Get()
	}
	if o.LockTimestampMsecs.IsSet() {
		toSerialize["lockTimestampMsecs"] = o.LockTimestampMsecs.Get()
	}
	if o.Mode.IsSet() {
		toSerialize["mode"] = o.Mode.Get()
	}
	if o.State.IsSet() {
		toSerialize["state"] = o.State.Get()
	}
	return toSerialize, nil
}

type NullableFileLockStatus struct {
	value *FileLockStatus
	isSet bool
}

func (v NullableFileLockStatus) Get() *FileLockStatus {
	return v.value
}

func (v *NullableFileLockStatus) Set(val *FileLockStatus) {
	v.value = val
	v.isSet = true
}

func (v NullableFileLockStatus) IsSet() bool {
	return v.isSet
}

func (v *NullableFileLockStatus) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFileLockStatus(val *FileLockStatus) *NullableFileLockStatus {
	return &NullableFileLockStatus{value: val, isSet: true}
}

func (v NullableFileLockStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFileLockStatus) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


