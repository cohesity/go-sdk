/*
Cohesity REST API

Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DataAccessorAPIService DataAccessorAPI service
type DataAccessorAPIService service

type ApiCreateDataAccessSessionRequest struct {
	ctx context.Context
	ApiService *DataAccessorAPIService
	body *CreateDataAccessSessionRequestParams
}

// Specifies the parameters to create data access session
func (r ApiCreateDataAccessSessionRequest) Body(body CreateDataAccessSessionRequestParams) ApiCreateDataAccessSessionRequest {
	r.body = &body
	return r
}

func (r ApiCreateDataAccessSessionRequest) Execute() (*CreateDataAccessSessionResponseParams, *http.Response, error) {
	return r.ApiService.CreateDataAccessSessionExecute(r)
}

/*
CreateDataAccessSession Create Data Access Session

Create data access session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDataAccessSessionRequest
*/
func (a *DataAccessorAPIService) CreateDataAccessSession(ctx context.Context) ApiCreateDataAccessSessionRequest {
	return ApiCreateDataAccessSessionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDataAccessSessionResponseParams
func (a *DataAccessorAPIService) CreateDataAccessSessionExecute(r ApiCreateDataAccessSessionRequest) (*CreateDataAccessSessionResponseParams, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDataAccessSessionResponseParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAccessorAPIService.CreateDataAccessSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-access/snapshots/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDifferenceOfGraphNodesRequest struct {
	ctx context.Context
	ApiService *DataAccessorAPIService
	sessionId string
	body *QueryGraphNodesDiffParams
}

// Specifies the parameters to determine graph nodes diff for a given session id.
func (r ApiDifferenceOfGraphNodesRequest) Body(body QueryGraphNodesDiffParams) ApiDifferenceOfGraphNodesRequest {
	r.body = &body
	return r
}

func (r ApiDifferenceOfGraphNodesRequest) Execute() (*QueryGraphNodesDiffResult, *http.Response, error) {
	return r.ApiService.DifferenceOfGraphNodesExecute(r)
}

/*
DifferenceOfGraphNodes Difference of Graph nodes

Query for difference of graph nodes between two snapshots of a session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Specifies the id of a session.
 @return ApiDifferenceOfGraphNodesRequest
*/
func (a *DataAccessorAPIService) DifferenceOfGraphNodes(ctx context.Context, sessionId string) ApiDifferenceOfGraphNodesRequest {
	return ApiDifferenceOfGraphNodesRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return QueryGraphNodesDiffResult
func (a *DataAccessorAPIService) DifferenceOfGraphNodesExecute(r ApiDifferenceOfGraphNodesRequest) (*QueryGraphNodesDiffResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryGraphNodesDiffResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAccessorAPIService.DifferenceOfGraphNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-access/snapshots/sessions/{sessionId}/graph-nodes/differences"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataAccessSessionsRequest struct {
	ctx context.Context
	ApiService *DataAccessorAPIService
	sessionIds *[]string
	startTimeUsecs *int64
	endTimeUsecs *int64
	snapshotEnvironments *[]string
	statuses *[]string
	paginationCookie *string
	count *int32
}

// Filter Data Access Sessions for given session ids.
func (r ApiGetDataAccessSessionsRequest) SessionIds(sessionIds []string) ApiGetDataAccessSessionsRequest {
	r.sessionIds = &sessionIds
	return r
}

// Returns the data access sessions which are started after the specific time. This value should be in Unix timestamp epoch in microseconds.
func (r ApiGetDataAccessSessionsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetDataAccessSessionsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}

// Returns the data access sessions which are started before the specific time. This value should be in Unix timestamp epoch in microseconds.
func (r ApiGetDataAccessSessionsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetDataAccessSessionsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}

// Specifies the snapshot environment types to filter data access sessions.
func (r ApiGetDataAccessSessionsRequest) SnapshotEnvironments(snapshotEnvironments []string) ApiGetDataAccessSessionsRequest {
	r.snapshotEnvironments = &snapshotEnvironments
	return r
}

// Specifies the list of session states to filter data access sessions
func (r ApiGetDataAccessSessionsRequest) Statuses(statuses []string) ApiGetDataAccessSessionsRequest {
	r.statuses = &statuses
	return r
}

// Specifies a cookie which can be passed in by the user in order to retrieve the next page of results.
func (r ApiGetDataAccessSessionsRequest) PaginationCookie(paginationCookie string) ApiGetDataAccessSessionsRequest {
	r.paginationCookie = &paginationCookie
	return r
}

// Specifies the number of objects to be fetched for the specified pagination cookie.
func (r ApiGetDataAccessSessionsRequest) Count(count int32) ApiGetDataAccessSessionsRequest {
	r.count = &count
	return r
}

func (r ApiGetDataAccessSessionsRequest) Execute() (*GetDataAccessSessionsResponseParams, *http.Response, error) {
	return r.ApiService.GetDataAccessSessionsExecute(r)
}

/*
GetDataAccessSessions Lists all the Data Access Sessions

Lists the Data Access Sessions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDataAccessSessionsRequest
*/
func (a *DataAccessorAPIService) GetDataAccessSessions(ctx context.Context) ApiGetDataAccessSessionsRequest {
	return ApiGetDataAccessSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDataAccessSessionsResponseParams
func (a *DataAccessorAPIService) GetDataAccessSessionsExecute(r ApiGetDataAccessSessionsRequest) (*GetDataAccessSessionsResponseParams, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDataAccessSessionsResponseParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAccessorAPIService.GetDataAccessSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-access/snapshots/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sessionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionIds", r.sessionIds, "csv")
	}
	if r.startTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeUsecs", r.startTimeUsecs, "")
	}
	if r.endTimeUsecs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimeUsecs", r.endTimeUsecs, "")
	}
	if r.snapshotEnvironments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "snapshotEnvironments", r.snapshotEnvironments, "csv")
	}
	if r.statuses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", r.statuses, "csv")
	}
	if r.paginationCookie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginationCookie", r.paginationCookie, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGraphNodeDetailsRequest struct {
	ctx context.Context
	ApiService *DataAccessorAPIService
	sessionId string
	nodeId string
	body *GetGraphNodeDetailsRequestParams
}

// Specifies the parameters to get node details in the graph for a given node id.
func (r ApiGetGraphNodeDetailsRequest) Body(body GetGraphNodeDetailsRequestParams) ApiGetGraphNodeDetailsRequest {
	r.body = &body
	return r
}

func (r ApiGetGraphNodeDetailsRequest) Execute() (*GetGraphNodeDetailsResult, *http.Response, error) {
	return r.ApiService.GetGraphNodeDetailsExecute(r)
}

/*
GetGraphNodeDetails Get Graph Node details

Get graph node details and it's relations for a node id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Specifies the id of a session.
 @param nodeId Specifies the id of a node.
 @return ApiGetGraphNodeDetailsRequest
*/
func (a *DataAccessorAPIService) GetGraphNodeDetails(ctx context.Context, sessionId string, nodeId string) ApiGetGraphNodeDetailsRequest {
	return ApiGetGraphNodeDetailsRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return GetGraphNodeDetailsResult
func (a *DataAccessorAPIService) GetGraphNodeDetailsExecute(r ApiGetGraphNodeDetailsRequest) (*GetGraphNodeDetailsResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetGraphNodeDetailsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAccessorAPIService.GetGraphNodeDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-access/snapshots/sessions/{sessionId}/graph-nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGraphNodeRelationsDifferencesRequest struct {
	ctx context.Context
	ApiService *DataAccessorAPIService
	sessionId string
	nodeId string
	body *GetGraphNodeRelationsDiffParams
}

// Specifies the parameters to search graph node relations for a given node id.
func (r ApiGetGraphNodeRelationsDifferencesRequest) Body(body GetGraphNodeRelationsDiffParams) ApiGetGraphNodeRelationsDifferencesRequest {
	r.body = &body
	return r
}

func (r ApiGetGraphNodeRelationsDifferencesRequest) Execute() (*DiffGraphNodeRelation, *http.Response, error) {
	return r.ApiService.GetGraphNodeRelationsDifferencesExecute(r)
}

/*
GetGraphNodeRelationsDifferences Query for difference of graph node relations

Query for difference of graph node relations between two snapshots of a session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Specifies the id of a session.
 @param nodeId Specifies the id of a graph node.
 @return ApiGetGraphNodeRelationsDifferencesRequest
*/
func (a *DataAccessorAPIService) GetGraphNodeRelationsDifferences(ctx context.Context, sessionId string, nodeId string) ApiGetGraphNodeRelationsDifferencesRequest {
	return ApiGetGraphNodeRelationsDifferencesRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return DiffGraphNodeRelation
func (a *DataAccessorAPIService) GetGraphNodeRelationsDifferencesExecute(r ApiGetGraphNodeRelationsDifferencesRequest) (*DiffGraphNodeRelation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiffGraphNodeRelation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAccessorAPIService.GetGraphNodeRelationsDifferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-access/snapshots/sessions/{sessionId}/graph-nodes/query-relations/{nodeId}/differences"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchGraphNodesRequest struct {
	ctx context.Context
	ApiService *DataAccessorAPIService
	body *SearchGraphNodesRequestParams
}

// Specifies the parameters to query nodes in the graph for a given session id.
func (r ApiSearchGraphNodesRequest) Body(body SearchGraphNodesRequestParams) ApiSearchGraphNodesRequest {
	r.body = &body
	return r
}

func (r ApiSearchGraphNodesRequest) Execute() (*SearchGraphNodesResponseParams, *http.Response, error) {
	return r.ApiService.SearchGraphNodesExecute(r)
}

/*
SearchGraphNodes Search Graph nodes

Search nodes in the graph for a given session id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchGraphNodesRequest
*/
func (a *DataAccessorAPIService) SearchGraphNodes(ctx context.Context) ApiSearchGraphNodesRequest {
	return ApiSearchGraphNodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchGraphNodesResponseParams
func (a *DataAccessorAPIService) SearchGraphNodesExecute(r ApiSearchGraphNodesRequest) (*SearchGraphNodesResponseParams, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchGraphNodesResponseParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAccessorAPIService.SearchGraphNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-access/snapshots/sessions/graph-nodes/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTearDownDataAccessSessionRequest struct {
	ctx context.Context
	ApiService *DataAccessorAPIService
	sessionId string
}

func (r ApiTearDownDataAccessSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.TearDownDataAccessSessionExecute(r)
}

/*
TearDownDataAccessSession Tear down data access session for a given id

Tear down data access session for a given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Specifies the id of the data access session.
 @return ApiTearDownDataAccessSessionRequest
*/
func (a *DataAccessorAPIService) TearDownDataAccessSession(ctx context.Context, sessionId string) ApiTearDownDataAccessSessionRequest {
	return ApiTearDownDataAccessSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *DataAccessorAPIService) TearDownDataAccessSessionExecute(r ApiTearDownDataAccessSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataAccessorAPIService.TearDownDataAccessSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/data-access/snapshots/sessions/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["APIKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["apiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
