// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// EntityBackupStats entity backup stats
//
// swagger:model EntityBackupStats
type EntityBackupStats struct {

	// Bytes read from the source during the current backup task. For example,
	// we only read the changed data during an incremental backup.
	BytesRead *int64 `json:"bytesRead,omitempty"`

	// Bytes written to SnapFS (<=bytes_read due to dedup and compression).
	BytesWritten *int64 `json:"bytesWritten,omitempty"`

	// entity size info
	EntitySizeInfo *EntitySizeInfo `json:"entitySizeInfo,omitempty"`

	// This indicates the subset of EntitySizeInfo.source_data_size_bytes that
	// is protected. This suffers for both the sources of ambiguity mentioned
	// for EntitySizeInfo.source_data_size_bytes.
	//
	// Additional ambiguity / limitation :
	// E.g. For VMware, the VMware tools based info does not provide details that
	// can be used to remove info for volumes that are part of the excluded disk.
	//
	// Due to the above ambiguity, this can be accurate only for agent based
	// adapters.
	SourceProtectedDataSizeBytes *int64 `json:"sourceProtectedDataSizeBytes,omitempty"`

	// source protected data size bytes computation method
	SourceProtectedDataSizeBytesComputationMethod *int32 `json:"sourceProtectedDataSizeBytesComputationMethod,omitempty"`

	// Total logical size of the source that is protected. This is optional. When
	// not set, we assume that the full logical size of the entity
	// (EntitySizeInfo.source_provisioned_logical_size_bytes) is protected.
	// This field is present to account for the case where there are disk
	// exclusions for a protected VM.
	SourceProtectedLogicalSizeBytes *int64 `json:"sourceProtectedLogicalSizeBytes,omitempty"`
}

// Validate validates this entity backup stats
func (m *EntityBackupStats) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEntitySizeInfo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EntityBackupStats) validateEntitySizeInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.EntitySizeInfo) { // not required
		return nil
	}

	if m.EntitySizeInfo != nil {
		if err := m.EntitySizeInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entitySizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entitySizeInfo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this entity backup stats based on the context it is used
func (m *EntityBackupStats) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEntitySizeInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *EntityBackupStats) contextValidateEntitySizeInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.EntitySizeInfo != nil {

		if swag.IsZero(m.EntitySizeInfo) { // not required
			return nil
		}

		if err := m.EntitySizeInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entitySizeInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entitySizeInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *EntityBackupStats) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *EntityBackupStats) UnmarshalBinary(b []byte) error {
	var res EntityBackupStats
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
