/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
)

// Linger please
var (
	_ _context.Context
)

// AuditApiService AuditApi service
type AuditApiService service

type ApiGetAuditLogsActionsRequest struct {
	ctx _context.Context
	ApiService *AuditApiService
}

/*

*/

/*
func (r ApiGetAuditLogsActionsRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetAuditLogsActionsExecute(r)
}

 * GetAuditLogsActions Return list of audit log actions.
 * A string array of all the actions used to filter audit logs.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAuditLogsActionsRequest
 
func (a *AuditApiService) GetAuditLogsActions(ctx _context.Context) ApiGetAuditLogsActionsRequest {
	return ApiGetAuditLogsActionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *AuditApiService) GetAuditLogsActions(r ApiGetAuditLogsActionsRequest) ([]string, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []string{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetAuditLogsActionsExecute(r)
}


/*
 * Execute executes the request
 * @return []string
 */
func (a *AuditApiService) GetAuditLogsActionsExecute(r ApiGetAuditLogsActionsRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.GetAuditLogsActions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/auditLogs/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuditLogsCategoriesRequest struct {
	ctx _context.Context
	ApiService *AuditApiService
}

/*

*/

/*
func (r ApiGetAuditLogsCategoriesRequest) Execute() ([]string, *_nethttp.Response, error) {
	return r.ApiService.GetAuditLogsCategoriesExecute(r)
}

 * GetAuditLogsCategories Return list of audit log categories.
 * A string array of all the categories used to filter audit logs.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAuditLogsCategoriesRequest
 
func (a *AuditApiService) GetAuditLogsCategories(ctx _context.Context) ApiGetAuditLogsCategoriesRequest {
	return ApiGetAuditLogsCategoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *AuditApiService) GetAuditLogsCategories(r ApiGetAuditLogsCategoriesRequest) ([]string, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []string{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetAuditLogsCategoriesExecute(r)
}


/*
 * Execute executes the request
 * @return []string
 */
func (a *AuditApiService) GetAuditLogsCategoriesExecute(r ApiGetAuditLogsCategoriesRequest) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.GetAuditLogsCategories")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/auditLogs/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchClusterAuditLogsRequest struct {
	ctx _context.Context
	ApiService *AuditApiService
	UserNames *[]string
	Domains *[]string
	EntityTypes *[]string
	Actions *[]string
	Search *string
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	StartIndex *int64
	PageCount *int64
	OutputFormat *string
	TenantId *string
	AllUnderHierarchy *bool
}

/*

func (r ApiSearchClusterAuditLogsRequest) UserNames(userNames []string) ApiSearchClusterAuditLogsRequest {
	r.userNames = &userNames
	return r
}
func (r ApiSearchClusterAuditLogsRequest) Domains(domains []string) ApiSearchClusterAuditLogsRequest {
	r.domains = &domains
	return r
}
func (r ApiSearchClusterAuditLogsRequest) EntityTypes(entityTypes []string) ApiSearchClusterAuditLogsRequest {
	r.entityTypes = &entityTypes
	return r
}
func (r ApiSearchClusterAuditLogsRequest) Actions(actions []string) ApiSearchClusterAuditLogsRequest {
	r.actions = &actions
	return r
}
func (r ApiSearchClusterAuditLogsRequest) Search(search string) ApiSearchClusterAuditLogsRequest {
	r.search = &search
	return r
}
func (r ApiSearchClusterAuditLogsRequest) StartTimeUsecs(startTimeUsecs int64) ApiSearchClusterAuditLogsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiSearchClusterAuditLogsRequest) EndTimeUsecs(endTimeUsecs int64) ApiSearchClusterAuditLogsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiSearchClusterAuditLogsRequest) StartIndex(startIndex int64) ApiSearchClusterAuditLogsRequest {
	r.startIndex = &startIndex
	return r
}
func (r ApiSearchClusterAuditLogsRequest) PageCount(pageCount int64) ApiSearchClusterAuditLogsRequest {
	r.pageCount = &pageCount
	return r
}
func (r ApiSearchClusterAuditLogsRequest) OutputFormat(outputFormat string) ApiSearchClusterAuditLogsRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiSearchClusterAuditLogsRequest) TenantId(tenantId string) ApiSearchClusterAuditLogsRequest {
	r.tenantId = &tenantId
	return r
}
func (r ApiSearchClusterAuditLogsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiSearchClusterAuditLogsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiSearchClusterAuditLogsRequest) Execute() (ClusterAuditLogsSearchResult, *_nethttp.Response, error) {
	return r.ApiService.SearchClusterAuditLogsExecute(r)
}

 * SearchClusterAuditLogs Lists the cluster audit logs on the Cohesity Cluster that match the filter criteria specified using parameters.
 * When actions (such as a login or a Job being paused) occur on the
Cohesity Cluster, the Cluster generates Audit Logs.
If no parameters are specified, all logs currently on the Cohesity Cluster
are returned. Specifying the parameters filters the results that are returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSearchClusterAuditLogsRequest
 
func (a *AuditApiService) SearchClusterAuditLogs(ctx _context.Context) ApiSearchClusterAuditLogsRequest {
	return ApiSearchClusterAuditLogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *AuditApiService) SearchClusterAuditLogs(r ApiSearchClusterAuditLogsRequest) (ClusterAuditLogsSearchResult, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ClusterAuditLogsSearchResult{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.SearchClusterAuditLogsExecute(r)
}


/*
 * Execute executes the request
 * @return ClusterAuditLogsSearchResult
 */
func (a *AuditApiService) SearchClusterAuditLogsExecute(r ApiSearchClusterAuditLogsRequest) (ClusterAuditLogsSearchResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterAuditLogsSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditApiService.SearchClusterAuditLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/auditLogs/cluster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.UserNames != nil {
		localVarQueryParams.Add("userNames", parameterToString(*r.UserNames, "csv"))
	}
	if r.Domains != nil {
		localVarQueryParams.Add("domains", parameterToString(*r.Domains, "csv"))
	}
	if r.EntityTypes != nil {
		localVarQueryParams.Add("entityTypes", parameterToString(*r.EntityTypes, "csv"))
	}
	if r.Actions != nil {
		localVarQueryParams.Add("actions", parameterToString(*r.Actions, "csv"))
	}
	if r.Search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.Search, ""))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.StartIndex != nil {
		localVarQueryParams.Add("startIndex", parameterToString(*r.StartIndex, ""))
	}
	if r.PageCount != nil {
		localVarQueryParams.Add("pageCount", parameterToString(*r.PageCount, ""))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.TenantId != nil {
		localVarQueryParams.Add("tenantId", parameterToString(*r.TenantId, ""))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
