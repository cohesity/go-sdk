/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// RestoreTasksApiService RestoreTasksApi service
type RestoreTasksApiService service

type ApiAdObjectsRestoreStatusRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	RestoreTaskId *int64
}

/*

func (r ApiAdObjectsRestoreStatusRequest) RestoreTaskId(restoreTaskId int64) ApiAdObjectsRestoreStatusRequest {
	r.restoreTaskId = &restoreTaskId
	return r
}
*/

/*
func (r ApiAdObjectsRestoreStatusRequest) Execute() (AdObjectsRestoreStatus, *_nethttp.Response, error) {
	return r.ApiService.AdObjectsRestoreStatusExecute(r)
}

 * AdObjectsRestoreStatus Method for AdObjectsRestoreStatus
 * Returns the Restore status of the AD objects which were restored from the
snapshot AD to production AD as part of the restore task id specified in the
parameters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAdObjectsRestoreStatusRequest
 
func (a *RestoreTasksApiService) AdObjectsRestoreStatus(ctx _context.Context) ApiAdObjectsRestoreStatusRequest {
	return ApiAdObjectsRestoreStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) AdObjectsRestoreStatus(r ApiAdObjectsRestoreStatusRequest) (AdObjectsRestoreStatus, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return AdObjectsRestoreStatus{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.AdObjectsRestoreStatusExecute(r)
}


/*
 * Execute executes the request
 * @return AdObjectsRestoreStatus
 */
func (a *RestoreTasksApiService) AdObjectsRestoreStatusExecute(r ApiAdObjectsRestoreStatusRequest) (AdObjectsRestoreStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AdObjectsRestoreStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.AdObjectsRestoreStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/adObjects/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.RestoreTaskId != nil {
		localVarQueryParams.Add("restoreTaskId", parameterToString(*r.RestoreTaskId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelRestoreTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Id int64
}

/*

*/

/*
func (r ApiCancelRestoreTaskRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CancelRestoreTaskExecute(r)
}

 * CancelRestoreTask Cancel a recover or clone task with specified id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id for the Restore Task.
 * @return ApiCancelRestoreTaskRequest
 
func (a *RestoreTasksApiService) CancelRestoreTask(ctx _context.Context, id int64) ApiCancelRestoreTaskRequest {
	return ApiCancelRestoreTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *RestoreTasksApiService) CancelRestoreTask(r ApiCancelRestoreTaskRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CancelRestoreTaskExecute(r)
}


/*
 * Execute executes the request
 */
func (a *RestoreTasksApiService) CancelRestoreTaskExecute(r ApiCancelRestoreTaskRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CancelRestoreTask")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/tasks/cancel/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompareAdObjectsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *CompareAdObjectsRequest
}

/*

func (r ApiCompareAdObjectsRequest) Body(body CompareAdObjectsRequest) ApiCompareAdObjectsRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCompareAdObjectsRequest) Execute() ([]ComparedADObject, *_nethttp.Response, error) {
	return r.ApiService.CompareAdObjectsExecute(r)
}

 * CompareAdObjects Compares the AD Object from both Snapshot and Production AD and returns the attributes with status whether they differ or not.
 * Returns the list of AD Objects after comparing attributes of AD Object from
both Snapshot and Production AD.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCompareAdObjectsRequest
 
func (a *RestoreTasksApiService) CompareAdObjects(ctx _context.Context) ApiCompareAdObjectsRequest {
	return ApiCompareAdObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CompareAdObjects(r ApiCompareAdObjectsRequest) ([]ComparedADObject, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ComparedADObject{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CompareAdObjectsExecute(r)
}


/*
 * Execute executes the request
 * @return []ComparedADObject
 */
func (a *RestoreTasksApiService) CompareAdObjectsExecute(r ApiCompareAdObjectsRequest) ([]ComparedADObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ComparedADObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CompareAdObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/adObjectAttributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationsCloneTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *ApplicationsRestoreTaskRequest
}

/*

func (r ApiCreateApplicationsCloneTaskRequest) Body(body ApplicationsRestoreTaskRequest) ApiCreateApplicationsCloneTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateApplicationsCloneTaskRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.CreateApplicationsCloneTaskExecute(r)
}

 * CreateApplicationsCloneTask Create a Restore Task for cloning Applications like SQL Databases.
 * Returns the created Restore Task.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateApplicationsCloneTaskRequest
 
func (a *RestoreTasksApiService) CreateApplicationsCloneTask(ctx _context.Context) ApiCreateApplicationsCloneTaskRequest {
	return ApiCreateApplicationsCloneTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CreateApplicationsCloneTask(r ApiCreateApplicationsCloneTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateApplicationsCloneTaskExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) CreateApplicationsCloneTaskExecute(r ApiCreateApplicationsCloneTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CreateApplicationsCloneTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/applicationsClone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApplicationsRecoverTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *ApplicationsRestoreTaskRequest
}

/*

func (r ApiCreateApplicationsRecoverTaskRequest) Body(body ApplicationsRestoreTaskRequest) ApiCreateApplicationsRecoverTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateApplicationsRecoverTaskRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.CreateApplicationsRecoverTaskExecute(r)
}

 * CreateApplicationsRecoverTask Create a Restore Task for recovering Applications like SQL Databases.
 * Returns the created Restore Task.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateApplicationsRecoverTaskRequest
 
func (a *RestoreTasksApiService) CreateApplicationsRecoverTask(ctx _context.Context) ApiCreateApplicationsRecoverTaskRequest {
	return ApiCreateApplicationsRecoverTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CreateApplicationsRecoverTask(r ApiCreateApplicationsRecoverTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateApplicationsRecoverTaskExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) CreateApplicationsRecoverTaskExecute(r ApiCreateApplicationsRecoverTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CreateApplicationsRecoverTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/applicationsRecover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloneTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *CloneTaskRequest
}

/*

func (r ApiCreateCloneTaskRequest) Body(body CloneTaskRequest) ApiCreateCloneTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateCloneTaskRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.CreateCloneTaskExecute(r)
}

 * CreateCloneTask Create a Restore Task for cloning VMs or a View.
 * Returns the created Restore Task that clones VMs or a View.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateCloneTaskRequest
 
func (a *RestoreTasksApiService) CreateCloneTask(ctx _context.Context) ApiCreateCloneTaskRequest {
	return ApiCreateCloneTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CreateCloneTask(r ApiCreateCloneTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateCloneTaskExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) CreateCloneTaskExecute(r ApiCreateCloneTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CreateCloneTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDeployTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *DeployTaskRequest
}

/*

func (r ApiCreateDeployTaskRequest) Body(body DeployTaskRequest) ApiCreateDeployTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateDeployTaskRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.CreateDeployTaskExecute(r)
}

 * CreateDeployTask Create a Restore Task for deploying VMs or a View on cloud.
 * Returns the created Restore Task that deploys VMs on cloud. This operation
returns the target where cloud is deployed. Currently, VMs can be deployed
in either AWS target or Azure target.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateDeployTaskRequest
 
func (a *RestoreTasksApiService) CreateDeployTask(ctx _context.Context) ApiCreateDeployTaskRequest {
	return ApiCreateDeployTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CreateDeployTask(r ApiCreateDeployTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateDeployTaskExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) CreateDeployTaskExecute(r ApiCreateDeployTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CreateDeployTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/deploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDownloadFilesAndFoldersRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *DownloadFilesAndFoldersParams
}

/*

func (r ApiCreateDownloadFilesAndFoldersRequest) Body(body DownloadFilesAndFoldersParams) ApiCreateDownloadFilesAndFoldersRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateDownloadFilesAndFoldersRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.CreateDownloadFilesAndFoldersExecute(r)
}

 * CreateDownloadFilesAndFolders Create a Download Task for downloading files and folders.
 * Returns the created download Task information that downloads files and folders.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateDownloadFilesAndFoldersRequest
 
func (a *RestoreTasksApiService) CreateDownloadFilesAndFolders(ctx _context.Context) ApiCreateDownloadFilesAndFoldersRequest {
	return ApiCreateDownloadFilesAndFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CreateDownloadFilesAndFolders(r ApiCreateDownloadFilesAndFoldersRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateDownloadFilesAndFoldersExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) CreateDownloadFilesAndFoldersExecute(r ApiCreateDownloadFilesAndFoldersRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CreateDownloadFilesAndFolders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/downloadFilesAndFolders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRecoverTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *RecoverTaskRequest
}

/*

func (r ApiCreateRecoverTaskRequest) Body(body RecoverTaskRequest) ApiCreateRecoverTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateRecoverTaskRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.CreateRecoverTaskExecute(r)
}

 * CreateRecoverTask Create a Restore Task for recovering VMs or instantly mounting volumes.
 * Returns the created Restore Task. This operation returns the following
types of Restore Tasks: 1) A Restore Task that recovers VMs back to the
original location or a new location. 2) A Restore Task that mounts the
volumes of a Server (such as a VM or Physical Server) onto the specified
target system. The Snapshots of the Server that contains the volumes
that are mounted is determined by Array of Objects.
The content of the Server is available from the mount point
for the Granular Level Recovery (GLR) of application data. For example
recovering Microsoft Exchange data using Kroll Ontrack® PowerControls™.

NOTE: Volumes are mounted "instantly" if the Snapshot is stored locally on the
Cohesity Cluster. If the Snapshot is archival target, it will take longer
because it must be retrieved.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateRecoverTaskRequest
 
func (a *RestoreTasksApiService) CreateRecoverTask(ctx _context.Context) ApiCreateRecoverTaskRequest {
	return ApiCreateRecoverTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CreateRecoverTask(r ApiCreateRecoverTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateRecoverTaskExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) CreateRecoverTaskExecute(r ApiCreateRecoverTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CreateRecoverTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/recover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRestoreFilesTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *RestoreFilesTaskRequest
}

/*

func (r ApiCreateRestoreFilesTaskRequest) Body(body RestoreFilesTaskRequest) ApiCreateRestoreFilesTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateRestoreFilesTaskRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.CreateRestoreFilesTaskExecute(r)
}

 * CreateRestoreFilesTask Create a Restore Task for recovering files and folders.
 * Returns the created Restore Task that recovers files and folders.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateRestoreFilesTaskRequest
 
func (a *RestoreTasksApiService) CreateRestoreFilesTask(ctx _context.Context) ApiCreateRestoreFilesTaskRequest {
	return ApiCreateRestoreFilesTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) CreateRestoreFilesTask(r ApiCreateRestoreFilesTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateRestoreFilesTaskExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) CreateRestoreFilesTaskExecute(r ApiCreateRestoreFilesTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.CreateRestoreFilesTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAdDomainRootTopologyRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	RestoreTaskId *int64
}

/*

func (r ApiGetAdDomainRootTopologyRequest) RestoreTaskId(restoreTaskId int64) ApiGetAdDomainRootTopologyRequest {
	r.restoreTaskId = &restoreTaskId
	return r
}
*/

/*
func (r ApiGetAdDomainRootTopologyRequest) Execute() ([]AdRootTopologyObject, *_nethttp.Response, error) {
	return r.ApiService.GetAdDomainRootTopologyExecute(r)
}

 * GetAdDomainRootTopology Gets Root Topology for an AD Domain.
 * Returns the root topology for an AD domain.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAdDomainRootTopologyRequest
 
func (a *RestoreTasksApiService) GetAdDomainRootTopology(ctx _context.Context) ApiGetAdDomainRootTopologyRequest {
	return ApiGetAdDomainRootTopologyRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetAdDomainRootTopology(r ApiGetAdDomainRootTopologyRequest) ([]AdRootTopologyObject, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []AdRootTopologyObject{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetAdDomainRootTopologyExecute(r)
}


/*
 * Execute executes the request
 * @return []AdRootTopologyObject
 */
func (a *RestoreTasksApiService) GetAdDomainRootTopologyExecute(r ApiGetAdDomainRootTopologyRequest) ([]AdRootTopologyObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AdRootTopologyObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetAdDomainRootTopology")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/adDomainRootTopology"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.RestoreTaskId == nil {
		return localVarReturnValue, nil, reportError("RestoreTaskId is required and must be specified")
	}

	localVarQueryParams.Add("restoreTaskId", parameterToString(*r.RestoreTaskId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAdObjectsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Name *string
	SamAccountName *string
	ObjectType *string
	Email *string
	RegisteredSourceIds *[]int64
	JobIds *[]int64
	ViewBoxIds *[]int64
	Domain *string
	TenantId *string
	AllUnderHierarchy *bool
}

/*

func (r ApiGetAdObjectsRequest) Name(name string) ApiGetAdObjectsRequest {
	r.name = &name
	return r
}
func (r ApiGetAdObjectsRequest) SamAccountName(samAccountName string) ApiGetAdObjectsRequest {
	r.samAccountName = &samAccountName
	return r
}
func (r ApiGetAdObjectsRequest) ObjectType(objectType string) ApiGetAdObjectsRequest {
	r.objectType = &objectType
	return r
}
func (r ApiGetAdObjectsRequest) Email(email string) ApiGetAdObjectsRequest {
	r.email = &email
	return r
}
func (r ApiGetAdObjectsRequest) RegisteredSourceIds(registeredSourceIds []int64) ApiGetAdObjectsRequest {
	r.registeredSourceIds = &registeredSourceIds
	return r
}
func (r ApiGetAdObjectsRequest) JobIds(jobIds []int64) ApiGetAdObjectsRequest {
	r.jobIds = &jobIds
	return r
}
func (r ApiGetAdObjectsRequest) ViewBoxIds(viewBoxIds []int64) ApiGetAdObjectsRequest {
	r.viewBoxIds = &viewBoxIds
	return r
}
func (r ApiGetAdObjectsRequest) Domain(domain string) ApiGetAdObjectsRequest {
	r.domain = &domain
	return r
}
func (r ApiGetAdObjectsRequest) TenantId(tenantId string) ApiGetAdObjectsRequest {
	r.tenantId = &tenantId
	return r
}
func (r ApiGetAdObjectsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetAdObjectsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiGetAdObjectsRequest) Execute() (FileSearchResults, *_nethttp.Response, error) {
	return r.ApiService.GetAdObjectsExecute(r)
}

 * GetAdObjects Method for GetAdObjects
 * Search for AD objects to recover that match the specified search and filter criterias
provided in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAdObjectsRequest
 
func (a *RestoreTasksApiService) GetAdObjects(ctx _context.Context) ApiGetAdObjectsRequest {
	return ApiGetAdObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetAdObjects(r ApiGetAdObjectsRequest) (FileSearchResults, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return FileSearchResults{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetAdObjectsExecute(r)
}


/*
 * Execute executes the request
 * @return FileSearchResults
 */
func (a *RestoreTasksApiService) GetAdObjectsExecute(r ApiGetAdObjectsRequest) (FileSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetAdObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/adObjects/searchResults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.Name, ""))
	}
	if r.SamAccountName != nil {
		localVarQueryParams.Add("samAccountName", parameterToString(*r.SamAccountName, ""))
	}
	if r.ObjectType != nil {
		localVarQueryParams.Add("objectType", parameterToString(*r.ObjectType, ""))
	}
	if r.Email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.Email, ""))
	}
	if r.RegisteredSourceIds != nil {
		localVarQueryParams.Add("registeredSourceIds", parameterToString(*r.RegisteredSourceIds, "csv"))
	}
	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.ViewBoxIds != nil {
		localVarQueryParams.Add("viewBoxIds", parameterToString(*r.ViewBoxIds, "csv"))
	}
	if r.Domain != nil {
		localVarQueryParams.Add("domain", parameterToString(*r.Domain, ""))
	}
	if r.TenantId != nil {
		localVarQueryParams.Add("tenantId", parameterToString(*r.TenantId, ""))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileFstatInformationRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	JobId *int64
	JobUidObjectId *int64
	EntityId *int64
	JobInstanceId *int64
	JobStartTimeUsecs *int64
	FilePath *string
	AttemptNum *int64
	VolumeName *string
	ViewBoxId *int64
	ViewName *string
	VolumeInfoCookie *int32
	UseLibrarian *bool
}

/*

func (r ApiGetFileFstatInformationRequest) JobId(jobId int64) ApiGetFileFstatInformationRequest {
	r.jobId = &jobId
	return r
}
func (r ApiGetFileFstatInformationRequest) JobUidObjectId(jobUidObjectId int64) ApiGetFileFstatInformationRequest {
	r.jobUidObjectId = &jobUidObjectId
	return r
}
func (r ApiGetFileFstatInformationRequest) EntityId(entityId int64) ApiGetFileFstatInformationRequest {
	r.entityId = &entityId
	return r
}
func (r ApiGetFileFstatInformationRequest) JobInstanceId(jobInstanceId int64) ApiGetFileFstatInformationRequest {
	r.jobInstanceId = &jobInstanceId
	return r
}
func (r ApiGetFileFstatInformationRequest) JobStartTimeUsecs(jobStartTimeUsecs int64) ApiGetFileFstatInformationRequest {
	r.jobStartTimeUsecs = &jobStartTimeUsecs
	return r
}
func (r ApiGetFileFstatInformationRequest) FilePath(filePath string) ApiGetFileFstatInformationRequest {
	r.filePath = &filePath
	return r
}
func (r ApiGetFileFstatInformationRequest) AttemptNum(attemptNum int64) ApiGetFileFstatInformationRequest {
	r.attemptNum = &attemptNum
	return r
}
func (r ApiGetFileFstatInformationRequest) VolumeName(volumeName string) ApiGetFileFstatInformationRequest {
	r.volumeName = &volumeName
	return r
}
func (r ApiGetFileFstatInformationRequest) ViewBoxId(viewBoxId int64) ApiGetFileFstatInformationRequest {
	r.viewBoxId = &viewBoxId
	return r
}
func (r ApiGetFileFstatInformationRequest) ViewName(viewName string) ApiGetFileFstatInformationRequest {
	r.viewName = &viewName
	return r
}
func (r ApiGetFileFstatInformationRequest) VolumeInfoCookie(volumeInfoCookie int32) ApiGetFileFstatInformationRequest {
	r.volumeInfoCookie = &volumeInfoCookie
	return r
}
func (r ApiGetFileFstatInformationRequest) UseLibrarian(useLibrarian bool) ApiGetFileFstatInformationRequest {
	r.useLibrarian = &useLibrarian
	return r
}
*/

/*
func (r ApiGetFileFstatInformationRequest) Execute() (FileFstatResult, *_nethttp.Response, error) {
	return r.ApiService.GetFileFstatInformationExecute(r)
}

 * GetFileFstatInformation Get the fstat information about file provided using query parameters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetFileFstatInformationRequest
 
func (a *RestoreTasksApiService) GetFileFstatInformation(ctx _context.Context) ApiGetFileFstatInformationRequest {
	return ApiGetFileFstatInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetFileFstatInformation(r ApiGetFileFstatInformationRequest) (FileFstatResult, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return FileFstatResult{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetFileFstatInformationExecute(r)
}


/*
 * Execute executes the request
 * @return FileFstatResult
 */
func (a *RestoreTasksApiService) GetFileFstatInformationExecute(r ApiGetFileFstatInformationRequest) (FileFstatResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileFstatResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetFileFstatInformation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/files/fstats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.JobId == nil {
		return localVarReturnValue, nil, reportError("JobId is required and must be specified")
	}
	if r.JobUidObjectId == nil {
		return localVarReturnValue, nil, reportError("JobUidObjectId is required and must be specified")
	}
	if r.EntityId == nil {
		return localVarReturnValue, nil, reportError("EntityId is required and must be specified")
	}
	if r.JobInstanceId == nil {
		return localVarReturnValue, nil, reportError("JobInstanceId is required and must be specified")
	}
	if r.JobStartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("JobStartTimeUsecs is required and must be specified")
	}
	if r.FilePath == nil {
		return localVarReturnValue, nil, reportError("FilePath is required and must be specified")
	}

	localVarQueryParams.Add("jobId", parameterToString(*r.JobId, ""))
	localVarQueryParams.Add("jobUidObjectId", parameterToString(*r.JobUidObjectId, ""))
	localVarQueryParams.Add("entityId", parameterToString(*r.EntityId, ""))
	localVarQueryParams.Add("jobInstanceId", parameterToString(*r.JobInstanceId, ""))
	localVarQueryParams.Add("jobStartTimeUsecs", parameterToString(*r.JobStartTimeUsecs, ""))
	if r.AttemptNum != nil {
		localVarQueryParams.Add("attemptNum", parameterToString(*r.AttemptNum, ""))
	}
	if r.VolumeName != nil {
		localVarQueryParams.Add("volumeName", parameterToString(*r.VolumeName, ""))
	}
	if r.ViewBoxId != nil {
		localVarQueryParams.Add("viewBoxId", parameterToString(*r.ViewBoxId, ""))
	}
	if r.ViewName != nil {
		localVarQueryParams.Add("viewName", parameterToString(*r.ViewName, ""))
	}
	if r.VolumeInfoCookie != nil {
		localVarQueryParams.Add("volumeInfoCookie", parameterToString(*r.VolumeInfoCookie, ""))
	}
	localVarQueryParams.Add("filePath", parameterToString(*r.FilePath, ""))
	if r.UseLibrarian != nil {
		localVarQueryParams.Add("useLibrarian", parameterToString(*r.UseLibrarian, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileSnapshotsInformationRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	JobId *int64
	ClusterId *int64
	ClusterIncarnationId *int64
	SourceId *int64
	Filename *string
}

/*

func (r ApiGetFileSnapshotsInformationRequest) JobId(jobId int64) ApiGetFileSnapshotsInformationRequest {
	r.jobId = &jobId
	return r
}
func (r ApiGetFileSnapshotsInformationRequest) ClusterId(clusterId int64) ApiGetFileSnapshotsInformationRequest {
	r.clusterId = &clusterId
	return r
}
func (r ApiGetFileSnapshotsInformationRequest) ClusterIncarnationId(clusterIncarnationId int64) ApiGetFileSnapshotsInformationRequest {
	r.clusterIncarnationId = &clusterIncarnationId
	return r
}
func (r ApiGetFileSnapshotsInformationRequest) SourceId(sourceId int64) ApiGetFileSnapshotsInformationRequest {
	r.sourceId = &sourceId
	return r
}
func (r ApiGetFileSnapshotsInformationRequest) Filename(filename string) ApiGetFileSnapshotsInformationRequest {
	r.filename = &filename
	return r
}
*/

/*
func (r ApiGetFileSnapshotsInformationRequest) Execute() ([]FileSnapshotInformation, *_nethttp.Response, error) {
	return r.ApiService.GetFileSnapshotsInformationExecute(r)
}

 * GetFileSnapshotsInformation Get the information about snapshots that contain the specified file or folder. In addition, information about the file or folder is provided.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetFileSnapshotsInformationRequest
 
func (a *RestoreTasksApiService) GetFileSnapshotsInformation(ctx _context.Context) ApiGetFileSnapshotsInformationRequest {
	return ApiGetFileSnapshotsInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetFileSnapshotsInformation(r ApiGetFileSnapshotsInformationRequest) ([]FileSnapshotInformation, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []FileSnapshotInformation{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetFileSnapshotsInformationExecute(r)
}


/*
 * Execute executes the request
 * @return []FileSnapshotInformation
 */
func (a *RestoreTasksApiService) GetFileSnapshotsInformationExecute(r ApiGetFileSnapshotsInformationRequest) ([]FileSnapshotInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FileSnapshotInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetFileSnapshotsInformation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/files/snapshotsInformation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.JobId == nil {
		return localVarReturnValue, nil, reportError("JobId is required and must be specified")
	}
	if r.ClusterId == nil {
		return localVarReturnValue, nil, reportError("ClusterId is required and must be specified")
	}
	if r.ClusterIncarnationId == nil {
		return localVarReturnValue, nil, reportError("ClusterIncarnationId is required and must be specified")
	}
	if r.SourceId == nil {
		return localVarReturnValue, nil, reportError("SourceId is required and must be specified")
	}
	if r.Filename == nil {
		return localVarReturnValue, nil, reportError("Filename is required and must be specified")
	}

	localVarQueryParams.Add("jobId", parameterToString(*r.JobId, ""))
	localVarQueryParams.Add("clusterId", parameterToString(*r.ClusterId, ""))
	localVarQueryParams.Add("clusterIncarnationId", parameterToString(*r.ClusterIncarnationId, ""))
	localVarQueryParams.Add("sourceId", parameterToString(*r.SourceId, ""))
	localVarQueryParams.Add("filename", parameterToString(*r.Filename, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOneDriveDocumentsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	TenantId *string
	AllUnderHierarchy *bool
	DocumentName *string
	DomainIds *[]int64
	MailboxIds *[]int64
	ProtectionJobIds *[]int64
}

/*

func (r ApiGetOneDriveDocumentsRequest) TenantId(tenantId string) ApiGetOneDriveDocumentsRequest {
	r.tenantId = &tenantId
	return r
}
func (r ApiGetOneDriveDocumentsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetOneDriveDocumentsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
func (r ApiGetOneDriveDocumentsRequest) DocumentName(documentName string) ApiGetOneDriveDocumentsRequest {
	r.documentName = &documentName
	return r
}
func (r ApiGetOneDriveDocumentsRequest) DomainIds(domainIds []int64) ApiGetOneDriveDocumentsRequest {
	r.domainIds = &domainIds
	return r
}
func (r ApiGetOneDriveDocumentsRequest) MailboxIds(mailboxIds []int64) ApiGetOneDriveDocumentsRequest {
	r.mailboxIds = &mailboxIds
	return r
}
func (r ApiGetOneDriveDocumentsRequest) ProtectionJobIds(protectionJobIds []int64) ApiGetOneDriveDocumentsRequest {
	r.protectionJobIds = &protectionJobIds
	return r
}
*/

/*
func (r ApiGetOneDriveDocumentsRequest) Execute() (FileSearchResults, *_nethttp.Response, error) {
	return r.ApiService.GetOneDriveDocumentsExecute(r)
}

 * GetOneDriveDocuments Returns the OneDrive files and folders.
 * Search for OneDrive files and folder to recover that match the specified
search and filter criterias on the Cohesity cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetOneDriveDocumentsRequest
 
func (a *RestoreTasksApiService) GetOneDriveDocuments(ctx _context.Context) ApiGetOneDriveDocumentsRequest {
	return ApiGetOneDriveDocumentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetOneDriveDocuments(r ApiGetOneDriveDocumentsRequest) (FileSearchResults, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return FileSearchResults{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetOneDriveDocumentsExecute(r)
}


/*
 * Execute executes the request
 * @return FileSearchResults
 */
func (a *RestoreTasksApiService) GetOneDriveDocumentsExecute(r ApiGetOneDriveDocumentsRequest) (FileSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetOneDriveDocuments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/office365/onedrive/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.TenantId != nil {
		localVarQueryParams.Add("tenantId", parameterToString(*r.TenantId, ""))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	if r.DocumentName != nil {
		localVarQueryParams.Add("documentName", parameterToString(*r.DocumentName, ""))
	}
	if r.DomainIds != nil {
		localVarQueryParams.Add("domainIds", parameterToString(*r.DomainIds, "csv"))
	}
	if r.MailboxIds != nil {
		localVarQueryParams.Add("mailboxIds", parameterToString(*r.MailboxIds, "csv"))
	}
	if r.ProtectionJobIds != nil {
		localVarQueryParams.Add("protectionJobIds", parameterToString(*r.ProtectionJobIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOutlookEmailsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	HasAttachments *bool
	SenderAddress *string
	RecipientAddresses *[]string
	CcRecipientAddresses *[]string
	BccRecipientAddresses *[]string
	SentTimeSeconds *int64
	ReceivedTimeSeconds *int64
	ReceivedStartTime *int64
	ReceivedEndTime *int64
	EmailSubject *string
	FolderName *string
	ShowOnlyEmailFolders *bool
	DomainIds *[]int64
	MailboxIds *[]int64
	ProtectionJobIds *[]int64
	TenantId *string
	AllUnderHierarchy *bool
}

/*

func (r ApiGetOutlookEmailsRequest) HasAttachments(hasAttachments bool) ApiGetOutlookEmailsRequest {
	r.hasAttachments = &hasAttachments
	return r
}
func (r ApiGetOutlookEmailsRequest) SenderAddress(senderAddress string) ApiGetOutlookEmailsRequest {
	r.senderAddress = &senderAddress
	return r
}
func (r ApiGetOutlookEmailsRequest) RecipientAddresses(recipientAddresses []string) ApiGetOutlookEmailsRequest {
	r.recipientAddresses = &recipientAddresses
	return r
}
func (r ApiGetOutlookEmailsRequest) CcRecipientAddresses(ccRecipientAddresses []string) ApiGetOutlookEmailsRequest {
	r.ccRecipientAddresses = &ccRecipientAddresses
	return r
}
func (r ApiGetOutlookEmailsRequest) BccRecipientAddresses(bccRecipientAddresses []string) ApiGetOutlookEmailsRequest {
	r.bccRecipientAddresses = &bccRecipientAddresses
	return r
}
func (r ApiGetOutlookEmailsRequest) SentTimeSeconds(sentTimeSeconds int64) ApiGetOutlookEmailsRequest {
	r.sentTimeSeconds = &sentTimeSeconds
	return r
}
func (r ApiGetOutlookEmailsRequest) ReceivedTimeSeconds(receivedTimeSeconds int64) ApiGetOutlookEmailsRequest {
	r.receivedTimeSeconds = &receivedTimeSeconds
	return r
}
func (r ApiGetOutlookEmailsRequest) ReceivedStartTime(receivedStartTime int64) ApiGetOutlookEmailsRequest {
	r.receivedStartTime = &receivedStartTime
	return r
}
func (r ApiGetOutlookEmailsRequest) ReceivedEndTime(receivedEndTime int64) ApiGetOutlookEmailsRequest {
	r.receivedEndTime = &receivedEndTime
	return r
}
func (r ApiGetOutlookEmailsRequest) EmailSubject(emailSubject string) ApiGetOutlookEmailsRequest {
	r.emailSubject = &emailSubject
	return r
}
func (r ApiGetOutlookEmailsRequest) FolderName(folderName string) ApiGetOutlookEmailsRequest {
	r.folderName = &folderName
	return r
}
func (r ApiGetOutlookEmailsRequest) ShowOnlyEmailFolders(showOnlyEmailFolders bool) ApiGetOutlookEmailsRequest {
	r.showOnlyEmailFolders = &showOnlyEmailFolders
	return r
}
func (r ApiGetOutlookEmailsRequest) DomainIds(domainIds []int64) ApiGetOutlookEmailsRequest {
	r.domainIds = &domainIds
	return r
}
func (r ApiGetOutlookEmailsRequest) MailboxIds(mailboxIds []int64) ApiGetOutlookEmailsRequest {
	r.mailboxIds = &mailboxIds
	return r
}
func (r ApiGetOutlookEmailsRequest) ProtectionJobIds(protectionJobIds []int64) ApiGetOutlookEmailsRequest {
	r.protectionJobIds = &protectionJobIds
	return r
}
func (r ApiGetOutlookEmailsRequest) TenantId(tenantId string) ApiGetOutlookEmailsRequest {
	r.tenantId = &tenantId
	return r
}
func (r ApiGetOutlookEmailsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetOutlookEmailsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiGetOutlookEmailsRequest) Execute() (FileSearchResults, *_nethttp.Response, error) {
	return r.ApiService.GetOutlookEmailsExecute(r)
}

 * GetOutlookEmails Returns the Outlook emails and folders containing emails.
 * Search for Emails and Emails' folders to recover that match the specified
search and filter criterias on the Cohesity cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetOutlookEmailsRequest
 
func (a *RestoreTasksApiService) GetOutlookEmails(ctx _context.Context) ApiGetOutlookEmailsRequest {
	return ApiGetOutlookEmailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetOutlookEmails(r ApiGetOutlookEmailsRequest) (FileSearchResults, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return FileSearchResults{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetOutlookEmailsExecute(r)
}


/*
 * Execute executes the request
 * @return FileSearchResults
 */
func (a *RestoreTasksApiService) GetOutlookEmailsExecute(r ApiGetOutlookEmailsRequest) (FileSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetOutlookEmails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/office365/outlook/emails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.HasAttachments != nil {
		localVarQueryParams.Add("hasAttachments", parameterToString(*r.HasAttachments, ""))
	}
	if r.SenderAddress != nil {
		localVarQueryParams.Add("senderAddress", parameterToString(*r.SenderAddress, ""))
	}
	if r.RecipientAddresses != nil {
		localVarQueryParams.Add("recipientAddresses", parameterToString(*r.RecipientAddresses, "csv"))
	}
	if r.CcRecipientAddresses != nil {
		localVarQueryParams.Add("ccRecipientAddresses", parameterToString(*r.CcRecipientAddresses, "csv"))
	}
	if r.BccRecipientAddresses != nil {
		localVarQueryParams.Add("bccRecipientAddresses", parameterToString(*r.BccRecipientAddresses, "csv"))
	}
	if r.SentTimeSeconds != nil {
		localVarQueryParams.Add("sentTimeSeconds", parameterToString(*r.SentTimeSeconds, ""))
	}
	if r.ReceivedTimeSeconds != nil {
		localVarQueryParams.Add("receivedTimeSeconds", parameterToString(*r.ReceivedTimeSeconds, ""))
	}
	if r.ReceivedStartTime != nil {
		localVarQueryParams.Add("receivedStartTime", parameterToString(*r.ReceivedStartTime, ""))
	}
	if r.ReceivedEndTime != nil {
		localVarQueryParams.Add("receivedEndTime", parameterToString(*r.ReceivedEndTime, ""))
	}
	if r.EmailSubject != nil {
		localVarQueryParams.Add("emailSubject", parameterToString(*r.EmailSubject, ""))
	}
	if r.FolderName != nil {
		localVarQueryParams.Add("folderName", parameterToString(*r.FolderName, ""))
	}
	if r.ShowOnlyEmailFolders != nil {
		localVarQueryParams.Add("showOnlyEmailFolders", parameterToString(*r.ShowOnlyEmailFolders, ""))
	}
	if r.DomainIds != nil {
		localVarQueryParams.Add("domainIds", parameterToString(*r.DomainIds, "csv"))
	}
	if r.MailboxIds != nil {
		localVarQueryParams.Add("mailboxIds", parameterToString(*r.MailboxIds, "csv"))
	}
	if r.ProtectionJobIds != nil {
		localVarQueryParams.Add("protectionJobIds", parameterToString(*r.ProtectionJobIds, "csv"))
	}
	if r.TenantId != nil {
		localVarQueryParams.Add("tenantId", parameterToString(*r.TenantId, ""))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRestorePointsForTimeRangeRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *RestorePointsForTimeRangeParam
}

/*

func (r ApiGetRestorePointsForTimeRangeRequest) Body(body RestorePointsForTimeRangeParam) ApiGetRestorePointsForTimeRangeRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiGetRestorePointsForTimeRangeRequest) Execute() (RestorePointsForTimeRange, *_nethttp.Response, error) {
	return r.ApiService.GetRestorePointsForTimeRangeExecute(r)
}

 * GetRestorePointsForTimeRange List Restore Points in a give time range.
 * Returns the snapshots in the time range specified.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetRestorePointsForTimeRangeRequest
 
func (a *RestoreTasksApiService) GetRestorePointsForTimeRange(ctx _context.Context) ApiGetRestorePointsForTimeRangeRequest {
	return ApiGetRestorePointsForTimeRangeRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetRestorePointsForTimeRange(r ApiGetRestorePointsForTimeRangeRequest) (RestorePointsForTimeRange, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestorePointsForTimeRange{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetRestorePointsForTimeRangeExecute(r)
}


/*
 * Execute executes the request
 * @return RestorePointsForTimeRange
 */
func (a *RestoreTasksApiService) GetRestorePointsForTimeRangeExecute(r ApiGetRestorePointsForTimeRangeRequest) (RestorePointsForTimeRange, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestorePointsForTimeRange
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetRestorePointsForTimeRange")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/pointsForTimeRange"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRestoreTaskByIdRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Id int64
}

/*

*/

/*
func (r ApiGetRestoreTaskByIdRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.GetRestoreTaskByIdExecute(r)
}

 * GetRestoreTaskById List details about a single Restore Task.
 * Returns the Restore Task corresponding to the specified Restore Task id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id for the Restore Task.
 * @return ApiGetRestoreTaskByIdRequest
 
func (a *RestoreTasksApiService) GetRestoreTaskById(ctx _context.Context, id int64) ApiGetRestoreTaskByIdRequest {
	return ApiGetRestoreTaskByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *RestoreTasksApiService) GetRestoreTaskById(r ApiGetRestoreTaskByIdRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetRestoreTaskByIdExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) GetRestoreTaskByIdExecute(r ApiGetRestoreTaskByIdRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetRestoreTaskById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/tasks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRestoreTasksRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	TaskIds *[]int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	PageCount *int64
	TaskTypes *[]string
	Environment *string
}

/*

func (r ApiGetRestoreTasksRequest) TaskIds(taskIds []int64) ApiGetRestoreTasksRequest {
	r.taskIds = &taskIds
	return r
}
func (r ApiGetRestoreTasksRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetRestoreTasksRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetRestoreTasksRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetRestoreTasksRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiGetRestoreTasksRequest) PageCount(pageCount int64) ApiGetRestoreTasksRequest {
	r.pageCount = &pageCount
	return r
}
func (r ApiGetRestoreTasksRequest) TaskTypes(taskTypes []string) ApiGetRestoreTasksRequest {
	r.taskTypes = &taskTypes
	return r
}
func (r ApiGetRestoreTasksRequest) Environment(environment string) ApiGetRestoreTasksRequest {
	r.environment = &environment
	return r
}
*/

/*
func (r ApiGetRestoreTasksRequest) Execute() ([]RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.GetRestoreTasksExecute(r)
}

 * GetRestoreTasks List the Restore Tasks filtered by the specified parameters.
 * If no parameters are specified, all Restore Tasks found
on the Cohesity Cluster are returned. Both running and completed
Restore Tasks are reported.
Specifying parameters filters the results that are returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetRestoreTasksRequest
 
func (a *RestoreTasksApiService) GetRestoreTasks(ctx _context.Context) ApiGetRestoreTasksRequest {
	return ApiGetRestoreTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetRestoreTasks(r ApiGetRestoreTasksRequest) ([]RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetRestoreTasksExecute(r)
}


/*
 * Execute executes the request
 * @return []RestoreTask
 */
func (a *RestoreTasksApiService) GetRestoreTasksExecute(r ApiGetRestoreTasksRequest) ([]RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetRestoreTasks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.TaskIds != nil {
		localVarQueryParams.Add("taskIds", parameterToString(*r.TaskIds, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.PageCount != nil {
		localVarQueryParams.Add("pageCount", parameterToString(*r.PageCount, ""))
	}
	if r.TaskTypes != nil {
		localVarQueryParams.Add("taskTypes", parameterToString(*r.TaskTypes, "csv"))
	}
	if r.Environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.Environment, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSharepointDocumentsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	TenantId *string
	AllUnderHierarchy *bool
	DocumentName *string
	DomainIds *[]int64
	SiteIds *[]int64
	ProtectionJobIds *[]int64
}

/*

func (r ApiGetSharepointDocumentsRequest) TenantId(tenantId string) ApiGetSharepointDocumentsRequest {
	r.tenantId = &tenantId
	return r
}
func (r ApiGetSharepointDocumentsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetSharepointDocumentsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
func (r ApiGetSharepointDocumentsRequest) DocumentName(documentName string) ApiGetSharepointDocumentsRequest {
	r.documentName = &documentName
	return r
}
func (r ApiGetSharepointDocumentsRequest) DomainIds(domainIds []int64) ApiGetSharepointDocumentsRequest {
	r.domainIds = &domainIds
	return r
}
func (r ApiGetSharepointDocumentsRequest) SiteIds(siteIds []int64) ApiGetSharepointDocumentsRequest {
	r.siteIds = &siteIds
	return r
}
func (r ApiGetSharepointDocumentsRequest) ProtectionJobIds(protectionJobIds []int64) ApiGetSharepointDocumentsRequest {
	r.protectionJobIds = &protectionJobIds
	return r
}
*/

/*
func (r ApiGetSharepointDocumentsRequest) Execute() (FileSearchResults, *_nethttp.Response, error) {
	return r.ApiService.GetSharepointDocumentsExecute(r)
}

 * GetSharepointDocuments Returns the Sharepoint Site's files and folders.
 * Search for Sharepoint files and folder to recover that match the specified
search and filter criterias on the Cohesity cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSharepointDocumentsRequest
 
func (a *RestoreTasksApiService) GetSharepointDocuments(ctx _context.Context) ApiGetSharepointDocumentsRequest {
	return ApiGetSharepointDocumentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetSharepointDocuments(r ApiGetSharepointDocumentsRequest) (FileSearchResults, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return FileSearchResults{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetSharepointDocumentsExecute(r)
}


/*
 * Execute executes the request
 * @return FileSearchResults
 */
func (a *RestoreTasksApiService) GetSharepointDocumentsExecute(r ApiGetSharepointDocumentsRequest) (FileSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetSharepointDocuments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/office365/sharepoint/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.TenantId != nil {
		localVarQueryParams.Add("tenantId", parameterToString(*r.TenantId, ""))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	if r.DocumentName != nil {
		localVarQueryParams.Add("documentName", parameterToString(*r.DocumentName, ""))
	}
	if r.DomainIds != nil {
		localVarQueryParams.Add("domainIds", parameterToString(*r.DomainIds, "csv"))
	}
	if r.SiteIds != nil {
		localVarQueryParams.Add("siteIds", parameterToString(*r.SiteIds, "csv"))
	}
	if r.ProtectionJobIds != nil {
		localVarQueryParams.Add("protectionJobIds", parameterToString(*r.ProtectionJobIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualDiskInformationRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	ClusterId *int64
	ClusterIncarnationId *int64
	JobId *int64
	JobRunId *int64
	StartTimeUsecs *int64
	SourceId *int64
	VaultId *int64
	VaultName *string
	VaultType *string
}

/*

func (r ApiGetVirtualDiskInformationRequest) ClusterId(clusterId int64) ApiGetVirtualDiskInformationRequest {
	r.clusterId = &clusterId
	return r
}
func (r ApiGetVirtualDiskInformationRequest) ClusterIncarnationId(clusterIncarnationId int64) ApiGetVirtualDiskInformationRequest {
	r.clusterIncarnationId = &clusterIncarnationId
	return r
}
func (r ApiGetVirtualDiskInformationRequest) JobId(jobId int64) ApiGetVirtualDiskInformationRequest {
	r.jobId = &jobId
	return r
}
func (r ApiGetVirtualDiskInformationRequest) JobRunId(jobRunId int64) ApiGetVirtualDiskInformationRequest {
	r.jobRunId = &jobRunId
	return r
}
func (r ApiGetVirtualDiskInformationRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetVirtualDiskInformationRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetVirtualDiskInformationRequest) SourceId(sourceId int64) ApiGetVirtualDiskInformationRequest {
	r.sourceId = &sourceId
	return r
}
func (r ApiGetVirtualDiskInformationRequest) VaultId(vaultId int64) ApiGetVirtualDiskInformationRequest {
	r.vaultId = &vaultId
	return r
}
func (r ApiGetVirtualDiskInformationRequest) VaultName(vaultName string) ApiGetVirtualDiskInformationRequest {
	r.vaultName = &vaultName
	return r
}
func (r ApiGetVirtualDiskInformationRequest) VaultType(vaultType string) ApiGetVirtualDiskInformationRequest {
	r.vaultType = &vaultType
	return r
}
*/

/*
func (r ApiGetVirtualDiskInformationRequest) Execute() ([]VirtualDiskInformation, *_nethttp.Response, error) {
	return r.ApiService.GetVirtualDiskInformationExecute(r)
}

 * GetVirtualDiskInformation Fetches information of virtual disk.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetVirtualDiskInformationRequest
 
func (a *RestoreTasksApiService) GetVirtualDiskInformation(ctx _context.Context) ApiGetVirtualDiskInformationRequest {
	return ApiGetVirtualDiskInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetVirtualDiskInformation(r ApiGetVirtualDiskInformationRequest) ([]VirtualDiskInformation, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []VirtualDiskInformation{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetVirtualDiskInformationExecute(r)
}


/*
 * Execute executes the request
 * @return []VirtualDiskInformation
 */
func (a *RestoreTasksApiService) GetVirtualDiskInformationExecute(r ApiGetVirtualDiskInformationRequest) ([]VirtualDiskInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []VirtualDiskInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetVirtualDiskInformation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/virtualDiskInformation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ClusterId == nil {
		return localVarReturnValue, nil, reportError("ClusterId is required and must be specified")
	}
	if r.ClusterIncarnationId == nil {
		return localVarReturnValue, nil, reportError("ClusterIncarnationId is required and must be specified")
	}
	if r.JobId == nil {
		return localVarReturnValue, nil, reportError("JobId is required and must be specified")
	}
	if r.JobRunId == nil {
		return localVarReturnValue, nil, reportError("JobRunId is required and must be specified")
	}
	if r.StartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("StartTimeUsecs is required and must be specified")
	}
	if r.SourceId == nil {
		return localVarReturnValue, nil, reportError("SourceId is required and must be specified")
	}

	localVarQueryParams.Add("clusterId", parameterToString(*r.ClusterId, ""))
	localVarQueryParams.Add("clusterIncarnationId", parameterToString(*r.ClusterIncarnationId, ""))
	localVarQueryParams.Add("jobId", parameterToString(*r.JobId, ""))
	localVarQueryParams.Add("jobRunId", parameterToString(*r.JobRunId, ""))
	localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	localVarQueryParams.Add("sourceId", parameterToString(*r.SourceId, ""))
	if r.VaultId != nil {
		localVarQueryParams.Add("vaultId", parameterToString(*r.VaultId, ""))
	}
	if r.VaultName != nil {
		localVarQueryParams.Add("vaultName", parameterToString(*r.VaultName, ""))
	}
	if r.VaultType != nil {
		localVarQueryParams.Add("vaultType", parameterToString(*r.VaultType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVmDirectoryListRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	JobId *int64
	JobUidObjectId *int64
	EntityId *int64
	JobInstanceId *int64
	JobStartTimeUsecs *int64
	DirPath *string
	AttemptNum *int64
	VolumeName *string
	ViewBoxId *int64
	ViewName *string
	MaxEntries *int32
	VolumeInfoCookie *int32
	Cookie *string
	StatFileEntries *bool
	BrowseIndexedData *bool
}

/*

func (r ApiGetVmDirectoryListRequest) JobId(jobId int64) ApiGetVmDirectoryListRequest {
	r.jobId = &jobId
	return r
}
func (r ApiGetVmDirectoryListRequest) JobUidObjectId(jobUidObjectId int64) ApiGetVmDirectoryListRequest {
	r.jobUidObjectId = &jobUidObjectId
	return r
}
func (r ApiGetVmDirectoryListRequest) EntityId(entityId int64) ApiGetVmDirectoryListRequest {
	r.entityId = &entityId
	return r
}
func (r ApiGetVmDirectoryListRequest) JobInstanceId(jobInstanceId int64) ApiGetVmDirectoryListRequest {
	r.jobInstanceId = &jobInstanceId
	return r
}
func (r ApiGetVmDirectoryListRequest) JobStartTimeUsecs(jobStartTimeUsecs int64) ApiGetVmDirectoryListRequest {
	r.jobStartTimeUsecs = &jobStartTimeUsecs
	return r
}
func (r ApiGetVmDirectoryListRequest) DirPath(dirPath string) ApiGetVmDirectoryListRequest {
	r.dirPath = &dirPath
	return r
}
func (r ApiGetVmDirectoryListRequest) AttemptNum(attemptNum int64) ApiGetVmDirectoryListRequest {
	r.attemptNum = &attemptNum
	return r
}
func (r ApiGetVmDirectoryListRequest) VolumeName(volumeName string) ApiGetVmDirectoryListRequest {
	r.volumeName = &volumeName
	return r
}
func (r ApiGetVmDirectoryListRequest) ViewBoxId(viewBoxId int64) ApiGetVmDirectoryListRequest {
	r.viewBoxId = &viewBoxId
	return r
}
func (r ApiGetVmDirectoryListRequest) ViewName(viewName string) ApiGetVmDirectoryListRequest {
	r.viewName = &viewName
	return r
}
func (r ApiGetVmDirectoryListRequest) MaxEntries(maxEntries int32) ApiGetVmDirectoryListRequest {
	r.maxEntries = &maxEntries
	return r
}
func (r ApiGetVmDirectoryListRequest) VolumeInfoCookie(volumeInfoCookie int32) ApiGetVmDirectoryListRequest {
	r.volumeInfoCookie = &volumeInfoCookie
	return r
}
func (r ApiGetVmDirectoryListRequest) Cookie(cookie string) ApiGetVmDirectoryListRequest {
	r.cookie = &cookie
	return r
}
func (r ApiGetVmDirectoryListRequest) StatFileEntries(statFileEntries bool) ApiGetVmDirectoryListRequest {
	r.statFileEntries = &statFileEntries
	return r
}
func (r ApiGetVmDirectoryListRequest) BrowseIndexedData(browseIndexedData bool) ApiGetVmDirectoryListRequest {
	r.browseIndexedData = &browseIndexedData
	return r
}
*/

/*
func (r ApiGetVmDirectoryListRequest) Execute() (VmDirectoryListResult, *_nethttp.Response, error) {
	return r.ApiService.GetVmDirectoryListExecute(r)
}

 * GetVmDirectoryList Get the directory list based on the given directory name and other query parameters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetVmDirectoryListRequest
 
func (a *RestoreTasksApiService) GetVmDirectoryList(ctx _context.Context) ApiGetVmDirectoryListRequest {
	return ApiGetVmDirectoryListRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetVmDirectoryList(r ApiGetVmDirectoryListRequest) (VmDirectoryListResult, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return VmDirectoryListResult{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetVmDirectoryListExecute(r)
}


/*
 * Execute executes the request
 * @return VmDirectoryListResult
 */
func (a *RestoreTasksApiService) GetVmDirectoryListExecute(r ApiGetVmDirectoryListRequest) (VmDirectoryListResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VmDirectoryListResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetVmDirectoryList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/vms/directoryList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.JobId == nil {
		return localVarReturnValue, nil, reportError("JobId is required and must be specified")
	}
	if r.JobUidObjectId == nil {
		return localVarReturnValue, nil, reportError("JobUidObjectId is required and must be specified")
	}
	if r.EntityId == nil {
		return localVarReturnValue, nil, reportError("EntityId is required and must be specified")
	}
	if r.JobInstanceId == nil {
		return localVarReturnValue, nil, reportError("JobInstanceId is required and must be specified")
	}
	if r.JobStartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("JobStartTimeUsecs is required and must be specified")
	}
	if r.DirPath == nil {
		return localVarReturnValue, nil, reportError("DirPath is required and must be specified")
	}

	localVarQueryParams.Add("jobId", parameterToString(*r.JobId, ""))
	localVarQueryParams.Add("jobUidObjectId", parameterToString(*r.JobUidObjectId, ""))
	localVarQueryParams.Add("entityId", parameterToString(*r.EntityId, ""))
	localVarQueryParams.Add("jobInstanceId", parameterToString(*r.JobInstanceId, ""))
	localVarQueryParams.Add("jobStartTimeUsecs", parameterToString(*r.JobStartTimeUsecs, ""))
	if r.AttemptNum != nil {
		localVarQueryParams.Add("attemptNum", parameterToString(*r.AttemptNum, ""))
	}
	if r.VolumeName != nil {
		localVarQueryParams.Add("volumeName", parameterToString(*r.VolumeName, ""))
	}
	if r.ViewBoxId != nil {
		localVarQueryParams.Add("viewBoxId", parameterToString(*r.ViewBoxId, ""))
	}
	if r.ViewName != nil {
		localVarQueryParams.Add("viewName", parameterToString(*r.ViewName, ""))
	}
	localVarQueryParams.Add("dirPath", parameterToString(*r.DirPath, ""))
	if r.MaxEntries != nil {
		localVarQueryParams.Add("maxEntries", parameterToString(*r.MaxEntries, ""))
	}
	if r.VolumeInfoCookie != nil {
		localVarQueryParams.Add("volumeInfoCookie", parameterToString(*r.VolumeInfoCookie, ""))
	}
	if r.Cookie != nil {
		localVarQueryParams.Add("cookie", parameterToString(*r.Cookie, ""))
	}
	if r.StatFileEntries != nil {
		localVarQueryParams.Add("statFileEntries", parameterToString(*r.StatFileEntries, ""))
	}
	if r.BrowseIndexedData != nil {
		localVarQueryParams.Add("browseIndexedData", parameterToString(*r.BrowseIndexedData, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVmVolumesInformationRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	JobId *int64
	ClusterId *int64
	ClusterIncarnationId *int64
	JobRunId *int64
	StartedTimeUsecs *int64
	SourceId *int64
	OriginalJobId *int64
	AttemptNumber *int64
	SupportedVolumesOnly *bool
	ComputeVolumeInfo *bool
}

/*

func (r ApiGetVmVolumesInformationRequest) JobId(jobId int64) ApiGetVmVolumesInformationRequest {
	r.jobId = &jobId
	return r
}
func (r ApiGetVmVolumesInformationRequest) ClusterId(clusterId int64) ApiGetVmVolumesInformationRequest {
	r.clusterId = &clusterId
	return r
}
func (r ApiGetVmVolumesInformationRequest) ClusterIncarnationId(clusterIncarnationId int64) ApiGetVmVolumesInformationRequest {
	r.clusterIncarnationId = &clusterIncarnationId
	return r
}
func (r ApiGetVmVolumesInformationRequest) JobRunId(jobRunId int64) ApiGetVmVolumesInformationRequest {
	r.jobRunId = &jobRunId
	return r
}
func (r ApiGetVmVolumesInformationRequest) StartedTimeUsecs(startedTimeUsecs int64) ApiGetVmVolumesInformationRequest {
	r.startedTimeUsecs = &startedTimeUsecs
	return r
}
func (r ApiGetVmVolumesInformationRequest) SourceId(sourceId int64) ApiGetVmVolumesInformationRequest {
	r.sourceId = &sourceId
	return r
}
func (r ApiGetVmVolumesInformationRequest) OriginalJobId(originalJobId int64) ApiGetVmVolumesInformationRequest {
	r.originalJobId = &originalJobId
	return r
}
func (r ApiGetVmVolumesInformationRequest) AttemptNumber(attemptNumber int64) ApiGetVmVolumesInformationRequest {
	r.attemptNumber = &attemptNumber
	return r
}
func (r ApiGetVmVolumesInformationRequest) SupportedVolumesOnly(supportedVolumesOnly bool) ApiGetVmVolumesInformationRequest {
	r.supportedVolumesOnly = &supportedVolumesOnly
	return r
}
func (r ApiGetVmVolumesInformationRequest) ComputeVolumeInfo(computeVolumeInfo bool) ApiGetVmVolumesInformationRequest {
	r.computeVolumeInfo = &computeVolumeInfo
	return r
}
*/

/*
func (r ApiGetVmVolumesInformationRequest) Execute() (VmVolumesInformation, *_nethttp.Response, error) {
	return r.ApiService.GetVmVolumesInformationExecute(r)
}

 * GetVmVolumesInformation Get information about the logical volumes found in a VM.
 * All required fields must be specified for this operation.
To get values for these fields, invoke the GET /public/restore/objects
operation.
A specific Job Run is defined by the jobRunId, startedTimeUsecs, and
attemptNumber fields.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetVmVolumesInformationRequest
 
func (a *RestoreTasksApiService) GetVmVolumesInformation(ctx _context.Context) ApiGetVmVolumesInformationRequest {
	return ApiGetVmVolumesInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) GetVmVolumesInformation(r ApiGetVmVolumesInformationRequest) (VmVolumesInformation, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return VmVolumesInformation{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetVmVolumesInformationExecute(r)
}


/*
 * Execute executes the request
 * @return VmVolumesInformation
 */
func (a *RestoreTasksApiService) GetVmVolumesInformationExecute(r ApiGetVmVolumesInformationRequest) (VmVolumesInformation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VmVolumesInformation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.GetVmVolumesInformation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/vms/volumesInformation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.JobId == nil {
		return localVarReturnValue, nil, reportError("JobId is required and must be specified")
	}
	if r.ClusterId == nil {
		return localVarReturnValue, nil, reportError("ClusterId is required and must be specified")
	}
	if r.ClusterIncarnationId == nil {
		return localVarReturnValue, nil, reportError("ClusterIncarnationId is required and must be specified")
	}
	if r.JobRunId == nil {
		return localVarReturnValue, nil, reportError("JobRunId is required and must be specified")
	}
	if r.StartedTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("StartedTimeUsecs is required and must be specified")
	}
	if r.SourceId == nil {
		return localVarReturnValue, nil, reportError("SourceId is required and must be specified")
	}
	if r.OriginalJobId == nil {
		return localVarReturnValue, nil, reportError("OriginalJobId is required and must be specified")
	}

	localVarQueryParams.Add("jobId", parameterToString(*r.JobId, ""))
	localVarQueryParams.Add("clusterId", parameterToString(*r.ClusterId, ""))
	localVarQueryParams.Add("clusterIncarnationId", parameterToString(*r.ClusterIncarnationId, ""))
	localVarQueryParams.Add("jobRunId", parameterToString(*r.JobRunId, ""))
	localVarQueryParams.Add("startedTimeUsecs", parameterToString(*r.StartedTimeUsecs, ""))
	if r.AttemptNumber != nil {
		localVarQueryParams.Add("attemptNumber", parameterToString(*r.AttemptNumber, ""))
	}
	localVarQueryParams.Add("sourceId", parameterToString(*r.SourceId, ""))
	localVarQueryParams.Add("originalJobId", parameterToString(*r.OriginalJobId, ""))
	if r.SupportedVolumesOnly != nil {
		localVarQueryParams.Add("supportedVolumesOnly", parameterToString(*r.SupportedVolumesOnly, ""))
	}
	if r.ComputeVolumeInfo != nil {
		localVarQueryParams.Add("computeVolumeInfo", parameterToString(*r.ComputeVolumeInfo, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStorageProfilesRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Id int64
}

/*

*/

/*
func (r ApiListStorageProfilesRequest) Execute() (ListStorageProfilesResponseBody, *_nethttp.Response, error) {
	return r.ApiService.ListStorageProfilesExecute(r)
}

 * ListStorageProfiles Fetches information of virtual disk.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id for the VDC.
 * @return ApiListStorageProfilesRequest
 
func (a *RestoreTasksApiService) ListStorageProfiles(ctx _context.Context, id int64) ApiListStorageProfilesRequest {
	return ApiListStorageProfilesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *RestoreTasksApiService) ListStorageProfiles(r ApiListStorageProfilesRequest) (ListStorageProfilesResponseBody, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ListStorageProfilesResponseBody{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListStorageProfilesExecute(r)
}


/*
 * Execute executes the request
 * @return ListStorageProfilesResponseBody
 */
func (a *RestoreTasksApiService) ListStorageProfilesExecute(r ApiListStorageProfilesRequest) (ListStorageProfilesResponseBody, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListStorageProfilesResponseBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.ListStorageProfiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/virtualDatacenters/{id}/storageProfiles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublicDestroyCloneTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Id int64
}

/*

*/

/*
func (r ApiPublicDestroyCloneTaskRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PublicDestroyCloneTaskExecute(r)
}

 * PublicDestroyCloneTask Destroy a clone task with specified id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Clone Task to destroy.
 * @return ApiPublicDestroyCloneTaskRequest
 
func (a *RestoreTasksApiService) PublicDestroyCloneTask(ctx _context.Context, id int64) ApiPublicDestroyCloneTaskRequest {
	return ApiPublicDestroyCloneTaskRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *RestoreTasksApiService) PublicDestroyCloneTask(r ApiPublicDestroyCloneTaskRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.PublicDestroyCloneTaskExecute(r)
}


/*
 * Execute executes the request
 */
func (a *RestoreTasksApiService) PublicDestroyCloneTaskExecute(r ApiPublicDestroyCloneTaskRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.PublicDestroyCloneTask")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/clone/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchAdObjectsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	RestoreTaskId *int64
	NumObjects *int32
	SearchBaseDn *string
	SubtreeSearchScope *bool
	CompareObjects *bool
	ExcludeSystemProperties *bool
	Filter *string
	RecordOffset *int32
}

/*

func (r ApiSearchAdObjectsRequest) RestoreTaskId(restoreTaskId int64) ApiSearchAdObjectsRequest {
	r.restoreTaskId = &restoreTaskId
	return r
}
func (r ApiSearchAdObjectsRequest) NumObjects(numObjects int32) ApiSearchAdObjectsRequest {
	r.numObjects = &numObjects
	return r
}
func (r ApiSearchAdObjectsRequest) SearchBaseDn(searchBaseDn string) ApiSearchAdObjectsRequest {
	r.searchBaseDn = &searchBaseDn
	return r
}
func (r ApiSearchAdObjectsRequest) SubtreeSearchScope(subtreeSearchScope bool) ApiSearchAdObjectsRequest {
	r.subtreeSearchScope = &subtreeSearchScope
	return r
}
func (r ApiSearchAdObjectsRequest) CompareObjects(compareObjects bool) ApiSearchAdObjectsRequest {
	r.compareObjects = &compareObjects
	return r
}
func (r ApiSearchAdObjectsRequest) ExcludeSystemProperties(excludeSystemProperties bool) ApiSearchAdObjectsRequest {
	r.excludeSystemProperties = &excludeSystemProperties
	return r
}
func (r ApiSearchAdObjectsRequest) Filter(filter string) ApiSearchAdObjectsRequest {
	r.filter = &filter
	return r
}
func (r ApiSearchAdObjectsRequest) RecordOffset(recordOffset int32) ApiSearchAdObjectsRequest {
	r.recordOffset = &recordOffset
	return r
}
*/

/*
func (r ApiSearchAdObjectsRequest) Execute() ([]ADObject, *_nethttp.Response, error) {
	return r.ApiService.SearchAdObjectsExecute(r)
}

 * SearchAdObjects Searches for AD Objects in both Production and Snapshot AD from given search base dn and offset.
 * Returns the list of AD Objects along with status whether they are missing in
Production AD, equal or not equal.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSearchAdObjectsRequest
 
func (a *RestoreTasksApiService) SearchAdObjects(ctx _context.Context) ApiSearchAdObjectsRequest {
	return ApiSearchAdObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) SearchAdObjects(r ApiSearchAdObjectsRequest) ([]ADObject, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ADObject{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.SearchAdObjectsExecute(r)
}


/*
 * Execute executes the request
 * @return []ADObject
 */
func (a *RestoreTasksApiService) SearchAdObjectsExecute(r ApiSearchAdObjectsRequest) ([]ADObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ADObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.SearchAdObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/adObjects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.RestoreTaskId == nil {
		return localVarReturnValue, nil, reportError("RestoreTaskId is required and must be specified")
	}

	localVarQueryParams.Add("restoreTaskId", parameterToString(*r.RestoreTaskId, ""))
	if r.NumObjects != nil {
		localVarQueryParams.Add("numObjects", parameterToString(*r.NumObjects, ""))
	}
	if r.SearchBaseDn != nil {
		localVarQueryParams.Add("searchBaseDn", parameterToString(*r.SearchBaseDn, ""))
	}
	if r.SubtreeSearchScope != nil {
		localVarQueryParams.Add("subtreeSearchScope", parameterToString(*r.SubtreeSearchScope, ""))
	}
	if r.CompareObjects != nil {
		localVarQueryParams.Add("compareObjects", parameterToString(*r.CompareObjects, ""))
	}
	if r.ExcludeSystemProperties != nil {
		localVarQueryParams.Add("excludeSystemProperties", parameterToString(*r.ExcludeSystemProperties, ""))
	}
	if r.Filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.Filter, ""))
	}
	if r.RecordOffset != nil {
		localVarQueryParams.Add("recordOffset", parameterToString(*r.RecordOffset, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchObjectsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Search *string
	JobIds *[]int64
	RegisteredSourceIds *[]int64
	ViewBoxIds *[]int64
	Environments *[]string
	Office365SourceTypes *[]string
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	StartIndex *int64
	PageCount *int64
	OperatingSystems *[]string
	Application *string
	OwnerEntityId *int64
	TenantId *string
	AllUnderHierarchy *bool
}

/*

func (r ApiSearchObjectsRequest) Search(search string) ApiSearchObjectsRequest {
	r.search = &search
	return r
}
func (r ApiSearchObjectsRequest) JobIds(jobIds []int64) ApiSearchObjectsRequest {
	r.jobIds = &jobIds
	return r
}
func (r ApiSearchObjectsRequest) RegisteredSourceIds(registeredSourceIds []int64) ApiSearchObjectsRequest {
	r.registeredSourceIds = &registeredSourceIds
	return r
}
func (r ApiSearchObjectsRequest) ViewBoxIds(viewBoxIds []int64) ApiSearchObjectsRequest {
	r.viewBoxIds = &viewBoxIds
	return r
}
func (r ApiSearchObjectsRequest) Environments(environments []string) ApiSearchObjectsRequest {
	r.environments = &environments
	return r
}
func (r ApiSearchObjectsRequest) Office365SourceTypes(office365SourceTypes []string) ApiSearchObjectsRequest {
	r.office365SourceTypes = &office365SourceTypes
	return r
}
func (r ApiSearchObjectsRequest) StartTimeUsecs(startTimeUsecs int64) ApiSearchObjectsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiSearchObjectsRequest) EndTimeUsecs(endTimeUsecs int64) ApiSearchObjectsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiSearchObjectsRequest) StartIndex(startIndex int64) ApiSearchObjectsRequest {
	r.startIndex = &startIndex
	return r
}
func (r ApiSearchObjectsRequest) PageCount(pageCount int64) ApiSearchObjectsRequest {
	r.pageCount = &pageCount
	return r
}
func (r ApiSearchObjectsRequest) OperatingSystems(operatingSystems []string) ApiSearchObjectsRequest {
	r.operatingSystems = &operatingSystems
	return r
}
func (r ApiSearchObjectsRequest) Application(application string) ApiSearchObjectsRequest {
	r.application = &application
	return r
}
func (r ApiSearchObjectsRequest) OwnerEntityId(ownerEntityId int64) ApiSearchObjectsRequest {
	r.ownerEntityId = &ownerEntityId
	return r
}
func (r ApiSearchObjectsRequest) TenantId(tenantId string) ApiSearchObjectsRequest {
	r.tenantId = &tenantId
	return r
}
func (r ApiSearchObjectsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiSearchObjectsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiSearchObjectsRequest) Execute() (ObjectSearchResults, *_nethttp.Response, error) {
	return r.ApiService.SearchObjectsExecute(r)
}

 * SearchObjects Find backup objects that match the specified search and filter criteria on the Cohesity Cluster.
 * If no search pattern or filter parameters are specified, all backup objects
currently found on the Cohesity Cluster are returned.
Only leaf objects that have been protected by a Job are returned such as VMs,
Views and databases.
Specify a search pattern or parameters to filter the results that
are returned.

The term "items" below refers to leaf backup objects such as VMs,
Views and databases.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSearchObjectsRequest
 
func (a *RestoreTasksApiService) SearchObjects(ctx _context.Context) ApiSearchObjectsRequest {
	return ApiSearchObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) SearchObjects(r ApiSearchObjectsRequest) (ObjectSearchResults, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ObjectSearchResults{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.SearchObjectsExecute(r)
}


/*
 * Execute executes the request
 * @return ObjectSearchResults
 */
func (a *RestoreTasksApiService) SearchObjectsExecute(r ApiSearchObjectsRequest) (ObjectSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ObjectSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.SearchObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.Search, ""))
	}
	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.RegisteredSourceIds != nil {
		localVarQueryParams.Add("registeredSourceIds", parameterToString(*r.RegisteredSourceIds, "csv"))
	}
	if r.ViewBoxIds != nil {
		localVarQueryParams.Add("viewBoxIds", parameterToString(*r.ViewBoxIds, "csv"))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.Office365SourceTypes != nil {
		localVarQueryParams.Add("office365SourceTypes", parameterToString(*r.Office365SourceTypes, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.StartIndex != nil {
		localVarQueryParams.Add("startIndex", parameterToString(*r.StartIndex, ""))
	}
	if r.PageCount != nil {
		localVarQueryParams.Add("pageCount", parameterToString(*r.PageCount, ""))
	}
	if r.OperatingSystems != nil {
		localVarQueryParams.Add("operatingSystems", parameterToString(*r.OperatingSystems, "csv"))
	}
	if r.Application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.Application, ""))
	}
	if r.OwnerEntityId != nil {
		localVarQueryParams.Add("ownerEntityId", parameterToString(*r.OwnerEntityId, ""))
	}
	if r.TenantId != nil {
		localVarQueryParams.Add("tenantId", parameterToString(*r.TenantId, ""))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchProductionAdObjectsRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *SearchProductionAdObjectsRequest
}

/*

func (r ApiSearchProductionAdObjectsRequest) Body(body SearchProductionAdObjectsRequest) ApiSearchProductionAdObjectsRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiSearchProductionAdObjectsRequest) Execute() ([]ADObject, *_nethttp.Response, error) {
	return r.ApiService.SearchProductionAdObjectsExecute(r)
}

 * SearchProductionAdObjects Searches for AD Objects that match the list of object guids, sam account names and distinguished names provided in the request.
 * Returns the list of AD Objects that match the list of object guids,
sam account names and distinguished names provided in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSearchProductionAdObjectsRequest
 
func (a *RestoreTasksApiService) SearchProductionAdObjects(ctx _context.Context) ApiSearchProductionAdObjectsRequest {
	return ApiSearchProductionAdObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) SearchProductionAdObjects(r ApiSearchProductionAdObjectsRequest) ([]ADObject, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ADObject{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.SearchProductionAdObjectsExecute(r)
}


/*
 * Execute executes the request
 * @return []ADObject
 */
func (a *RestoreTasksApiService) SearchProductionAdObjectsExecute(r ApiSearchProductionAdObjectsRequest) ([]ADObject, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ADObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.SearchProductionAdObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/adObjects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRestoredFilesRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	MustHaveTags *[]string
	MightHaveTags *[]string
	MustHaveSnapshotTags *[]string
	MightHaveSnapshotTags *[]string
	Paginate *bool
	PageSize *int32
	PaginationCookie *string
	Search *string
	JobIds *[]int64
	RegisteredSourceIds *[]int64
	ViewBoxIds *[]int64
	Environments *[]string
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	StartIndex *int64
	PageCount *int64
	SourceIds *[]int64
	FolderOnly *bool
	TenantId *string
	AllUnderHierarchy *bool
}

/*

func (r ApiSearchRestoredFilesRequest) MustHaveTags(mustHaveTags []string) ApiSearchRestoredFilesRequest {
	r.mustHaveTags = &mustHaveTags
	return r
}
func (r ApiSearchRestoredFilesRequest) MightHaveTags(mightHaveTags []string) ApiSearchRestoredFilesRequest {
	r.mightHaveTags = &mightHaveTags
	return r
}
func (r ApiSearchRestoredFilesRequest) MustHaveSnapshotTags(mustHaveSnapshotTags []string) ApiSearchRestoredFilesRequest {
	r.mustHaveSnapshotTags = &mustHaveSnapshotTags
	return r
}
func (r ApiSearchRestoredFilesRequest) MightHaveSnapshotTags(mightHaveSnapshotTags []string) ApiSearchRestoredFilesRequest {
	r.mightHaveSnapshotTags = &mightHaveSnapshotTags
	return r
}
func (r ApiSearchRestoredFilesRequest) Paginate(paginate bool) ApiSearchRestoredFilesRequest {
	r.paginate = &paginate
	return r
}
func (r ApiSearchRestoredFilesRequest) PageSize(pageSize int32) ApiSearchRestoredFilesRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiSearchRestoredFilesRequest) PaginationCookie(paginationCookie string) ApiSearchRestoredFilesRequest {
	r.paginationCookie = &paginationCookie
	return r
}
func (r ApiSearchRestoredFilesRequest) Search(search string) ApiSearchRestoredFilesRequest {
	r.search = &search
	return r
}
func (r ApiSearchRestoredFilesRequest) JobIds(jobIds []int64) ApiSearchRestoredFilesRequest {
	r.jobIds = &jobIds
	return r
}
func (r ApiSearchRestoredFilesRequest) RegisteredSourceIds(registeredSourceIds []int64) ApiSearchRestoredFilesRequest {
	r.registeredSourceIds = &registeredSourceIds
	return r
}
func (r ApiSearchRestoredFilesRequest) ViewBoxIds(viewBoxIds []int64) ApiSearchRestoredFilesRequest {
	r.viewBoxIds = &viewBoxIds
	return r
}
func (r ApiSearchRestoredFilesRequest) Environments(environments []string) ApiSearchRestoredFilesRequest {
	r.environments = &environments
	return r
}
func (r ApiSearchRestoredFilesRequest) StartTimeUsecs(startTimeUsecs int64) ApiSearchRestoredFilesRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiSearchRestoredFilesRequest) EndTimeUsecs(endTimeUsecs int64) ApiSearchRestoredFilesRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiSearchRestoredFilesRequest) StartIndex(startIndex int64) ApiSearchRestoredFilesRequest {
	r.startIndex = &startIndex
	return r
}
func (r ApiSearchRestoredFilesRequest) PageCount(pageCount int64) ApiSearchRestoredFilesRequest {
	r.pageCount = &pageCount
	return r
}
func (r ApiSearchRestoredFilesRequest) SourceIds(sourceIds []int64) ApiSearchRestoredFilesRequest {
	r.sourceIds = &sourceIds
	return r
}
func (r ApiSearchRestoredFilesRequest) FolderOnly(folderOnly bool) ApiSearchRestoredFilesRequest {
	r.folderOnly = &folderOnly
	return r
}
func (r ApiSearchRestoredFilesRequest) TenantId(tenantId string) ApiSearchRestoredFilesRequest {
	r.tenantId = &tenantId
	return r
}
func (r ApiSearchRestoredFilesRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiSearchRestoredFilesRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiSearchRestoredFilesRequest) Execute() (FileSearchResults, *_nethttp.Response, error) {
	return r.ApiService.SearchRestoredFilesExecute(r)
}

 * SearchRestoredFiles Search for files and folders to recover that match the specified search and filter criteria on the Cohesity Cluster.
 * Use the files and folders returned by this operation to populate the
list of files and folders to recover in the
POST /public/restore/files operation.
If no search pattern or filter parameters are specified, all files
and folders currently found on the Cohesity Cluster are returned.
Specify a search pattern or parameters to filter the results that
are returned.

The term "items" below refers to files and folders that are found
in the source objects (such as VMs).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSearchRestoredFilesRequest
 
func (a *RestoreTasksApiService) SearchRestoredFiles(ctx _context.Context) ApiSearchRestoredFilesRequest {
	return ApiSearchRestoredFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) SearchRestoredFiles(r ApiSearchRestoredFilesRequest) (FileSearchResults, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return FileSearchResults{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.SearchRestoredFilesExecute(r)
}


/*
 * Execute executes the request
 * @return FileSearchResults
 */
func (a *RestoreTasksApiService) SearchRestoredFilesExecute(r ApiSearchRestoredFilesRequest) (FileSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FileSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.SearchRestoredFiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.MustHaveTags != nil {
		localVarQueryParams.Add("mustHaveTags", parameterToString(*r.MustHaveTags, "csv"))
	}
	if r.MightHaveTags != nil {
		localVarQueryParams.Add("mightHaveTags", parameterToString(*r.MightHaveTags, "csv"))
	}
	if r.MustHaveSnapshotTags != nil {
		localVarQueryParams.Add("mustHaveSnapshotTags", parameterToString(*r.MustHaveSnapshotTags, "csv"))
	}
	if r.MightHaveSnapshotTags != nil {
		localVarQueryParams.Add("mightHaveSnapshotTags", parameterToString(*r.MightHaveSnapshotTags, "csv"))
	}
	if r.Paginate != nil {
		localVarQueryParams.Add("paginate", parameterToString(*r.Paginate, ""))
	}
	if r.PageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.PageSize, ""))
	}
	if r.PaginationCookie != nil {
		localVarQueryParams.Add("paginationCookie", parameterToString(*r.PaginationCookie, ""))
	}
	if r.Search != nil {
		localVarQueryParams.Add("search", parameterToString(*r.Search, ""))
	}
	if r.JobIds != nil {
		localVarQueryParams.Add("jobIds", parameterToString(*r.JobIds, "csv"))
	}
	if r.RegisteredSourceIds != nil {
		localVarQueryParams.Add("registeredSourceIds", parameterToString(*r.RegisteredSourceIds, "csv"))
	}
	if r.ViewBoxIds != nil {
		localVarQueryParams.Add("viewBoxIds", parameterToString(*r.ViewBoxIds, "csv"))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.StartIndex != nil {
		localVarQueryParams.Add("startIndex", parameterToString(*r.StartIndex, ""))
	}
	if r.PageCount != nil {
		localVarQueryParams.Add("pageCount", parameterToString(*r.PageCount, ""))
	}
	if r.SourceIds != nil {
		localVarQueryParams.Add("sourceIds", parameterToString(*r.SourceIds, "csv"))
	}
	if r.FolderOnly != nil {
		localVarQueryParams.Add("folderOnly", parameterToString(*r.FolderOnly, ""))
	}
	if r.TenantId != nil {
		localVarQueryParams.Add("tenantId", parameterToString(*r.TenantId, ""))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRestoreTaskRequest struct {
	ctx _context.Context
	ApiService *RestoreTasksApiService
	Body *UpdateRestoreTaskParams
}

/*

func (r ApiUpdateRestoreTaskRequest) Body(body UpdateRestoreTaskParams) ApiUpdateRestoreTaskRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateRestoreTaskRequest) Execute() (RestoreTask, *_nethttp.Response, error) {
	return r.ApiService.UpdateRestoreTaskExecute(r)
}

 * UpdateRestoreTask Method for UpdateRestoreTask
 * Updates an existing restore task with additional params which are needed for
features like Hot-Standby.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateRestoreTaskRequest
 
func (a *RestoreTasksApiService) UpdateRestoreTask(ctx _context.Context) ApiUpdateRestoreTaskRequest {
	return ApiUpdateRestoreTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *RestoreTasksApiService) UpdateRestoreTask(r ApiUpdateRestoreTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreTask{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateRestoreTaskExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreTask
 */
func (a *RestoreTasksApiService) UpdateRestoreTaskExecute(r ApiUpdateRestoreTaskRequest) (RestoreTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RestoreTasksApiService.UpdateRestoreTask")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/restore/recover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
