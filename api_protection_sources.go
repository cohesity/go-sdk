/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ProtectionSourcesApiService ProtectionSourcesApi service
type ProtectionSourcesApiService service

type ApiDownloadCftFileRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Body *DownloadCftParams
}

/*

func (r ApiDownloadCftFileRequest) Body(body DownloadCftParams) ApiDownloadCftFileRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiDownloadCftFileRequest) Execute() (DownloadCftResponse, *_nethttp.Response, error) {
	return r.ApiService.DownloadCftFileExecute(r)
}

 * DownloadCftFile Download the CFT.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDownloadCftFileRequest
 
func (a *ProtectionSourcesApiService) DownloadCftFile(ctx _context.Context) ApiDownloadCftFileRequest {
	return ApiDownloadCftFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) DownloadCftFile(r ApiDownloadCftFileRequest) (DownloadCftResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return DownloadCftResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.DownloadCftFileExecute(r)
}


/*
 * Execute executes the request
 * @return DownloadCftResponse
 */
func (a *ProtectionSourcesApiService) DownloadCftFileExecute(r ApiDownloadCftFileRequest) (DownloadCftResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DownloadCftResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.DownloadCftFile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/downloadCftFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadPhysicalAgentRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	HostType *string
	PkgType *string
	AgentType *string
}

/*

func (r ApiDownloadPhysicalAgentRequest) HostType(hostType string) ApiDownloadPhysicalAgentRequest {
	r.hostType = &hostType
	return r
}
func (r ApiDownloadPhysicalAgentRequest) PkgType(pkgType string) ApiDownloadPhysicalAgentRequest {
	r.pkgType = &pkgType
	return r
}
func (r ApiDownloadPhysicalAgentRequest) AgentType(agentType string) ApiDownloadPhysicalAgentRequest {
	r.agentType = &agentType
	return r
}
*/

/*
func (r ApiDownloadPhysicalAgentRequest) Execute() ([]int32, *_nethttp.Response, error) {
	return r.ApiService.DownloadPhysicalAgentExecute(r)
}

 * DownloadPhysicalAgent Download the physical agent for a host type.
 * Host type could be Linux, Windows, AIX.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDownloadPhysicalAgentRequest
 
func (a *ProtectionSourcesApiService) DownloadPhysicalAgent(ctx _context.Context) ApiDownloadPhysicalAgentRequest {
	return ApiDownloadPhysicalAgentRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) DownloadPhysicalAgent(r ApiDownloadPhysicalAgentRequest) ([]int32, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []int32{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.DownloadPhysicalAgentExecute(r)
}


/*
 * Execute executes the request
 * @return []int32
 */
func (a *ProtectionSourcesApiService) DownloadPhysicalAgentExecute(r ApiDownloadPhysicalAgentRequest) ([]int32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.DownloadPhysicalAgent")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/physicalAgents/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.HostType == nil {
		return localVarReturnValue, nil, reportError("HostType is required and must be specified")
	}

	localVarQueryParams.Add("hostType", parameterToString(*r.HostType, ""))
	if r.PkgType != nil {
		localVarQueryParams.Add("pkgType", parameterToString(*r.PkgType, ""))
	}
	if r.AgentType != nil {
		localVarQueryParams.Add("agentType", parameterToString(*r.AgentType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionSourcesObjectByIdRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Id int64
}

/*

*/

/*
func (r ApiGetProtectionSourcesObjectByIdRequest) Execute() (ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionSourcesObjectByIdExecute(r)
}

 * GetProtectionSourcesObjectById Get details about a single Protection Source Object.
 * Returns the Protection Source object corresponding to the specified id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Source to return.
 * @return ApiGetProtectionSourcesObjectByIdRequest
 
func (a *ProtectionSourcesApiService) GetProtectionSourcesObjectById(ctx _context.Context, id int64) ApiGetProtectionSourcesObjectByIdRequest {
	return ApiGetProtectionSourcesObjectByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionSourcesApiService) GetProtectionSourcesObjectById(r ApiGetProtectionSourcesObjectByIdRequest) (ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionSourcesObjectByIdExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSource
 */
func (a *ProtectionSourcesApiService) GetProtectionSourcesObjectByIdExecute(r ApiGetProtectionSourcesObjectByIdRequest) (ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.GetProtectionSourcesObjectById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/objects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionSourcesObjectsRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	ObjectIds *[]int64
}

/*

func (r ApiGetProtectionSourcesObjectsRequest) ObjectIds(objectIds []int64) ApiGetProtectionSourcesObjectsRequest {
	r.objectIds = &objectIds
	return r
}
*/

/*
func (r ApiGetProtectionSourcesObjectsRequest) Execute() ([]ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionSourcesObjectsExecute(r)
}

 * GetProtectionSourcesObjects List details about Protection Source objects.
 * Returns the Protection Source objects corresponding to the specified ids.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectionSourcesObjectsRequest
 
func (a *ProtectionSourcesApiService) GetProtectionSourcesObjects(ctx _context.Context) ApiGetProtectionSourcesObjectsRequest {
	return ApiGetProtectionSourcesObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) GetProtectionSourcesObjects(r ApiGetProtectionSourcesObjectsRequest) ([]ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionSourcesObjectsExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionSource
 */
func (a *ProtectionSourcesApiService) GetProtectionSourcesObjectsExecute(r ApiGetProtectionSourcesObjectsRequest) ([]ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.GetProtectionSourcesObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ObjectIds != nil {
		localVarQueryParams.Add("objectIds", parameterToString(*r.ObjectIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationServersRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	ProtectionSourcesRootNodeId *int64
	Environment *string
	ProtectionSourceId *int64
	Application *string
}

/*

func (r ApiListApplicationServersRequest) ProtectionSourcesRootNodeId(protectionSourcesRootNodeId int64) ApiListApplicationServersRequest {
	r.protectionSourcesRootNodeId = &protectionSourcesRootNodeId
	return r
}
func (r ApiListApplicationServersRequest) Environment(environment string) ApiListApplicationServersRequest {
	r.environment = &environment
	return r
}
func (r ApiListApplicationServersRequest) ProtectionSourceId(protectionSourceId int64) ApiListApplicationServersRequest {
	r.protectionSourceId = &protectionSourceId
	return r
}
func (r ApiListApplicationServersRequest) Application(application string) ApiListApplicationServersRequest {
	r.application = &application
	return r
}
*/

/*
func (r ApiListApplicationServersRequest) Execute() ([]RegisteredApplicationServer, *_nethttp.Response, error) {
	return r.ApiService.ListApplicationServersExecute(r)
}

 * ListApplicationServers Returns the registered Application Servers and their Object subtrees.
 * Given the root node id of a Protection Source tree, returns the list of
Application Servers registered under that tree based on the filters.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListApplicationServersRequest
 
func (a *ProtectionSourcesApiService) ListApplicationServers(ctx _context.Context) ApiListApplicationServersRequest {
	return ApiListApplicationServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListApplicationServers(r ApiListApplicationServersRequest) ([]RegisteredApplicationServer, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []RegisteredApplicationServer{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListApplicationServersExecute(r)
}


/*
 * Execute executes the request
 * @return []RegisteredApplicationServer
 */
func (a *ProtectionSourcesApiService) ListApplicationServersExecute(r ApiListApplicationServersRequest) ([]RegisteredApplicationServer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []RegisteredApplicationServer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListApplicationServers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/applicationServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ProtectionSourcesRootNodeId != nil {
		localVarQueryParams.Add("protectionSourcesRootNodeId", parameterToString(*r.ProtectionSourcesRootNodeId, ""))
	}
	if r.Environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.Environment, ""))
	}
	if r.ProtectionSourceId != nil {
		localVarQueryParams.Add("protectionSourceId", parameterToString(*r.ProtectionSourceId, ""))
	}
	if r.Application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.Application, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDataStoreInformationRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	SourceId *int64
}

/*

func (r ApiListDataStoreInformationRequest) SourceId(sourceId int64) ApiListDataStoreInformationRequest {
	r.sourceId = &sourceId
	return r
}
*/

/*
func (r ApiListDataStoreInformationRequest) Execute() ([]ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.ListDataStoreInformationExecute(r)
}

 * ListDataStoreInformation Returns the datastore information in VMware environment.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListDataStoreInformationRequest
 
func (a *ProtectionSourcesApiService) ListDataStoreInformation(ctx _context.Context) ApiListDataStoreInformationRequest {
	return ApiListDataStoreInformationRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListDataStoreInformation(r ApiListDataStoreInformationRequest) ([]ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListDataStoreInformationExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionSource
 */
func (a *ProtectionSourcesApiService) ListDataStoreInformationExecute(r ApiListDataStoreInformationRequest) ([]ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListDataStoreInformation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/datastores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.SourceId == nil {
		return localVarReturnValue, nil, reportError("SourceId is required and must be specified")
	}

	localVarQueryParams.Add("sourceId", parameterToString(*r.SourceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExchangeDagHostsRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Endpoint *string
	ProtectionSourceId *int64
}

/*

func (r ApiListExchangeDagHostsRequest) Endpoint(endpoint string) ApiListExchangeDagHostsRequest {
	r.endpoint = &endpoint
	return r
}
func (r ApiListExchangeDagHostsRequest) ProtectionSourceId(protectionSourceId int64) ApiListExchangeDagHostsRequest {
	r.protectionSourceId = &protectionSourceId
	return r
}
*/

/*
func (r ApiListExchangeDagHostsRequest) Execute() (ExchangeDagHostsResponse, *_nethttp.Response, error) {
	return r.ApiService.ListExchangeDagHostsExecute(r)
}

 * ListExchangeDagHosts Method for ListExchangeDagHosts
 * Returns information about all the exchange hosts that belong to an Exchange
DAG.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListExchangeDagHostsRequest
 
func (a *ProtectionSourcesApiService) ListExchangeDagHosts(ctx _context.Context) ApiListExchangeDagHostsRequest {
	return ApiListExchangeDagHostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListExchangeDagHosts(r ApiListExchangeDagHostsRequest) (ExchangeDagHostsResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ExchangeDagHostsResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListExchangeDagHostsExecute(r)
}


/*
 * Execute executes the request
 * @return ExchangeDagHostsResponse
 */
func (a *ProtectionSourcesApiService) ListExchangeDagHostsExecute(r ApiListExchangeDagHostsRequest) (ExchangeDagHostsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExchangeDagHostsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListExchangeDagHosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/exchangeDagHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Endpoint != nil {
		localVarQueryParams.Add("endpoint", parameterToString(*r.Endpoint, ""))
	}
	if r.ProtectionSourceId != nil {
		localVarQueryParams.Add("protectionSourceId", parameterToString(*r.ProtectionSourceId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProtectedObjectsRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Environment *string
	Id *int64
	AllUnderHierarchy *bool
	IncludeRpoSnapshots *bool
}

/*

func (r ApiListProtectedObjectsRequest) Environment(environment string) ApiListProtectedObjectsRequest {
	r.environment = &environment
	return r
}
func (r ApiListProtectedObjectsRequest) Id(id int64) ApiListProtectedObjectsRequest {
	r.id = &id
	return r
}
func (r ApiListProtectedObjectsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiListProtectedObjectsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
func (r ApiListProtectedObjectsRequest) IncludeRpoSnapshots(includeRpoSnapshots bool) ApiListProtectedObjectsRequest {
	r.includeRpoSnapshots = &includeRpoSnapshots
	return r
}
*/

/*
func (r ApiListProtectedObjectsRequest) Execute() ([]ProtectedVmInfo, *_nethttp.Response, error) {
	return r.ApiService.ListProtectedObjectsExecute(r)
}

 * ListProtectedObjects Returns the list of protected Objects in a registered Protection Source.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListProtectedObjectsRequest
 
func (a *ProtectionSourcesApiService) ListProtectedObjects(ctx _context.Context) ApiListProtectedObjectsRequest {
	return ApiListProtectedObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListProtectedObjects(r ApiListProtectedObjectsRequest) ([]ProtectedVmInfo, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectedVmInfo{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListProtectedObjectsExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectedVmInfo
 */
func (a *ProtectionSourcesApiService) ListProtectedObjectsExecute(r ApiListProtectedObjectsRequest) ([]ProtectedVmInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectedVmInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListProtectedObjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/protectedObjects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Environment == nil {
		return localVarReturnValue, nil, reportError("Environment is required and must be specified")
	}
	if r.Id == nil {
		return localVarReturnValue, nil, reportError("Id is required and must be specified")
	}

	localVarQueryParams.Add("environment", parameterToString(*r.Environment, ""))
	localVarQueryParams.Add("id", parameterToString(*r.Id, ""))
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	if r.IncludeRpoSnapshots != nil {
		localVarQueryParams.Add("includeRpoSnapshots", parameterToString(*r.IncludeRpoSnapshots, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProtectionSourcesRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	AfterCursorEntityId *int64
	BeforeCursorEntityId *int64
	NodeId *int64
	PageSize *int64
	Id *int64
	NumLevels *int32
	ExcludeTypes *[]string
	ExcludeOffice365Types *[]string
	ExcludeAwsTypes *[]string
	IncludeDatastores *bool
	IncludeNetworks *bool
	IncludeVMFolders *bool
	IncludeSystemVApps *bool
	Environments *[]string
	Environment *string
	IncludeEntityPermissionInfo *bool
	Sids *[]string
	TenantIds *[]string
	AllUnderHierarchy *bool
}

/*

func (r ApiListProtectionSourcesRequest) AfterCursorEntityId(afterCursorEntityId int64) ApiListProtectionSourcesRequest {
	r.afterCursorEntityId = &afterCursorEntityId
	return r
}
func (r ApiListProtectionSourcesRequest) BeforeCursorEntityId(beforeCursorEntityId int64) ApiListProtectionSourcesRequest {
	r.beforeCursorEntityId = &beforeCursorEntityId
	return r
}
func (r ApiListProtectionSourcesRequest) NodeId(nodeId int64) ApiListProtectionSourcesRequest {
	r.nodeId = &nodeId
	return r
}
func (r ApiListProtectionSourcesRequest) PageSize(pageSize int64) ApiListProtectionSourcesRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiListProtectionSourcesRequest) Id(id int64) ApiListProtectionSourcesRequest {
	r.id = &id
	return r
}
func (r ApiListProtectionSourcesRequest) NumLevels(numLevels int32) ApiListProtectionSourcesRequest {
	r.numLevels = &numLevels
	return r
}
func (r ApiListProtectionSourcesRequest) ExcludeTypes(excludeTypes []string) ApiListProtectionSourcesRequest {
	r.excludeTypes = &excludeTypes
	return r
}
func (r ApiListProtectionSourcesRequest) ExcludeOffice365Types(excludeOffice365Types []string) ApiListProtectionSourcesRequest {
	r.excludeOffice365Types = &excludeOffice365Types
	return r
}
func (r ApiListProtectionSourcesRequest) ExcludeAwsTypes(excludeAwsTypes []string) ApiListProtectionSourcesRequest {
	r.excludeAwsTypes = &excludeAwsTypes
	return r
}
func (r ApiListProtectionSourcesRequest) IncludeDatastores(includeDatastores bool) ApiListProtectionSourcesRequest {
	r.includeDatastores = &includeDatastores
	return r
}
func (r ApiListProtectionSourcesRequest) IncludeNetworks(includeNetworks bool) ApiListProtectionSourcesRequest {
	r.includeNetworks = &includeNetworks
	return r
}
func (r ApiListProtectionSourcesRequest) IncludeVMFolders(includeVMFolders bool) ApiListProtectionSourcesRequest {
	r.includeVMFolders = &includeVMFolders
	return r
}
func (r ApiListProtectionSourcesRequest) IncludeSystemVApps(includeSystemVApps bool) ApiListProtectionSourcesRequest {
	r.includeSystemVApps = &includeSystemVApps
	return r
}
func (r ApiListProtectionSourcesRequest) Environments(environments []string) ApiListProtectionSourcesRequest {
	r.environments = &environments
	return r
}
func (r ApiListProtectionSourcesRequest) Environment(environment string) ApiListProtectionSourcesRequest {
	r.environment = &environment
	return r
}
func (r ApiListProtectionSourcesRequest) IncludeEntityPermissionInfo(includeEntityPermissionInfo bool) ApiListProtectionSourcesRequest {
	r.includeEntityPermissionInfo = &includeEntityPermissionInfo
	return r
}
func (r ApiListProtectionSourcesRequest) Sids(sids []string) ApiListProtectionSourcesRequest {
	r.sids = &sids
	return r
}
func (r ApiListProtectionSourcesRequest) TenantIds(tenantIds []string) ApiListProtectionSourcesRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiListProtectionSourcesRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiListProtectionSourcesRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiListProtectionSourcesRequest) Execute() ([]ProtectionSourceNode, *_nethttp.Response, error) {
	return r.ApiService.ListProtectionSourcesExecute(r)
}

 * ListProtectionSources Returns the registered Protection Sources and their Object subtrees.
 * If no parameters are specified, all Protection Sources that are registered
on the Cohesity Cluster are returned.
In addition, an Object subtree gathered from each Source is returned.
For example, the Cohesity Cluster interrogates a Source VMware vCenter Server
and creates an hierarchical Object subtree that mirrors the
Inventory tree on vCenter Server.
The contents of the Object tree are returned as a "nodes" hierarchy
of "protectionSource"s.
Specifying parameters can alter the results that are returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListProtectionSourcesRequest
 
func (a *ProtectionSourcesApiService) ListProtectionSources(ctx _context.Context) ApiListProtectionSourcesRequest {
	return ApiListProtectionSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListProtectionSources(r ApiListProtectionSourcesRequest) ([]ProtectionSourceNode, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionSourceNode{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListProtectionSourcesExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionSourceNode
 */
func (a *ProtectionSourcesApiService) ListProtectionSourcesExecute(r ApiListProtectionSourcesRequest) ([]ProtectionSourceNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionSourceNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListProtectionSources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.AfterCursorEntityId != nil {
		localVarQueryParams.Add("afterCursorEntityId", parameterToString(*r.AfterCursorEntityId, ""))
	}
	if r.BeforeCursorEntityId != nil {
		localVarQueryParams.Add("beforeCursorEntityId", parameterToString(*r.BeforeCursorEntityId, ""))
	}
	if r.NodeId != nil {
		localVarQueryParams.Add("nodeId", parameterToString(*r.NodeId, ""))
	}
	if r.PageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.PageSize, ""))
	}
	if r.Id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.Id, ""))
	}
	if r.NumLevels != nil {
		localVarQueryParams.Add("numLevels", parameterToString(*r.NumLevels, ""))
	}
	if r.ExcludeTypes != nil {
		localVarQueryParams.Add("excludeTypes", parameterToString(*r.ExcludeTypes, "csv"))
	}
	if r.ExcludeOffice365Types != nil {
		localVarQueryParams.Add("excludeOffice365Types", parameterToString(*r.ExcludeOffice365Types, "csv"))
	}
	if r.ExcludeAwsTypes != nil {
		localVarQueryParams.Add("excludeAwsTypes", parameterToString(*r.ExcludeAwsTypes, "csv"))
	}
	if r.IncludeDatastores != nil {
		localVarQueryParams.Add("includeDatastores", parameterToString(*r.IncludeDatastores, ""))
	}
	if r.IncludeNetworks != nil {
		localVarQueryParams.Add("includeNetworks", parameterToString(*r.IncludeNetworks, ""))
	}
	if r.IncludeVMFolders != nil {
		localVarQueryParams.Add("includeVMFolders", parameterToString(*r.IncludeVMFolders, ""))
	}
	if r.IncludeSystemVApps != nil {
		localVarQueryParams.Add("includeSystemVApps", parameterToString(*r.IncludeSystemVApps, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.Environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.Environment, ""))
	}
	if r.IncludeEntityPermissionInfo != nil {
		localVarQueryParams.Add("includeEntityPermissionInfo", parameterToString(*r.IncludeEntityPermissionInfo, ""))
	}
	if r.Sids != nil {
		localVarQueryParams.Add("sids", parameterToString(*r.Sids, "csv"))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProtectionSourcesRegistrationInfoRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Environments *[]string
	Ids *[]int64
	IncludeEntityPermissionInfo *bool
	Sids *[]string
	IncludeApplicationsTreeInfo *bool
	TenantIds *[]string
	AllUnderHierarchy *bool
}

/*

func (r ApiListProtectionSourcesRegistrationInfoRequest) Environments(environments []string) ApiListProtectionSourcesRegistrationInfoRequest {
	r.environments = &environments
	return r
}
func (r ApiListProtectionSourcesRegistrationInfoRequest) Ids(ids []int64) ApiListProtectionSourcesRegistrationInfoRequest {
	r.ids = &ids
	return r
}
func (r ApiListProtectionSourcesRegistrationInfoRequest) IncludeEntityPermissionInfo(includeEntityPermissionInfo bool) ApiListProtectionSourcesRegistrationInfoRequest {
	r.includeEntityPermissionInfo = &includeEntityPermissionInfo
	return r
}
func (r ApiListProtectionSourcesRegistrationInfoRequest) Sids(sids []string) ApiListProtectionSourcesRegistrationInfoRequest {
	r.sids = &sids
	return r
}
func (r ApiListProtectionSourcesRegistrationInfoRequest) IncludeApplicationsTreeInfo(includeApplicationsTreeInfo bool) ApiListProtectionSourcesRegistrationInfoRequest {
	r.includeApplicationsTreeInfo = &includeApplicationsTreeInfo
	return r
}
func (r ApiListProtectionSourcesRegistrationInfoRequest) TenantIds(tenantIds []string) ApiListProtectionSourcesRegistrationInfoRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiListProtectionSourcesRegistrationInfoRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiListProtectionSourcesRegistrationInfoRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiListProtectionSourcesRegistrationInfoRequest) Execute() (GetRegistrationInfoResponse, *_nethttp.Response, error) {
	return r.ApiService.ListProtectionSourcesRegistrationInfoExecute(r)
}

 * ListProtectionSourcesRegistrationInfo Method for ListProtectionSourcesRegistrationInfo
 * Returns the registration and protection information of the registered
Protection Sources.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListProtectionSourcesRegistrationInfoRequest
 
func (a *ProtectionSourcesApiService) ListProtectionSourcesRegistrationInfo(ctx _context.Context) ApiListProtectionSourcesRegistrationInfoRequest {
	return ApiListProtectionSourcesRegistrationInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListProtectionSourcesRegistrationInfo(r ApiListProtectionSourcesRegistrationInfoRequest) (GetRegistrationInfoResponse, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return GetRegistrationInfoResponse{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListProtectionSourcesRegistrationInfoExecute(r)
}


/*
 * Execute executes the request
 * @return GetRegistrationInfoResponse
 */
func (a *ProtectionSourcesApiService) ListProtectionSourcesRegistrationInfoExecute(r ApiListProtectionSourcesRegistrationInfoRequest) (GetRegistrationInfoResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetRegistrationInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListProtectionSourcesRegistrationInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/registrationInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.Ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.Ids, "csv"))
	}
	if r.IncludeEntityPermissionInfo != nil {
		localVarQueryParams.Add("includeEntityPermissionInfo", parameterToString(*r.IncludeEntityPermissionInfo, ""))
	}
	if r.Sids != nil {
		localVarQueryParams.Add("sids", parameterToString(*r.Sids, "csv"))
	}
	if r.IncludeApplicationsTreeInfo != nil {
		localVarQueryParams.Add("includeApplicationsTreeInfo", parameterToString(*r.IncludeApplicationsTreeInfo, ""))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListProtectionSourcesRootNodesRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Id *int64
	Environments *[]string
	Environment *string
}

/*

func (r ApiListProtectionSourcesRootNodesRequest) Id(id int64) ApiListProtectionSourcesRootNodesRequest {
	r.id = &id
	return r
}
func (r ApiListProtectionSourcesRootNodesRequest) Environments(environments []string) ApiListProtectionSourcesRootNodesRequest {
	r.environments = &environments
	return r
}
func (r ApiListProtectionSourcesRootNodesRequest) Environment(environment string) ApiListProtectionSourcesRootNodesRequest {
	r.environment = &environment
	return r
}
*/

/*
func (r ApiListProtectionSourcesRootNodesRequest) Execute() ([]ProtectionSourceNode, *_nethttp.Response, error) {
	return r.ApiService.ListProtectionSourcesRootNodesExecute(r)
}

 * ListProtectionSourcesRootNodes Returns the top level (root) Protection Sources with registration information.
 * Returns the root Protection Sources and the registration information for
each of these Sources.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListProtectionSourcesRootNodesRequest
 
func (a *ProtectionSourcesApiService) ListProtectionSourcesRootNodes(ctx _context.Context) ApiListProtectionSourcesRootNodesRequest {
	return ApiListProtectionSourcesRootNodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListProtectionSourcesRootNodes(r ApiListProtectionSourcesRootNodesRequest) ([]ProtectionSourceNode, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionSourceNode{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListProtectionSourcesRootNodesExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionSourceNode
 */
func (a *ProtectionSourcesApiService) ListProtectionSourcesRootNodesExecute(r ApiListProtectionSourcesRootNodesRequest) ([]ProtectionSourceNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionSourceNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListProtectionSourcesRootNodes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/rootNodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.Id, ""))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.Environment != nil {
		localVarQueryParams.Add("environment", parameterToString(*r.Environment, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSqlAagHostsAndDatabasesRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	SqlProtectionSourceIds *[]int64
}

/*

func (r ApiListSqlAagHostsAndDatabasesRequest) SqlProtectionSourceIds(sqlProtectionSourceIds []int64) ApiListSqlAagHostsAndDatabasesRequest {
	r.sqlProtectionSourceIds = &sqlProtectionSourceIds
	return r
}
*/

/*
func (r ApiListSqlAagHostsAndDatabasesRequest) Execute() ([]SqlAagHostAndDatabases, *_nethttp.Response, error) {
	return r.ApiService.ListSqlAagHostsAndDatabasesExecute(r)
}

 * ListSqlAagHostsAndDatabases Returns the registered Protection Sources and their Object subtrees.
 * Given a list of Protection Source Ids registered as SQL servers, returns
AAGs found and the databases in AAG(Always on Availablity Group).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListSqlAagHostsAndDatabasesRequest
 
func (a *ProtectionSourcesApiService) ListSqlAagHostsAndDatabases(ctx _context.Context) ApiListSqlAagHostsAndDatabasesRequest {
	return ApiListSqlAagHostsAndDatabasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListSqlAagHostsAndDatabases(r ApiListSqlAagHostsAndDatabasesRequest) ([]SqlAagHostAndDatabases, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []SqlAagHostAndDatabases{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListSqlAagHostsAndDatabasesExecute(r)
}


/*
 * Execute executes the request
 * @return []SqlAagHostAndDatabases
 */
func (a *ProtectionSourcesApiService) ListSqlAagHostsAndDatabasesExecute(r ApiListSqlAagHostsAndDatabasesRequest) ([]SqlAagHostAndDatabases, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []SqlAagHostAndDatabases
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListSqlAagHostsAndDatabases")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/sqlAagHostsAndDatabases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.SqlProtectionSourceIds == nil {
		return localVarReturnValue, nil, reportError("SqlProtectionSourceIds is required and must be specified")
	}

	localVarQueryParams.Add("sqlProtectionSourceIds", parameterToString(*r.SqlProtectionSourceIds, "csv"))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVirtualMachinesRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	VCenterId *int64
	Names *[]string
	Uuids *[]string
	Protected *bool
}

/*

func (r ApiListVirtualMachinesRequest) VCenterId(vCenterId int64) ApiListVirtualMachinesRequest {
	r.vCenterId = &vCenterId
	return r
}
func (r ApiListVirtualMachinesRequest) Names(names []string) ApiListVirtualMachinesRequest {
	r.names = &names
	return r
}
func (r ApiListVirtualMachinesRequest) Uuids(uuids []string) ApiListVirtualMachinesRequest {
	r.uuids = &uuids
	return r
}
func (r ApiListVirtualMachinesRequest) Protected(protected bool) ApiListVirtualMachinesRequest {
	r.protected = &protected
	return r
}
*/

/*
func (r ApiListVirtualMachinesRequest) Execute() ([]ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.ListVirtualMachinesExecute(r)
}

 * ListVirtualMachines Returns the Virtual Machines in a vCenter Server.
 * Returns all Virtual Machines found in all the vCenter Servers registered
on the Cohesity Cluster that match the filter criteria specified using
parameters.
If an id is specified, only VMs found in the specified vCenter Server
are returned.
Only VM Objects are returned.
Other VMware Objects such as datacenters are not returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListVirtualMachinesRequest
 
func (a *ProtectionSourcesApiService) ListVirtualMachines(ctx _context.Context) ApiListVirtualMachinesRequest {
	return ApiListVirtualMachinesRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) ListVirtualMachines(r ApiListVirtualMachinesRequest) ([]ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ListVirtualMachinesExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionSource
 */
func (a *ProtectionSourcesApiService) ListVirtualMachinesExecute(r ApiListVirtualMachinesRequest) ([]ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.ListVirtualMachines")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/virtualMachines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.VCenterId != nil {
		localVarQueryParams.Add("vCenterId", parameterToString(*r.VCenterId, ""))
	}
	if r.Names != nil {
		localVarQueryParams.Add("names", parameterToString(*r.Names, "csv"))
	}
	if r.Uuids != nil {
		localVarQueryParams.Add("uuids", parameterToString(*r.Uuids, "csv"))
	}
	if r.Protected != nil {
		localVarQueryParams.Add("protected", parameterToString(*r.Protected, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefreshProtectionSourceByIdRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Id int64
}

/*

*/

/*
func (r ApiRefreshProtectionSourceByIdRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RefreshProtectionSourceByIdExecute(r)
}

 * RefreshProtectionSourceById Refresh the Object hierarchy of the Protection Sources tree.
 * Force an immediate refresh between the specified Protection Source tree
on the Cohesity Cluster and the Inventory tree
in the associated vCenter Server.

For example if a new VM is added to the vCenter Server, after a refresh,
a new Protection Source node for this VM is added to the Protection Sources
tree.

Success indicates the forced refresh has been completed. For larger sources it
is possible for the operation to timeout before the force refresh has been
completed. This timeout can be increased by modifying the
'iris_post_timeout_msecs_to_magneto' gflag on the Iris service.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the root node of the Protection Sources tree to refresh.  Force a refresh of the Object hierarchy for the passed in Protection Sources Id.
 * @return ApiRefreshProtectionSourceByIdRequest
 
func (a *ProtectionSourcesApiService) RefreshProtectionSourceById(ctx _context.Context, id int64) ApiRefreshProtectionSourceByIdRequest {
	return ApiRefreshProtectionSourceByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionSourcesApiService) RefreshProtectionSourceById(r ApiRefreshProtectionSourceByIdRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.RefreshProtectionSourceByIdExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ProtectionSourcesApiService) RefreshProtectionSourceByIdExecute(r ApiRefreshProtectionSourceByIdRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.RefreshProtectionSourceById")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/refresh/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRegisterApplicationServersRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Body *RegisterApplicationServersParameters
}

/*

func (r ApiRegisterApplicationServersRequest) Body(body RegisterApplicationServersParameters) ApiRegisterApplicationServersRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiRegisterApplicationServersRequest) Execute() (ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.RegisterApplicationServersExecute(r)
}

 * RegisterApplicationServers Register a Protection Source as running one or more Application Servers like Microsoft SQL servers or Microsoft Exchange servers.
 * Registering Application Servers will help Cohesity Cluster such that any
application specific data can be backed up.

Returns the Protection Source registered upon success.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRegisterApplicationServersRequest
 
func (a *ProtectionSourcesApiService) RegisterApplicationServers(ctx _context.Context) ApiRegisterApplicationServersRequest {
	return ApiRegisterApplicationServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) RegisterApplicationServers(r ApiRegisterApplicationServersRequest) (ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.RegisterApplicationServersExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSource
 */
func (a *ProtectionSourcesApiService) RegisterApplicationServersExecute(r ApiRegisterApplicationServersRequest) (ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.RegisterApplicationServers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/applicationServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterProtectionSourceRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Body *RegisterProtectionSourceParameters
}

/*

func (r ApiRegisterProtectionSourceRequest) Body(body RegisterProtectionSourceParameters) ApiRegisterProtectionSourceRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiRegisterProtectionSourceRequest) Execute() (ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.RegisterProtectionSourceExecute(r)
}

 * RegisterProtectionSource Register a Protection Source.
 * Register a Protection Source on the Cohesity Cluster.
It could be the root node of a vCenter Server or a physical server.

Returns the newly registered Protection Source upon success.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiRegisterProtectionSourceRequest
 
func (a *ProtectionSourcesApiService) RegisterProtectionSource(ctx _context.Context) ApiRegisterProtectionSourceRequest {
	return ApiRegisterProtectionSourceRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) RegisterProtectionSource(r ApiRegisterProtectionSourceRequest) (ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.RegisterProtectionSourceExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSource
 */
func (a *ProtectionSourcesApiService) RegisterProtectionSourceExecute(r ApiRegisterProtectionSourceRequest) (ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.RegisterProtectionSource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunDiagnosticsRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Id int64
}

/*

*/

/*
func (r ApiRunDiagnosticsRequest) Execute() (RunDiagnosticsMessage, *_nethttp.Response, error) {
	return r.ApiService.RunDiagnosticsExecute(r)
}

 * RunDiagnostics Collect diagnostics of the protection source for a host type.
 * If the request is successful, the diagnostics script is triggered on Cohesity
agent which generates a tarball containing various diagnostics and uploads it
to the Cohesity cluster. Host type could be Linux, Windows.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies the entity id.
 * @return ApiRunDiagnosticsRequest
 
func (a *ProtectionSourcesApiService) RunDiagnostics(ctx _context.Context, id int64) ApiRunDiagnosticsRequest {
	return ApiRunDiagnosticsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionSourcesApiService) RunDiagnostics(r ApiRunDiagnosticsRequest) (RunDiagnosticsMessage, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RunDiagnosticsMessage{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.RunDiagnosticsExecute(r)
}


/*
 * Execute executes the request
 * @return RunDiagnosticsMessage
 */
func (a *ProtectionSourcesApiService) RunDiagnosticsExecute(r ApiRunDiagnosticsRequest) (RunDiagnosticsMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RunDiagnosticsMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.RunDiagnostics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/diagnostics/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnregisterApplicationServersRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Id int64
	Body *UnRegisterApplicationServersParameters
}

/*

func (r ApiUnregisterApplicationServersRequest) Body(body UnRegisterApplicationServersParameters) ApiUnregisterApplicationServersRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUnregisterApplicationServersRequest) Execute() (ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.UnregisterApplicationServersExecute(r)
}

 * UnregisterApplicationServers Unregister Application Servers like Microsoft SQL servers or Microsoft Exchange servers running on a Protection Source.
 * Unregistering Application Servers will fail if the Protection Source is
currently being backed up.

Returns the Protection Source whose Application Servers are unregistered upon
success.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Source to unregister the Application Servers. If the Protection Source is currently being backed up, unregister operation will fail.
 * @return ApiUnregisterApplicationServersRequest
 
func (a *ProtectionSourcesApiService) UnregisterApplicationServers(ctx _context.Context, id int64) ApiUnregisterApplicationServersRequest {
	return ApiUnregisterApplicationServersRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionSourcesApiService) UnregisterApplicationServers(r ApiUnregisterApplicationServersRequest) (ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UnregisterApplicationServersExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSource
 */
func (a *ProtectionSourcesApiService) UnregisterApplicationServersExecute(r ApiUnregisterApplicationServersRequest) (ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.UnregisterApplicationServers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/applicationServers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnregisterProtectionSourceRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Id int64
}

/*

*/

/*
func (r ApiUnregisterProtectionSourceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnregisterProtectionSourceExecute(r)
}

 * UnregisterProtectionSource Unregister a previously registered Protection Source.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Source to unregister. If the Protection Source is currently being backed up, unregister operation will fail.
 * @return ApiUnregisterProtectionSourceRequest
 
func (a *ProtectionSourcesApiService) UnregisterProtectionSource(ctx _context.Context, id int64) ApiUnregisterProtectionSourceRequest {
	return ApiUnregisterProtectionSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionSourcesApiService) UnregisterProtectionSource(r ApiUnregisterProtectionSourceRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UnregisterProtectionSourceExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ProtectionSourcesApiService) UnregisterProtectionSourceExecute(r ApiUnregisterProtectionSourceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.UnregisterProtectionSource")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateApplicationServersRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Body *UpdateApplicationServerParameters
}

/*

func (r ApiUpdateApplicationServersRequest) Body(body UpdateApplicationServerParameters) ApiUpdateApplicationServersRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateApplicationServersRequest) Execute() (ProtectionSource, *_nethttp.Response, error) {
	return r.ApiService.UpdateApplicationServersExecute(r)
}

 * UpdateApplicationServers Modifies the registration parameters of Application Servers in a Protection Source.
 * Returns the Protection Source whose registration parameters of its
Application Servers are modified upon success.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateApplicationServersRequest
 
func (a *ProtectionSourcesApiService) UpdateApplicationServers(ctx _context.Context) ApiUpdateApplicationServersRequest {
	return ApiUpdateApplicationServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) UpdateApplicationServers(r ApiUpdateApplicationServersRequest) (ProtectionSource, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSource{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateApplicationServersExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSource
 */
func (a *ProtectionSourcesApiService) UpdateApplicationServersExecute(r ApiUpdateApplicationServersRequest) (ProtectionSource, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSource
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.UpdateApplicationServers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/applicationServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProtectionSourceRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Id int64
	Body *UpdateProtectionSourceParameters
}

/*

func (r ApiUpdateProtectionSourceRequest) Body(body UpdateProtectionSourceParameters) ApiUpdateProtectionSourceRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateProtectionSourceRequest) Execute() (ProtectionSourceNode, *_nethttp.Response, error) {
	return r.ApiService.UpdateProtectionSourceExecute(r)
}

 * UpdateProtectionSource Update a previously registered Protection Source with new details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Source to update.
 * @return ApiUpdateProtectionSourceRequest
 
func (a *ProtectionSourcesApiService) UpdateProtectionSource(ctx _context.Context, id int64) ApiUpdateProtectionSourceRequest {
	return ApiUpdateProtectionSourceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionSourcesApiService) UpdateProtectionSource(r ApiUpdateProtectionSourceRequest) (ProtectionSourceNode, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionSourceNode{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateProtectionSourceExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionSourceNode
 */
func (a *ProtectionSourcesApiService) UpdateProtectionSourceExecute(r ApiUpdateProtectionSourceRequest) (ProtectionSourceNode, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionSourceNode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.UpdateProtectionSource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionSources/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpgradePhysicalAgentsRequest struct {
	ctx _context.Context
	ApiService *ProtectionSourcesApiService
	Body *UpgradePhysicalServerAgents
}

/*

func (r ApiUpgradePhysicalAgentsRequest) Body(body UpgradePhysicalServerAgents) ApiUpgradePhysicalAgentsRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpgradePhysicalAgentsRequest) Execute() (UpgradePhysicalAgentsMessage, *_nethttp.Response, error) {
	return r.ApiService.UpgradePhysicalAgentsExecute(r)
}

 * UpgradePhysicalAgents Initiate a request to upgrade Cohesity agents on one or more Physical Servers registered on the Cohesity Cluster.
 * If the request is successful, the Cohesity agents on the specified
Physical Servers are upgraded to the agent release
currently available from this Cohesity Cluster.
For example if the Cluster is upgraded from 3.7.1 to 4.0,
the agents on the specified Physical Servers can be upgraded to 4.0 using
this POST operation.
To get the agentIds to pass into this operation, call
GET /public/protectionSources with the environment set to 'KPhysical'.
In addition this GET operation returns the agentUpgradability field, that
indicates if an agent can be upgraded. Use the agentUpgradability field
to determine which Physical Servers to upgrade using this
POST /public/physicalAgents/upgrade operation.

WARNING: Only agents at a particular Cohesity release can be
upgraded using this operation.
See the Cohesity online help for details.

Returns the status of the upgrade initiation.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpgradePhysicalAgentsRequest
 
func (a *ProtectionSourcesApiService) UpgradePhysicalAgents(ctx _context.Context) ApiUpgradePhysicalAgentsRequest {
	return ApiUpgradePhysicalAgentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionSourcesApiService) UpgradePhysicalAgents(r ApiUpgradePhysicalAgentsRequest) (UpgradePhysicalAgentsMessage, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return UpgradePhysicalAgentsMessage{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpgradePhysicalAgentsExecute(r)
}


/*
 * Execute executes the request
 * @return UpgradePhysicalAgentsMessage
 */
func (a *ProtectionSourcesApiService) UpgradePhysicalAgentsExecute(r ApiUpgradePhysicalAgentsRequest) (UpgradePhysicalAgentsMessage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpgradePhysicalAgentsMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionSourcesApiService.UpgradePhysicalAgents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/physicalAgents/upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
