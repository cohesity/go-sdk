/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ProtectionJobsApiService ProtectionJobsApi service
type ProtectionJobsApiService service

type ApiChangeProtectionJobStateRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Id int64
	Body *ChangeProtectionJobStateParam
}

/*

func (r ApiChangeProtectionJobStateRequest) Body(body ChangeProtectionJobStateParam) ApiChangeProtectionJobStateRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiChangeProtectionJobStateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChangeProtectionJobStateExecute(r)
}

 * ChangeProtectionJobState Pause future Runs or resume future Runs of the specified Protection Job.
 * If the Protection Job is currently running (not paused) and true is passed in,
this operation stops any new Runs of this Protection Job
from stating and executing.
However, any existing Runs that were already executing will continue to run.
If this Projection Job is paused and false is passed in, this operation
restores the Job to a running state and new Runs are started as defined
by the schedule in the Policy associated with the Job.

Returns success if the paused state is changed.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Job.
 * @return ApiChangeProtectionJobStateRequest
 
func (a *ProtectionJobsApiService) ChangeProtectionJobState(ctx _context.Context, id int64) ApiChangeProtectionJobStateRequest {
	return ApiChangeProtectionJobStateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionJobsApiService) ChangeProtectionJobState(r ApiChangeProtectionJobStateRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.ChangeProtectionJobStateExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ProtectionJobsApiService) ChangeProtectionJobStateExecute(r ApiChangeProtectionJobStateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.ChangeProtectionJobState")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobState/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateProtectionJobRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Body *ProtectionJobRequestBody
}

/*

func (r ApiCreateProtectionJobRequest) Body(body ProtectionJobRequestBody) ApiCreateProtectionJobRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCreateProtectionJobRequest) Execute() (ProtectionJob, *_nethttp.Response, error) {
	return r.ApiService.CreateProtectionJobExecute(r)
}

 * CreateProtectionJob Create a Protection Job.
 * Returns the created Protection Job.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateProtectionJobRequest
 
func (a *ProtectionJobsApiService) CreateProtectionJob(ctx _context.Context) ApiCreateProtectionJobRequest {
	return ApiCreateProtectionJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionJobsApiService) CreateProtectionJob(r ApiCreateProtectionJobRequest) (ProtectionJob, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionJob{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CreateProtectionJobExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionJob
 */
func (a *ProtectionJobsApiService) CreateProtectionJobExecute(r ApiCreateProtectionJobRequest) (ProtectionJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.CreateProtectionJob")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProtectionJobRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Id int64
	Body *DeleteProtectionJobParam
}

/*

func (r ApiDeleteProtectionJobRequest) Body(body DeleteProtectionJobParam) ApiDeleteProtectionJobRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiDeleteProtectionJobRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteProtectionJobExecute(r)
}

 * DeleteProtectionJob Delete a Protection Job.
 * Returns Success if the Protection Job is deleted.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Job.
 * @return ApiDeleteProtectionJobRequest
 
func (a *ProtectionJobsApiService) DeleteProtectionJob(ctx _context.Context, id int64) ApiDeleteProtectionJobRequest {
	return ApiDeleteProtectionJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionJobsApiService) DeleteProtectionJob(r ApiDeleteProtectionJobRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.DeleteProtectionJobExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ProtectionJobsApiService) DeleteProtectionJobExecute(r ApiDeleteProtectionJobRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.DeleteProtectionJob")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetProtectionJobAuditRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Id int64
}

/*

*/

/*
func (r ApiGetProtectionJobAuditRequest) Execute() ([]ProtectionJobAuditTrail, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionJobAuditExecute(r)
}

 * GetProtectionJobAudit List a protection job audit.
 * Returns the audit of specific protection job edit history.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Job.
 * @return ApiGetProtectionJobAuditRequest
 
func (a *ProtectionJobsApiService) GetProtectionJobAudit(ctx _context.Context, id int64) ApiGetProtectionJobAuditRequest {
	return ApiGetProtectionJobAuditRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionJobsApiService) GetProtectionJobAudit(r ApiGetProtectionJobAuditRequest) ([]ProtectionJobAuditTrail, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionJobAuditTrail{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionJobAuditExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionJobAuditTrail
 */
func (a *ProtectionJobsApiService) GetProtectionJobAuditExecute(r ApiGetProtectionJobAuditRequest) ([]ProtectionJobAuditTrail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionJobAuditTrail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.GetProtectionJobAudit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs/{id}/auditTrail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionJobByIdRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Id int64
}

/*

*/

/*
func (r ApiGetProtectionJobByIdRequest) Execute() (ProtectionJob, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionJobByIdExecute(r)
}

 * GetProtectionJobById List details about single Protection Job.
 * Returns the Protection Job corresponding to the specified Job id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Job.
 * @return ApiGetProtectionJobByIdRequest
 
func (a *ProtectionJobsApiService) GetProtectionJobById(ctx _context.Context, id int64) ApiGetProtectionJobByIdRequest {
	return ApiGetProtectionJobByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionJobsApiService) GetProtectionJobById(r ApiGetProtectionJobByIdRequest) (ProtectionJob, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionJob{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionJobByIdExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionJob
 */
func (a *ProtectionJobsApiService) GetProtectionJobByIdExecute(r ApiGetProtectionJobByIdRequest) (ProtectionJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.GetProtectionJobById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionJobsRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Ids *[]int64
	Names *[]string
	PolicyIds *[]string
	Environments *[]string
	IsActive *bool
	IsDeleted *bool
	OnlyReturnBasicSummary *bool
	IncludeLastRunAndStats *bool
	IncludeRpoSnapshots *bool
	IsLastRunSlaViolated *bool
	OnlyReturnDataMigrationJobs *bool
	PruneExcludedSourceIds *bool
	TenantIds *[]string
	AllUnderHierarchy *bool
}

/*

func (r ApiGetProtectionJobsRequest) Ids(ids []int64) ApiGetProtectionJobsRequest {
	r.ids = &ids
	return r
}
func (r ApiGetProtectionJobsRequest) Names(names []string) ApiGetProtectionJobsRequest {
	r.names = &names
	return r
}
func (r ApiGetProtectionJobsRequest) PolicyIds(policyIds []string) ApiGetProtectionJobsRequest {
	r.policyIds = &policyIds
	return r
}
func (r ApiGetProtectionJobsRequest) Environments(environments []string) ApiGetProtectionJobsRequest {
	r.environments = &environments
	return r
}
func (r ApiGetProtectionJobsRequest) IsActive(isActive bool) ApiGetProtectionJobsRequest {
	r.isActive = &isActive
	return r
}
func (r ApiGetProtectionJobsRequest) IsDeleted(isDeleted bool) ApiGetProtectionJobsRequest {
	r.isDeleted = &isDeleted
	return r
}
func (r ApiGetProtectionJobsRequest) OnlyReturnBasicSummary(onlyReturnBasicSummary bool) ApiGetProtectionJobsRequest {
	r.onlyReturnBasicSummary = &onlyReturnBasicSummary
	return r
}
func (r ApiGetProtectionJobsRequest) IncludeLastRunAndStats(includeLastRunAndStats bool) ApiGetProtectionJobsRequest {
	r.includeLastRunAndStats = &includeLastRunAndStats
	return r
}
func (r ApiGetProtectionJobsRequest) IncludeRpoSnapshots(includeRpoSnapshots bool) ApiGetProtectionJobsRequest {
	r.includeRpoSnapshots = &includeRpoSnapshots
	return r
}
func (r ApiGetProtectionJobsRequest) IsLastRunSlaViolated(isLastRunSlaViolated bool) ApiGetProtectionJobsRequest {
	r.isLastRunSlaViolated = &isLastRunSlaViolated
	return r
}
func (r ApiGetProtectionJobsRequest) OnlyReturnDataMigrationJobs(onlyReturnDataMigrationJobs bool) ApiGetProtectionJobsRequest {
	r.onlyReturnDataMigrationJobs = &onlyReturnDataMigrationJobs
	return r
}
func (r ApiGetProtectionJobsRequest) PruneExcludedSourceIds(pruneExcludedSourceIds bool) ApiGetProtectionJobsRequest {
	r.pruneExcludedSourceIds = &pruneExcludedSourceIds
	return r
}
func (r ApiGetProtectionJobsRequest) TenantIds(tenantIds []string) ApiGetProtectionJobsRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetProtectionJobsRequest) AllUnderHierarchy(allUnderHierarchy bool) ApiGetProtectionJobsRequest {
	r.allUnderHierarchy = &allUnderHierarchy
	return r
}
*/

/*
func (r ApiGetProtectionJobsRequest) Execute() ([]ProtectionJob, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionJobsExecute(r)
}

 * GetProtectionJobs List Protections Jobs filtered by the specified parameters.
 * If no parameters are specified, all Protection Jobs currently
on the Cohesity Cluster are returned.
Specifying parameters filters the results that are returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectionJobsRequest
 
func (a *ProtectionJobsApiService) GetProtectionJobs(ctx _context.Context) ApiGetProtectionJobsRequest {
	return ApiGetProtectionJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionJobsApiService) GetProtectionJobs(r ApiGetProtectionJobsRequest) ([]ProtectionJob, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionJob{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionJobsExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionJob
 */
func (a *ProtectionJobsApiService) GetProtectionJobsExecute(r ApiGetProtectionJobsRequest) ([]ProtectionJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.GetProtectionJobs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.Ids, "csv"))
	}
	if r.Names != nil {
		localVarQueryParams.Add("names", parameterToString(*r.Names, "csv"))
	}
	if r.PolicyIds != nil {
		localVarQueryParams.Add("policyIds", parameterToString(*r.PolicyIds, "csv"))
	}
	if r.Environments != nil {
		localVarQueryParams.Add("environments", parameterToString(*r.Environments, "csv"))
	}
	if r.IsActive != nil {
		localVarQueryParams.Add("isActive", parameterToString(*r.IsActive, ""))
	}
	if r.IsDeleted != nil {
		localVarQueryParams.Add("isDeleted", parameterToString(*r.IsDeleted, ""))
	}
	if r.OnlyReturnBasicSummary != nil {
		localVarQueryParams.Add("onlyReturnBasicSummary", parameterToString(*r.OnlyReturnBasicSummary, ""))
	}
	if r.IncludeLastRunAndStats != nil {
		localVarQueryParams.Add("includeLastRunAndStats", parameterToString(*r.IncludeLastRunAndStats, ""))
	}
	if r.IncludeRpoSnapshots != nil {
		localVarQueryParams.Add("includeRpoSnapshots", parameterToString(*r.IncludeRpoSnapshots, ""))
	}
	if r.IsLastRunSlaViolated != nil {
		localVarQueryParams.Add("isLastRunSlaViolated", parameterToString(*r.IsLastRunSlaViolated, ""))
	}
	if r.OnlyReturnDataMigrationJobs != nil {
		localVarQueryParams.Add("onlyReturnDataMigrationJobs", parameterToString(*r.OnlyReturnDataMigrationJobs, ""))
	}
	if r.PruneExcludedSourceIds != nil {
		localVarQueryParams.Add("pruneExcludedSourceIds", parameterToString(*r.PruneExcludedSourceIds, ""))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.AllUnderHierarchy != nil {
		localVarQueryParams.Add("allUnderHierarchy", parameterToString(*r.AllUnderHierarchy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunProtectionJobRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Id int64
	Body *RunProtectionJobParam
}

/*

func (r ApiRunProtectionJobRequest) Body(body RunProtectionJobParam) ApiRunProtectionJobRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiRunProtectionJobRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RunProtectionJobExecute(r)
}

 * RunProtectionJob Immediately execute a single Protection Job Run.
 * Immediately execute a single Job Run and ignore the schedule defined
in the Policy.
A Protection Policy associated with the Job may define up to three
backup run types:
1) Regular (CBT utilized), 2) Full (CBT not utilized) and 3) Log.
The passed in run type defines what type of backup is done by the Job Run.
The schedule defined in the Policy for the backup run type is ignored but
other settings such as the snapshot retention and retry settings are used.
Returns success if the Job Run starts.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Job.
 * @return ApiRunProtectionJobRequest
 
func (a *ProtectionJobsApiService) RunProtectionJob(ctx _context.Context, id int64) ApiRunProtectionJobRequest {
	return ApiRunProtectionJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionJobsApiService) RunProtectionJob(r ApiRunProtectionJobRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.RunProtectionJobExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ProtectionJobsApiService) RunProtectionJobExecute(r ApiRunProtectionJobRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.RunProtectionJob")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs/run/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateProtectionJobRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Id int64
	Body *ProtectionJobRequestBody
}

/*

func (r ApiUpdateProtectionJobRequest) Body(body ProtectionJobRequestBody) ApiUpdateProtectionJobRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateProtectionJobRequest) Execute() (ProtectionJob, *_nethttp.Response, error) {
	return r.ApiService.UpdateProtectionJobExecute(r)
}

 * UpdateProtectionJob Update a Protection Job.
 * Returns the updated Protection Job.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Job.
 * @return ApiUpdateProtectionJobRequest
 
func (a *ProtectionJobsApiService) UpdateProtectionJob(ctx _context.Context, id int64) ApiUpdateProtectionJobRequest {
	return ApiUpdateProtectionJobRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionJobsApiService) UpdateProtectionJob(r ApiUpdateProtectionJobRequest) (ProtectionJob, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionJob{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateProtectionJobExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionJob
 */
func (a *ProtectionJobsApiService) UpdateProtectionJobExecute(r ApiUpdateProtectionJobRequest) (ProtectionJob, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.UpdateProtectionJob")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return localVarReturnValue, nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProtectionJobsStateRequest struct {
	ctx _context.Context
	ApiService *ProtectionJobsApiService
	Body *UpdateProtectionJobsStateRequestBody
}

/*

func (r ApiUpdateProtectionJobsStateRequest) Body(body UpdateProtectionJobsStateRequestBody) ApiUpdateProtectionJobsStateRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateProtectionJobsStateRequest) Execute() (UpdateProtectionJobsState, *_nethttp.Response, error) {
	return r.ApiService.UpdateProtectionJobsStateExecute(r)
}

 * UpdateProtectionJobsState Perform an action like pause, resume, activate, deactivate on all the specified Protection Jobs.
 * Note that the pause or resume actions will take effect from next Protection
Run. Also, user can specify only one type of action on all the Protection Jobs.
Deactivate and activate actions are independent of pause and resume state.
Deactivate and activate actions are useful in case of failover situations.

Returns success if the state of all the Protection Jobs state is changed
successfully.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateProtectionJobsStateRequest
 
func (a *ProtectionJobsApiService) UpdateProtectionJobsState(ctx _context.Context) ApiUpdateProtectionJobsStateRequest {
	return ApiUpdateProtectionJobsStateRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionJobsApiService) UpdateProtectionJobsState(r ApiUpdateProtectionJobsStateRequest) (UpdateProtectionJobsState, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return UpdateProtectionJobsState{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateProtectionJobsStateExecute(r)
}


/*
 * Execute executes the request
 * @return UpdateProtectionJobsState
 */
func (a *ProtectionJobsApiService) UpdateProtectionJobsStateExecute(r ApiUpdateProtectionJobsStateRequest) (UpdateProtectionJobsState, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateProtectionJobsState
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionJobsApiService.UpdateProtectionJobsState")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionJobs/states"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
