/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ProtectionRunsApiService ProtectionRunsApi service
type ProtectionRunsApiService service

type ApiCancelProtectionJobRunRequest struct {
	ctx _context.Context
	ApiService *ProtectionRunsApiService
	Id int64
	Body *CancelProtectionJobRunParam
}

/*

func (r ApiCancelProtectionJobRunRequest) Body(body CancelProtectionJobRunParam) ApiCancelProtectionJobRunRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiCancelProtectionJobRunRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CancelProtectionJobRunExecute(r)
}

 * CancelProtectionJobRun Cancel a Protection Job run.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Specifies a unique id of the Protection Job.
 * @return ApiCancelProtectionJobRunRequest
 
func (a *ProtectionRunsApiService) CancelProtectionJobRun(ctx _context.Context, id int64) ApiCancelProtectionJobRunRequest {
	return ApiCancelProtectionJobRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}
*/

func (a *ProtectionRunsApiService) CancelProtectionJobRun(r ApiCancelProtectionJobRunRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.CancelProtectionJobRunExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ProtectionRunsApiService) CancelProtectionJobRunExecute(r ApiCancelProtectionJobRunRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionRunsApiService.CancelProtectionJobRun")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionRuns/cancel/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.Id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetProtectionRunErrorsRequest struct {
	ctx _context.Context
	ApiService *ProtectionRunsApiService
	JobId *int64
	StartTimeUsecs *int64
	TaskId *int64
	LimitNumberOfErrors *int64
	PaginationCookie *string
}

/*

func (r ApiGetProtectionRunErrorsRequest) JobId(jobId int64) ApiGetProtectionRunErrorsRequest {
	r.jobId = &jobId
	return r
}
func (r ApiGetProtectionRunErrorsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionRunErrorsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetProtectionRunErrorsRequest) TaskId(taskId int64) ApiGetProtectionRunErrorsRequest {
	r.taskId = &taskId
	return r
}
func (r ApiGetProtectionRunErrorsRequest) LimitNumberOfErrors(limitNumberOfErrors int64) ApiGetProtectionRunErrorsRequest {
	r.limitNumberOfErrors = &limitNumberOfErrors
	return r
}
func (r ApiGetProtectionRunErrorsRequest) PaginationCookie(paginationCookie string) ApiGetProtectionRunErrorsRequest {
	r.paginationCookie = &paginationCookie
	return r
}
*/

/*
func (r ApiGetProtectionRunErrorsRequest) Execute() (ProtectionRunErrors, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionRunErrorsExecute(r)
}

 * GetProtectionRunErrors List Protection Job Run Errors filtered by the specified parameters.
 * jobId, startTimeUsecs and taskId have to be provided to get the a list of
errors for a job run task.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectionRunErrorsRequest
 
func (a *ProtectionRunsApiService) GetProtectionRunErrors(ctx _context.Context) ApiGetProtectionRunErrorsRequest {
	return ApiGetProtectionRunErrorsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionRunsApiService) GetProtectionRunErrors(r ApiGetProtectionRunErrorsRequest) (ProtectionRunErrors, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionRunErrors{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionRunErrorsExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionRunErrors
 */
func (a *ProtectionRunsApiService) GetProtectionRunErrorsExecute(r ApiGetProtectionRunErrorsRequest) (ProtectionRunErrors, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionRunErrors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionRunsApiService.GetProtectionRunErrors")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionRuns/errors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.JobId == nil {
		return localVarReturnValue, nil, reportError("JobId is required and must be specified")
	}
	if r.StartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("StartTimeUsecs is required and must be specified")
	}
	if r.TaskId == nil {
		return localVarReturnValue, nil, reportError("TaskId is required and must be specified")
	}

	localVarQueryParams.Add("jobId", parameterToString(*r.JobId, ""))
	localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	localVarQueryParams.Add("taskId", parameterToString(*r.TaskId, ""))
	if r.LimitNumberOfErrors != nil {
		localVarQueryParams.Add("limitNumberOfErrors", parameterToString(*r.LimitNumberOfErrors, ""))
	}
	if r.PaginationCookie != nil {
		localVarQueryParams.Add("paginationCookie", parameterToString(*r.PaginationCookie, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionRunsRequest struct {
	ctx _context.Context
	ApiService *ProtectionRunsApiService
	JobId *int64
	IncludeRpoSnapshots *bool
	StartedTimeUsecs *int64
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	NumRuns *int64
	ExcludeTasks *bool
	SourceId *int64
	RunTypes *[]string
	ExcludeErrorRuns *bool
	ExcludeNonRestoreableRuns *bool
	OnlyReturnShellInfo *bool
}

/*

func (r ApiGetProtectionRunsRequest) JobId(jobId int64) ApiGetProtectionRunsRequest {
	r.jobId = &jobId
	return r
}
func (r ApiGetProtectionRunsRequest) IncludeRpoSnapshots(includeRpoSnapshots bool) ApiGetProtectionRunsRequest {
	r.includeRpoSnapshots = &includeRpoSnapshots
	return r
}
func (r ApiGetProtectionRunsRequest) StartedTimeUsecs(startedTimeUsecs int64) ApiGetProtectionRunsRequest {
	r.startedTimeUsecs = &startedTimeUsecs
	return r
}
func (r ApiGetProtectionRunsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionRunsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetProtectionRunsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionRunsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiGetProtectionRunsRequest) NumRuns(numRuns int64) ApiGetProtectionRunsRequest {
	r.numRuns = &numRuns
	return r
}
func (r ApiGetProtectionRunsRequest) ExcludeTasks(excludeTasks bool) ApiGetProtectionRunsRequest {
	r.excludeTasks = &excludeTasks
	return r
}
func (r ApiGetProtectionRunsRequest) SourceId(sourceId int64) ApiGetProtectionRunsRequest {
	r.sourceId = &sourceId
	return r
}
func (r ApiGetProtectionRunsRequest) RunTypes(runTypes []string) ApiGetProtectionRunsRequest {
	r.runTypes = &runTypes
	return r
}
func (r ApiGetProtectionRunsRequest) ExcludeErrorRuns(excludeErrorRuns bool) ApiGetProtectionRunsRequest {
	r.excludeErrorRuns = &excludeErrorRuns
	return r
}
func (r ApiGetProtectionRunsRequest) ExcludeNonRestoreableRuns(excludeNonRestoreableRuns bool) ApiGetProtectionRunsRequest {
	r.excludeNonRestoreableRuns = &excludeNonRestoreableRuns
	return r
}
func (r ApiGetProtectionRunsRequest) OnlyReturnShellInfo(onlyReturnShellInfo bool) ApiGetProtectionRunsRequest {
	r.onlyReturnShellInfo = &onlyReturnShellInfo
	return r
}
*/

/*
func (r ApiGetProtectionRunsRequest) Execute() ([]ProtectionRunInstance, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionRunsExecute(r)
}

 * GetProtectionRuns List Protection Job Runs filtered by the specified parameters.
 * If no parameters are specified, Job Runs currently
on the Cohesity Cluster are returned. Both running and completed Job Runs
are reported.
Specifying parameters filters the results that are returned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectionRunsRequest
 
func (a *ProtectionRunsApiService) GetProtectionRuns(ctx _context.Context) ApiGetProtectionRunsRequest {
	return ApiGetProtectionRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionRunsApiService) GetProtectionRuns(r ApiGetProtectionRunsRequest) ([]ProtectionRunInstance, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ProtectionRunInstance{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionRunsExecute(r)
}


/*
 * Execute executes the request
 * @return []ProtectionRunInstance
 */
func (a *ProtectionRunsApiService) GetProtectionRunsExecute(r ApiGetProtectionRunsRequest) ([]ProtectionRunInstance, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ProtectionRunInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionRunsApiService.GetProtectionRuns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionRuns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.JobId != nil {
		localVarQueryParams.Add("jobId", parameterToString(*r.JobId, ""))
	}
	if r.IncludeRpoSnapshots != nil {
		localVarQueryParams.Add("includeRpoSnapshots", parameterToString(*r.IncludeRpoSnapshots, ""))
	}
	if r.StartedTimeUsecs != nil {
		localVarQueryParams.Add("startedTimeUsecs", parameterToString(*r.StartedTimeUsecs, ""))
	}
	if r.StartTimeUsecs != nil {
		localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	}
	if r.EndTimeUsecs != nil {
		localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	}
	if r.NumRuns != nil {
		localVarQueryParams.Add("numRuns", parameterToString(*r.NumRuns, ""))
	}
	if r.ExcludeTasks != nil {
		localVarQueryParams.Add("excludeTasks", parameterToString(*r.ExcludeTasks, ""))
	}
	if r.SourceId != nil {
		localVarQueryParams.Add("sourceId", parameterToString(*r.SourceId, ""))
	}
	if r.RunTypes != nil {
		localVarQueryParams.Add("runTypes", parameterToString(*r.RunTypes, "csv"))
	}
	if r.ExcludeErrorRuns != nil {
		localVarQueryParams.Add("excludeErrorRuns", parameterToString(*r.ExcludeErrorRuns, ""))
	}
	if r.ExcludeNonRestoreableRuns != nil {
		localVarQueryParams.Add("excludeNonRestoreableRuns", parameterToString(*r.ExcludeNonRestoreableRuns, ""))
	}
	if r.OnlyReturnShellInfo != nil {
		localVarQueryParams.Add("onlyReturnShellInfo", parameterToString(*r.OnlyReturnShellInfo, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProtectionRunsRequest struct {
	ctx _context.Context
	ApiService *ProtectionRunsApiService
	Body *UpdateProtectionJobRunsParam
}

/*

func (r ApiUpdateProtectionRunsRequest) Body(body UpdateProtectionJobRunsParam) ApiUpdateProtectionRunsRequest {
	r.body = &body
	return r
}
*/

/*
func (r ApiUpdateProtectionRunsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateProtectionRunsExecute(r)
}

 * UpdateProtectionRuns Update how long Protection Job Runs and their snapshots are retained on the Cohesity Cluster.
 * Update the expiration date (retention period) for the specified Protection
Job Runs and their snapshots.
After an expiration time is reached, the Job Run and its snapshots are deleted.
If an expiration time of 0 is specified, a Job Run and its snapshots
are immediately deleted.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUpdateProtectionRunsRequest
 
func (a *ProtectionRunsApiService) UpdateProtectionRuns(ctx _context.Context) ApiUpdateProtectionRunsRequest {
	return ApiUpdateProtectionRunsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *ProtectionRunsApiService) UpdateProtectionRuns(r ApiUpdateProtectionRunsRequest) (*_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.UpdateProtectionRunsExecute(r)
}


/*
 * Execute executes the request
 */
func (a *ProtectionRunsApiService) UpdateProtectionRunsExecute(r ApiUpdateProtectionRunsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProtectionRunsApiService.UpdateProtectionRuns")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/protectionRuns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Body == nil {
		return nil, reportError("Body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.Body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
