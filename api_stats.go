/*
 * Cohesity REST API
 *
 * This API list provides operations for interfacing with the Cohesity Cluster.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesitysdk

import (
	"bytes"
	"reflect"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"regexp"
)

// Linger please
var (
	_ _context.Context
)

// StatsApiService StatsApi service
type StatsApiService service

type ApiGetActiveAlertsStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	StartTimeUsecs *int64
	EndTimeUsecs *int64
}

/*

func (r ApiGetActiveAlertsStatsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetActiveAlertsStatsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetActiveAlertsStatsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetActiveAlertsStatsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
*/

/*
func (r ApiGetActiveAlertsStatsRequest) Execute() (ActiveAlertsStats, *_nethttp.Response, error) {
	return r.ApiService.GetActiveAlertsStatsExecute(r)
}

 * GetActiveAlertsStats Compute the statistics on the active Alerts generated on the cluster.
 * Compute the statistics on the active Alerts generated on the cluster based on the provided time interval.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetActiveAlertsStatsRequest
 
func (a *StatsApiService) GetActiveAlertsStats(ctx _context.Context) ApiGetActiveAlertsStatsRequest {
	return ApiGetActiveAlertsStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetActiveAlertsStats(r ApiGetActiveAlertsStatsRequest) (ActiveAlertsStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ActiveAlertsStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetActiveAlertsStatsExecute(r)
}


/*
 * Execute executes the request
 * @return ActiveAlertsStats
 */
func (a *StatsApiService) GetActiveAlertsStatsExecute(r ApiGetActiveAlertsStatsRequest) (ActiveAlertsStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveAlertsStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetActiveAlertsStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/alerts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.StartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("StartTimeUsecs is required and must be specified")
	}
	if r.EndTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("EndTimeUsecs is required and must be specified")
	}

	localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConsumerStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	ConsumerType *string
	MaxCount *int64
	Cookie *string
	ConsumerIdList *[]int64
	ConsumerEntityIdList *[]string
	FetchViewBoxName *bool
	FetchTenantName *bool
	FetchProtectionPolicy *bool
	FetchProtectionEnvironment *bool
	ViewBoxesIdList *[]int64
	OrganizationsIdList *[]string
	TenantIds *[]string
	IncludeServiceProvider *bool
}

/*

func (r ApiGetConsumerStatsRequest) ConsumerType(consumerType string) ApiGetConsumerStatsRequest {
	r.consumerType = &consumerType
	return r
}
func (r ApiGetConsumerStatsRequest) MaxCount(maxCount int64) ApiGetConsumerStatsRequest {
	r.maxCount = &maxCount
	return r
}
func (r ApiGetConsumerStatsRequest) Cookie(cookie string) ApiGetConsumerStatsRequest {
	r.cookie = &cookie
	return r
}
func (r ApiGetConsumerStatsRequest) ConsumerIdList(consumerIdList []int64) ApiGetConsumerStatsRequest {
	r.consumerIdList = &consumerIdList
	return r
}
func (r ApiGetConsumerStatsRequest) ConsumerEntityIdList(consumerEntityIdList []string) ApiGetConsumerStatsRequest {
	r.consumerEntityIdList = &consumerEntityIdList
	return r
}
func (r ApiGetConsumerStatsRequest) FetchViewBoxName(fetchViewBoxName bool) ApiGetConsumerStatsRequest {
	r.fetchViewBoxName = &fetchViewBoxName
	return r
}
func (r ApiGetConsumerStatsRequest) FetchTenantName(fetchTenantName bool) ApiGetConsumerStatsRequest {
	r.fetchTenantName = &fetchTenantName
	return r
}
func (r ApiGetConsumerStatsRequest) FetchProtectionPolicy(fetchProtectionPolicy bool) ApiGetConsumerStatsRequest {
	r.fetchProtectionPolicy = &fetchProtectionPolicy
	return r
}
func (r ApiGetConsumerStatsRequest) FetchProtectionEnvironment(fetchProtectionEnvironment bool) ApiGetConsumerStatsRequest {
	r.fetchProtectionEnvironment = &fetchProtectionEnvironment
	return r
}
func (r ApiGetConsumerStatsRequest) ViewBoxesIdList(viewBoxesIdList []int64) ApiGetConsumerStatsRequest {
	r.viewBoxesIdList = &viewBoxesIdList
	return r
}
func (r ApiGetConsumerStatsRequest) OrganizationsIdList(organizationsIdList []string) ApiGetConsumerStatsRequest {
	r.organizationsIdList = &organizationsIdList
	return r
}
func (r ApiGetConsumerStatsRequest) TenantIds(tenantIds []string) ApiGetConsumerStatsRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetConsumerStatsRequest) IncludeServiceProvider(includeServiceProvider bool) ApiGetConsumerStatsRequest {
	r.includeServiceProvider = &includeServiceProvider
	return r
}
*/

/*
func (r ApiGetConsumerStatsRequest) Execute() (GetConsumerStatsResult, *_nethttp.Response, error) {
	return r.ApiService.GetConsumerStatsExecute(r)
}

 * GetConsumerStats Gets the statistics of consumers.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetConsumerStatsRequest
 
func (a *StatsApiService) GetConsumerStats(ctx _context.Context) ApiGetConsumerStatsRequest {
	return ApiGetConsumerStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetConsumerStats(r ApiGetConsumerStatsRequest) (GetConsumerStatsResult, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return GetConsumerStatsResult{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetConsumerStatsExecute(r)
}


/*
 * Execute executes the request
 * @return GetConsumerStatsResult
 */
func (a *StatsApiService) GetConsumerStatsExecute(r ApiGetConsumerStatsRequest) (GetConsumerStatsResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetConsumerStatsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetConsumerStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/consumers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ConsumerType != nil {
		localVarQueryParams.Add("consumerType", parameterToString(*r.ConsumerType, ""))
	}
	if r.MaxCount != nil {
		localVarQueryParams.Add("maxCount", parameterToString(*r.MaxCount, ""))
	}
	if r.Cookie != nil {
		localVarQueryParams.Add("cookie", parameterToString(*r.Cookie, ""))
	}
	if r.ConsumerIdList != nil {
		localVarQueryParams.Add("consumerIdList", parameterToString(*r.ConsumerIdList, "csv"))
	}
	if r.ConsumerEntityIdList != nil {
		localVarQueryParams.Add("consumerEntityIdList", parameterToString(*r.ConsumerEntityIdList, "csv"))
	}
	if r.FetchViewBoxName != nil {
		localVarQueryParams.Add("fetchViewBoxName", parameterToString(*r.FetchViewBoxName, ""))
	}
	if r.FetchTenantName != nil {
		localVarQueryParams.Add("fetchTenantName", parameterToString(*r.FetchTenantName, ""))
	}
	if r.FetchProtectionPolicy != nil {
		localVarQueryParams.Add("fetchProtectionPolicy", parameterToString(*r.FetchProtectionPolicy, ""))
	}
	if r.FetchProtectionEnvironment != nil {
		localVarQueryParams.Add("fetchProtectionEnvironment", parameterToString(*r.FetchProtectionEnvironment, ""))
	}
	if r.ViewBoxesIdList != nil {
		localVarQueryParams.Add("viewBoxesIdList", parameterToString(*r.ViewBoxesIdList, "csv"))
	}
	if r.OrganizationsIdList != nil {
		localVarQueryParams.Add("organizationsIdList", parameterToString(*r.OrganizationsIdList, "csv"))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.IncludeServiceProvider != nil {
		localVarQueryParams.Add("includeServiceProvider", parameterToString(*r.IncludeServiceProvider, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFileDistributionStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	EntityType *string
}

/*

func (r ApiGetFileDistributionStatsRequest) EntityType(entityType string) ApiGetFileDistributionStatsRequest {
	r.entityType = &entityType
	return r
}
*/

/*
func (r ApiGetFileDistributionStatsRequest) Execute() ([]FileDistributionStats, *_nethttp.Response, error) {
	return r.ApiService.GetFileDistributionStatsExecute(r)
}

 * GetFileDistributionStats Compute the file distribution statistics on a given entity like cluster or storage domain.
 * Compute the file distribution statistics on a given entity like cluster or storage domain.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetFileDistributionStatsRequest
 
func (a *StatsApiService) GetFileDistributionStats(ctx _context.Context) ApiGetFileDistributionStatsRequest {
	return ApiGetFileDistributionStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetFileDistributionStats(r ApiGetFileDistributionStatsRequest) ([]FileDistributionStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []FileDistributionStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetFileDistributionStatsExecute(r)
}


/*
 * Execute executes the request
 * @return []FileDistributionStats
 */
func (a *StatsApiService) GetFileDistributionStatsExecute(r ApiGetFileDistributionStatsRequest) ([]FileDistributionStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []FileDistributionStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetFileDistributionStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.EntityType == nil {
		return localVarReturnValue, nil, reportError("EntityType is required and must be specified")
	}

	localVarQueryParams.Add("entityType", parameterToString(*r.EntityType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLastProtectionRunStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
}

/*

*/

/*
func (r ApiGetLastProtectionRunStatsRequest) Execute() (LastProtectionRunStats, *_nethttp.Response, error) {
	return r.ApiService.GetLastProtectionRunStatsExecute(r)
}

 * GetLastProtectionRunStats Compute stats on last Protection Run for every job.
 * Compute stats on last Protection Run for every job.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetLastProtectionRunStatsRequest
 
func (a *StatsApiService) GetLastProtectionRunStats(ctx _context.Context) ApiGetLastProtectionRunStatsRequest {
	return ApiGetLastProtectionRunStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetLastProtectionRunStats(r ApiGetLastProtectionRunStatsRequest) (LastProtectionRunStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return LastProtectionRunStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetLastProtectionRunStatsExecute(r)
}


/*
 * Execute executes the request
 * @return LastProtectionRunStats
 */
func (a *StatsApiService) GetLastProtectionRunStatsExecute(r ApiGetLastProtectionRunStatsRequest) (LastProtectionRunStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LastProtectionRunStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetLastProtectionRunStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/protectionRuns/lastRun"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectedObjectsSummaryRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	ExcludeTypes *[]string
}

/*

func (r ApiGetProtectedObjectsSummaryRequest) ExcludeTypes(excludeTypes []string) ApiGetProtectedObjectsSummaryRequest {
	r.excludeTypes = &excludeTypes
	return r
}
*/

/*
func (r ApiGetProtectedObjectsSummaryRequest) Execute() (ProtectedObjectsSummary, *_nethttp.Response, error) {
	return r.ApiService.GetProtectedObjectsSummaryExecute(r)
}

 * GetProtectedObjectsSummary Computes the protected objects summary on the cluster.
 * Computes the protected objects summary on the cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectedObjectsSummaryRequest
 
func (a *StatsApiService) GetProtectedObjectsSummary(ctx _context.Context) ApiGetProtectedObjectsSummaryRequest {
	return ApiGetProtectedObjectsSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetProtectedObjectsSummary(r ApiGetProtectedObjectsSummaryRequest) (ProtectedObjectsSummary, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectedObjectsSummary{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectedObjectsSummaryExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectedObjectsSummary
 */
func (a *StatsApiService) GetProtectedObjectsSummaryExecute(r ApiGetProtectedObjectsSummaryRequest) (ProtectedObjectsSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectedObjectsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetProtectedObjectsSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/protectionSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ExcludeTypes != nil {
		localVarQueryParams.Add("excludeTypes", parameterToString(*r.ExcludeTypes, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProtectionRunsStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	Status *string
	StartTimeUsecs *int64
	EndTimeUsecs *int64
}

/*

func (r ApiGetProtectionRunsStatsRequest) Status(status string) ApiGetProtectionRunsStatsRequest {
	r.status = &status
	return r
}
func (r ApiGetProtectionRunsStatsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetProtectionRunsStatsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetProtectionRunsStatsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetProtectionRunsStatsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
*/

/*
func (r ApiGetProtectionRunsStatsRequest) Execute() (ProtectionRunsStats, *_nethttp.Response, error) {
	return r.ApiService.GetProtectionRunsStatsExecute(r)
}

 * GetProtectionRunsStats Compute the statistics on the Protection Runs for the cluster.
 * Compute the statistics of the Protection Runs based on the input filters. This endpoint provides a snapshot of count of Protection Runs of a specified status on a specified time interval.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetProtectionRunsStatsRequest
 
func (a *StatsApiService) GetProtectionRunsStats(ctx _context.Context) ApiGetProtectionRunsStatsRequest {
	return ApiGetProtectionRunsStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetProtectionRunsStats(r ApiGetProtectionRunsStatsRequest) (ProtectionRunsStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ProtectionRunsStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetProtectionRunsStatsExecute(r)
}


/*
 * Execute executes the request
 * @return ProtectionRunsStats
 */
func (a *StatsApiService) GetProtectionRunsStatsExecute(r ApiGetProtectionRunsStatsRequest) (ProtectionRunsStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ProtectionRunsStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetProtectionRunsStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/protectionRuns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.Status == nil {
		return localVarReturnValue, nil, reportError("Status is required and must be specified")
	}
	if r.StartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("StartTimeUsecs is required and must be specified")
	}
	if r.EndTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("EndTimeUsecs is required and must be specified")
	}

	localVarQueryParams.Add("status", parameterToString(*r.Status, ""))
	localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRestoreStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	StartTimeUsecs *int64
	EndTimeUsecs *int64
}

/*

func (r ApiGetRestoreStatsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetRestoreStatsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetRestoreStatsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetRestoreStatsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
*/

/*
func (r ApiGetRestoreStatsRequest) Execute() (RestoreStats, *_nethttp.Response, error) {
	return r.ApiService.GetRestoreStatsExecute(r)
}

 * GetRestoreStats Compute the statistics on the Restore tasks on the cluster.
 * Compute the statistics on the Restore tasks on the cluster based on the provided time interval.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetRestoreStatsRequest
 
func (a *StatsApiService) GetRestoreStats(ctx _context.Context) ApiGetRestoreStatsRequest {
	return ApiGetRestoreStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetRestoreStats(r ApiGetRestoreStatsRequest) (RestoreStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return RestoreStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetRestoreStatsExecute(r)
}


/*
 * Execute executes the request
 * @return RestoreStats
 */
func (a *StatsApiService) GetRestoreStatsExecute(r ApiGetRestoreStatsRequest) (RestoreStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestoreStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetRestoreStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/restores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.StartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("StartTimeUsecs is required and must be specified")
	}
	if r.EndTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("EndTimeUsecs is required and must be specified")
	}

	localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStorageStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
}

/*

*/

/*
func (r ApiGetStorageStatsRequest) Execute() (StorageStats, *_nethttp.Response, error) {
	return r.ApiService.GetStorageStatsExecute(r)
}

 * GetStorageStats Computes the storage stats on the cluster.
 * Computes the storage stats on the cluster.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetStorageStatsRequest
 
func (a *StatsApiService) GetStorageStats(ctx _context.Context) ApiGetStorageStatsRequest {
	return ApiGetStorageStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetStorageStats(r ApiGetStorageStatsRequest) (StorageStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return StorageStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetStorageStatsExecute(r)
}


/*
 * Execute executes the request
 * @return StorageStats
 */
func (a *StatsApiService) GetStorageStatsExecute(r ApiGetStorageStatsRequest) (StorageStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StorageStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetStorageStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/storage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTenantStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	ConsumerType *string
	SkipGroupByTenant *bool
	MaxCount *int64
	Cookie *string
	OutputFormat *string
	ViewBoxesIdList *[]int64
	OrganizationsIdList *[]string
	TenantIds *[]string
	IncludeServiceProvider *bool
}

/*

func (r ApiGetTenantStatsRequest) ConsumerType(consumerType string) ApiGetTenantStatsRequest {
	r.consumerType = &consumerType
	return r
}
func (r ApiGetTenantStatsRequest) SkipGroupByTenant(skipGroupByTenant bool) ApiGetTenantStatsRequest {
	r.skipGroupByTenant = &skipGroupByTenant
	return r
}
func (r ApiGetTenantStatsRequest) MaxCount(maxCount int64) ApiGetTenantStatsRequest {
	r.maxCount = &maxCount
	return r
}
func (r ApiGetTenantStatsRequest) Cookie(cookie string) ApiGetTenantStatsRequest {
	r.cookie = &cookie
	return r
}
func (r ApiGetTenantStatsRequest) OutputFormat(outputFormat string) ApiGetTenantStatsRequest {
	r.outputFormat = &outputFormat
	return r
}
func (r ApiGetTenantStatsRequest) ViewBoxesIdList(viewBoxesIdList []int64) ApiGetTenantStatsRequest {
	r.viewBoxesIdList = &viewBoxesIdList
	return r
}
func (r ApiGetTenantStatsRequest) OrganizationsIdList(organizationsIdList []string) ApiGetTenantStatsRequest {
	r.organizationsIdList = &organizationsIdList
	return r
}
func (r ApiGetTenantStatsRequest) TenantIds(tenantIds []string) ApiGetTenantStatsRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetTenantStatsRequest) IncludeServiceProvider(includeServiceProvider bool) ApiGetTenantStatsRequest {
	r.includeServiceProvider = &includeServiceProvider
	return r
}
*/

/*
func (r ApiGetTenantStatsRequest) Execute() (GetTenantStatsResult, *_nethttp.Response, error) {
	return r.ApiService.GetTenantStatsExecute(r)
}

 * GetTenantStats Gets the statistics of organizations (tenant).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetTenantStatsRequest
 
func (a *StatsApiService) GetTenantStats(ctx _context.Context) ApiGetTenantStatsRequest {
	return ApiGetTenantStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetTenantStats(r ApiGetTenantStatsRequest) (GetTenantStatsResult, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return GetTenantStatsResult{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetTenantStatsExecute(r)
}


/*
 * Execute executes the request
 * @return GetTenantStatsResult
 */
func (a *StatsApiService) GetTenantStatsExecute(r ApiGetTenantStatsRequest) (GetTenantStatsResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetTenantStatsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetTenantStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/tenants"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ConsumerType != nil {
		localVarQueryParams.Add("consumerType", parameterToString(*r.ConsumerType, ""))
	}
	if r.SkipGroupByTenant != nil {
		localVarQueryParams.Add("skipGroupByTenant", parameterToString(*r.SkipGroupByTenant, ""))
	}
	if r.MaxCount != nil {
		localVarQueryParams.Add("maxCount", parameterToString(*r.MaxCount, ""))
	}
	if r.Cookie != nil {
		localVarQueryParams.Add("cookie", parameterToString(*r.Cookie, ""))
	}
	if r.OutputFormat != nil {
		localVarQueryParams.Add("outputFormat", parameterToString(*r.OutputFormat, ""))
	}
	if r.ViewBoxesIdList != nil {
		localVarQueryParams.Add("viewBoxesIdList", parameterToString(*r.ViewBoxesIdList, "csv"))
	}
	if r.OrganizationsIdList != nil {
		localVarQueryParams.Add("organizationsIdList", parameterToString(*r.OrganizationsIdList, "csv"))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.IncludeServiceProvider != nil {
		localVarQueryParams.Add("includeServiceProvider", parameterToString(*r.IncludeServiceProvider, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultProviderStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	RunType *string
}

/*

func (r ApiGetVaultProviderStatsRequest) RunType(runType string) ApiGetVaultProviderStatsRequest {
	r.runType = &runType
	return r
}
*/

/*
func (r ApiGetVaultProviderStatsRequest) Execute() ([]VaultProviderStatsInfo, *_nethttp.Response, error) {
	return r.ApiService.GetVaultProviderStatsExecute(r)
}

 * GetVaultProviderStats Compute the size and count of entities on vaults.
 * Compute the size and count of entities on vaults.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetVaultProviderStatsRequest
 
func (a *StatsApiService) GetVaultProviderStats(ctx _context.Context) ApiGetVaultProviderStatsRequest {
	return ApiGetVaultProviderStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetVaultProviderStats(r ApiGetVaultProviderStatsRequest) ([]VaultProviderStatsInfo, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []VaultProviderStatsInfo{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetVaultProviderStatsExecute(r)
}


/*
 * Execute executes the request
 * @return []VaultProviderStatsInfo
 */
func (a *StatsApiService) GetVaultProviderStatsExecute(r ApiGetVaultProviderStatsRequest) ([]VaultProviderStatsInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []VaultProviderStatsInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetVaultProviderStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/vaults/providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.RunType == nil {
		return localVarReturnValue, nil, reportError("RunType is required and must be specified")
	}

	localVarQueryParams.Add("runType", parameterToString(*r.RunType, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultRunStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	RunType *string
	StartTimeUsecs *int64
	EndTimeUsecs *int64
	Interval *string
}

/*

func (r ApiGetVaultRunStatsRequest) RunType(runType string) ApiGetVaultRunStatsRequest {
	r.runType = &runType
	return r
}
func (r ApiGetVaultRunStatsRequest) StartTimeUsecs(startTimeUsecs int64) ApiGetVaultRunStatsRequest {
	r.startTimeUsecs = &startTimeUsecs
	return r
}
func (r ApiGetVaultRunStatsRequest) EndTimeUsecs(endTimeUsecs int64) ApiGetVaultRunStatsRequest {
	r.endTimeUsecs = &endTimeUsecs
	return r
}
func (r ApiGetVaultRunStatsRequest) Interval(interval string) ApiGetVaultRunStatsRequest {
	r.interval = &interval
	return r
}
*/

/*
func (r ApiGetVaultRunStatsRequest) Execute() (VaultRunStatsSummary, *_nethttp.Response, error) {
	return r.ApiService.GetVaultRunStatsExecute(r)
}

 * GetVaultRunStats Compute the statistics on protection runs to or from a vault.
 * Compute the statistics on protection runs to or from a vault and return a trend line of the result.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetVaultRunStatsRequest
 
func (a *StatsApiService) GetVaultRunStats(ctx _context.Context) ApiGetVaultRunStatsRequest {
	return ApiGetVaultRunStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetVaultRunStats(r ApiGetVaultRunStatsRequest) (VaultRunStatsSummary, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return VaultRunStatsSummary{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetVaultRunStatsExecute(r)
}


/*
 * Execute executes the request
 * @return VaultRunStatsSummary
 */
func (a *StatsApiService) GetVaultRunStatsExecute(r ApiGetVaultRunStatsRequest) (VaultRunStatsSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VaultRunStatsSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetVaultRunStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/vaults/runs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.RunType == nil {
		return localVarReturnValue, nil, reportError("RunType is required and must be specified")
	}
	if r.StartTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("StartTimeUsecs is required and must be specified")
	}
	if r.EndTimeUsecs == nil {
		return localVarReturnValue, nil, reportError("EndTimeUsecs is required and must be specified")
	}
	if r.Interval == nil {
		return localVarReturnValue, nil, reportError("Interval is required and must be specified")
	}

	localVarQueryParams.Add("runType", parameterToString(*r.RunType, ""))
	localVarQueryParams.Add("startTimeUsecs", parameterToString(*r.StartTimeUsecs, ""))
	localVarQueryParams.Add("endTimeUsecs", parameterToString(*r.EndTimeUsecs, ""))
	localVarQueryParams.Add("interval", parameterToString(*r.Interval, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVaultStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
}

/*

*/

/*
func (r ApiGetVaultStatsRequest) Execute() (VaultStats, *_nethttp.Response, error) {
	return r.ApiService.GetVaultStatsExecute(r)
}

 * GetVaultStats Compute the statistics on vaults.
 * Compute the statistics on vaults.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetVaultStatsRequest
 
func (a *StatsApiService) GetVaultStats(ctx _context.Context) ApiGetVaultStatsRequest {
	return ApiGetVaultStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetVaultStats(r ApiGetVaultStatsRequest) (VaultStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return VaultStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetVaultStatsExecute(r)
}


/*
 * Execute executes the request
 * @return VaultStats
 */
func (a *StatsApiService) GetVaultStatsExecute(r ApiGetVaultStatsRequest) (VaultStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VaultStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetVaultStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/vaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewBoxStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	ViewBoxesIdList *[]int64
	OrganizationsIdList *[]string
	TenantIds *[]string
	IncludeServiceProvider *bool
}

/*

func (r ApiGetViewBoxStatsRequest) ViewBoxesIdList(viewBoxesIdList []int64) ApiGetViewBoxStatsRequest {
	r.viewBoxesIdList = &viewBoxesIdList
	return r
}
func (r ApiGetViewBoxStatsRequest) OrganizationsIdList(organizationsIdList []string) ApiGetViewBoxStatsRequest {
	r.organizationsIdList = &organizationsIdList
	return r
}
func (r ApiGetViewBoxStatsRequest) TenantIds(tenantIds []string) ApiGetViewBoxStatsRequest {
	r.tenantIds = &tenantIds
	return r
}
func (r ApiGetViewBoxStatsRequest) IncludeServiceProvider(includeServiceProvider bool) ApiGetViewBoxStatsRequest {
	r.includeServiceProvider = &includeServiceProvider
	return r
}
*/

/*
func (r ApiGetViewBoxStatsRequest) Execute() (GetViewBoxStatsResult, *_nethttp.Response, error) {
	return r.ApiService.GetViewBoxStatsExecute(r)
}

 * GetViewBoxStats Gets the statistics of view boxes (storage domain).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetViewBoxStatsRequest
 
func (a *StatsApiService) GetViewBoxStats(ctx _context.Context) ApiGetViewBoxStatsRequest {
	return ApiGetViewBoxStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetViewBoxStats(r ApiGetViewBoxStatsRequest) (GetViewBoxStatsResult, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return GetViewBoxStatsResult{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetViewBoxStatsExecute(r)
}


/*
 * Execute executes the request
 * @return GetViewBoxStatsResult
 */
func (a *StatsApiService) GetViewBoxStatsExecute(r ApiGetViewBoxStatsRequest) (GetViewBoxStatsResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetViewBoxStatsResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetViewBoxStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/viewBoxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ViewBoxesIdList != nil {
		localVarQueryParams.Add("viewBoxesIdList", parameterToString(*r.ViewBoxesIdList, "csv"))
	}
	if r.OrganizationsIdList != nil {
		localVarQueryParams.Add("organizationsIdList", parameterToString(*r.OrganizationsIdList, "csv"))
	}
	if r.TenantIds != nil {
		localVarQueryParams.Add("tenantIds", parameterToString(*r.TenantIds, "csv"))
	}
	if r.IncludeServiceProvider != nil {
		localVarQueryParams.Add("includeServiceProvider", parameterToString(*r.IncludeServiceProvider, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewProtocolStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
}

/*

*/

/*
func (r ApiGetViewProtocolStatsRequest) Execute() ([]ViewProtocolStats, *_nethttp.Response, error) {
	return r.ApiService.GetViewProtocolStatsExecute(r)
}

 * GetViewProtocolStats Compute the protocol statistics on Views.
 * Compute the protocol statistics on Views.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetViewProtocolStatsRequest
 
func (a *StatsApiService) GetViewProtocolStats(ctx _context.Context) ApiGetViewProtocolStatsRequest {
	return ApiGetViewProtocolStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetViewProtocolStats(r ApiGetViewProtocolStatsRequest) ([]ViewProtocolStats, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return []ViewProtocolStats{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetViewProtocolStatsExecute(r)
}


/*
 * Execute executes the request
 * @return []ViewProtocolStats
 */
func (a *StatsApiService) GetViewProtocolStatsExecute(r ApiGetViewProtocolStatsRequest) ([]ViewProtocolStats, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ViewProtocolStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetViewProtocolStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/views/protocols"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetViewStatsRequest struct {
	ctx _context.Context
	ApiService *StatsApiService
	Metric *string
	NumTopViews *int64
}

/*

func (r ApiGetViewStatsRequest) Metric(metric string) ApiGetViewStatsRequest {
	r.metric = &metric
	return r
}
func (r ApiGetViewStatsRequest) NumTopViews(numTopViews int64) ApiGetViewStatsRequest {
	r.numTopViews = &numTopViews
	return r
}
*/

/*
func (r ApiGetViewStatsRequest) Execute() (ViewStatsSnapshot, *_nethttp.Response, error) {
	return r.ApiService.GetViewStatsExecute(r)
}

 * GetViewStats Compute the statistics on Views.
 * Compute the statistics on Views.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetViewStatsRequest
 
func (a *StatsApiService) GetViewStats(ctx _context.Context) ApiGetViewStatsRequest {
	return ApiGetViewStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}
*/

func (a *StatsApiService) GetViewStats(r ApiGetViewStatsRequest) (ViewStatsSnapshot, *_nethttp.Response, error) {
	if reflect.TypeOf(*a).Name() != "AccessTokensApiService" {
		token, err := GetTokenHelper(a.client)

		if err != nil {
			return ViewStatsSnapshot{}, nil, GenericOpenAPIError{
				error: err.Error(),
			}
		}

		r.ctx = _context.WithValue(_context.Background(), ContextAPIKeys, map[string]APIKey{"TokenHeader": {Key: token, Prefix: "Bearer"}})
	} else {
		r.ctx = _context.Background()
	}
	r.ApiService = a

	return r.ApiService.GetViewStatsExecute(r)
}


/*
 * Execute executes the request
 * @return ViewStatsSnapshot
 */
func (a *StatsApiService) GetViewStatsExecute(r ApiGetViewStatsRequest) (ViewStatsSnapshot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ViewStatsSnapshot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StatsApiService.GetViewStats")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/public/stats/views"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.Metric != nil {
		localVarQueryParams.Add("metric", parameterToString(*r.Metric, ""))
	}
	if r.NumTopViews != nil {
		localVarQueryParams.Add("numTopViews", parameterToString(*r.NumTopViews, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["TokenHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		if match, matchErr := regexp.MatchString(`Client.Timeout exceeded`, err.Error()); matchErr == nil && match {
			serName := reflect.TypeOf(r).Name()
			serName = serName[3:len(serName)-7] // remove Api prefix, and Request suffix
			err = GenericOpenAPIError{
				error: "Network timeout when making a request of " + serName +
					". Consider increase the request timeout in the client config." ,
			}
		}
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
